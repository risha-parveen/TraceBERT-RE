issue_id,commit_id,p_x,l_x,issue_desc,issue_comments,summary,diff,files,created_at,closed_at,commit_time
6,4fa9eda88b8e6a94c4e6662a86f87da7bc41d060,2.886468791984953e-05,1,"An end user wants to know when an expression will always return empty due to table enforcement rule ( e.g primary/foreign key , CHECK constraint ) Minimal implementation : detect PKEY , FKEY and CHECK constraints",Detect implied expressions,Merge pull request # 59 from Project-C-SQL/feat/implied-expression,"insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 221 , 487.39 , 227 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 13 , 'Marion ' , 'Penelli ' , ' B ' , 'Adaline ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 14 , 586.06 , 181 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 153 , 350.78 , 247 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 5 , 'Callida ' , 'Tomasello ' , ' B ' , 'Abiel ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 50 , 306.71 , 235 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 10 , 414.55 , 234 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 246 , 510.74 , 188 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 78 , 569.4 , 99 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 93 , 452.63 , 115 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 218 , 389.51 , 177 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 166 , 95.01 , 189 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 97 , 313.39 , 241 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 119 , 579.12 , 43 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 176 , 'Marylou ' , 'Guilloton ' , ' C ' , 'Bridget ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 23 , 'Jeanette ' , 'Fincher ' , ' B ' , 'Adriane ' ) ; return postgresql insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 132 , 'Olympe ' , 'Faber ' , ' B ' , 'Barbery ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 233 , 87.21 , 179 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 196 , 'Louisa ' , 'Matasov ' , ' B ' , 'Carmon ' ) ; return None insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 42 , 561.85 , 222 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 78 , 'Matilde ' , 'Froome ' , ' B ' , 'Angelica ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 159 , 281.36 , 198 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 20 , 207.6 , 9 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 216 , 388.15 , 142 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 4 , 144.14 , 157 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 192 , 206.39 , 151 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 24 , 538.88 , 38 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 77 , 'Maegan ' , 'Wheldon ' , ' C ' , 'Angela ' ) ; import pytest insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 82 , 106.39 , 237 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 29 , 'Dawna ' , 'Knipe ' , ' C ' , 'Alanson ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 242 , 356.69 , 244 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 210 , 332.45 , 47 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 63 , 'Gratia ' , 'Moss ' , ' B ' , 'Althea ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 187 , 'Donall ' , 'Casolla ' , ' B ' , 'Calvin ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 32 , 'Aubrie ' , 'Lockitt ' , ' C ' , 'Albert ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 176 , 22.8 , 175 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 245 , 327.9 , 212 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 169 , 'Elsbeth ' , 'Nucciotti ' , ' B ' , 'Bradley ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 37 , 'Talbot ' , 'Keddey ' , ' B ' , 'Aleva ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 237 , 293.23 , 140 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 229 , 89.34 , 147 ) ; len ( qep_analysis_without_constraint_exclusion.root.rfind ( finder ) ) > 0 import copy insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 56 , 'Kaitlin ' , 'Payle ' , ' B ' , 'Allyson ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 44 , 537.56 , 2 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 204 , 212.04 , 203 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 188 , 'Ferguson ' , 'Mackriell ' , ' B ' , 'Cameron ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 122 , 'Myrlene ' , 'Worcs ' , ' B ' , 'Augusta ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 183 , 'Harvey ' , 'Skinn ' , ' B ' , 'Caleb ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 226 , 212.04 , 28 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 201 , 411.07 , 202 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 46 , 362.72 , 240 ) ; SQL_SIMPLE = \ order_id INT insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 242 , 'Brenden ' , 'Simmons ' , ' B ' , 'Clarence ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 52 , 'Gerrilee ' , 'Ackland ' , ' B ' , 'Allan ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 119 , 'Gregg ' , 'Lazenbury ' , ' B ' , 'Aubrey ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 171 , 'Fredrick ' , 'Matuszynski ' , ' C ' , 'Breanna ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 137 , 'Lucilia ' , 'Bentick ' , ' C ' , 'Bartholomew ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 11 , 88.19 , 50 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 162 , 'Jessee ' , 'List ' , ' B ' , 'Billy ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 14 , 'Davon ' , 'Burris ' , ' C ' , 'Addison ' ) ; , order_total_eur DECIMAL ( 6,2 ) NOT NULL insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 32 , 331.93 , 144 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 83 , 'Wolf ' , 'Brenton ' , ' B ' , 'Annette ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 246 , 'Albert ' , 'Heimann ' , ' B ' , 'Cleatus ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 189 , 164.91 , 68 ) ; sql_statement = SQL_CHECK_CONSTRAINT_VIOLATION insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 240 , 384.87 , 107 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 144 , 504.73 , 154 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 127 , 'Rhoda ' , 'Kurton ' , ' C ' , 'Avarilla ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 28 , 'Nanice ' , 'MacMaster ' , ' B ' , 'Alan ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 151 , 221.16 , 212 ) ; sql_statement = SQL_NOT_NULL_CONSTRAINT_VIOLATION insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 148 , 203.36 , 180 ) ; QEPParser ( conn=self.db_connection , constraint_exclusion=False ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 169 , 552.88 , 241 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 57 , 'Vita ' , 'Dunnett ' , ' B ' , 'Allyssa ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 214 , 'Chalmers ' , 'Britton ' , ' C ' , 'Celinda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 70 , 596.2 , 221 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 12 , 'Tiffi ' , 'Riolfo ' , ' C ' , 'Ada ' ) ; WHERE type = ' A ' ; '' '' '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 173 , 'Kristopher ' , 'Mackelworth ' , ' B ' , 'Brenda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 7 , 183.92 , 236 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 219 , 594.84 , 121 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 130 , 'Rora ' , 'Adcock ' , ' C ' , 'Babs ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 162 , 168.92 , 27 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 89 , 556.68 , 74 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 183 , 546.08 , 88 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 118 , 23.96 , 195 ) ; if constraint_exclusion : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 18 , 'Odie ' , 'Rowling ' , ' C ' , 'Adele ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 30 , 'Colin ' , 'Jansie ' , ' C ' , 'Alastair ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 177 , 'Genvieve ' , 'Marthen ' , ' B ' , 'Brittany ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 150 , 439.75 , 18 ) ; import psycopg insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 102 , 'Ricca ' , 'Rupprecht ' , ' B ' , 'Arlene ' ) ; `` One-Time Filter '' : str , insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 227 , 189.25 , 230 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 206 , 226.62 , 228 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 186 , 561.85 , 156 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 1 , 535.36 , 111 ) ; FROM { CUSTOMERS_TABLE_NAME } insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 212 , 179.55 , 180 ) ; parsed_sql , sql_statement , db_connection ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 103 , 14.83 , 183 ) ; def test_check ( sql_parser : SqlParser , db_connection : Connection ) : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 171 , 175.72 , 249 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 128 , 'Jere ' , 'Cometti ' , ' B ' , 'Azariah ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 137 , 417.16 , 215 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 10 , 'Sonnie ' , 'Kelling ' , ' B ' , 'Abram ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 140 , 'Suki ' , 'Flinn ' , ' B ' , 'Bea ' ) ; SELECT * insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 104 , 97.04 , 11 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 115 , 351.68 , 153 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 30 , 435.57 , 105 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 208 , 344.91 , 150 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 239 , 327.06 , 34 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 91 , 'Bobby ' , 'Fortesquieu ' , ' B ' , 'Aquilla ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 121 , 'Clywd ' , 'Stokey ' , ' B ' , 'August ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 28 , 87.44 , 1 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 8 , 424.8 , 244 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 109 , 170.82 , 206 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 181 , 150.37 , 69 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 64 , 'Dyan ' , 'Crosbie ' , ' B ' , 'Alverta ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 194 , 328.76 , 41 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 121 , 132.25 , 50 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 123 , 'Lyon ' , 'Nolleau ' , ' C ' , 'Augustina ' ) ; cur.execute ( `` set constraint_exclusion = on ; '' ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 248 , 321.97 , 195 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 201 , 'Arv ' , 'Spawforth ' , ' B ' , 'Carrie ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 221 , 'Cassondra ' , 'Mattingson ' , ' B ' , 'Chesley ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 96 , 'Tiertza ' , 'Bunford ' , ' C ' , 'Archibald ' ) ; ORDERS_TABLE_NAME = `` implied_expression_test_table_orders '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 202 , 'Sonja ' , 'Pentycross ' , ' B ' , 'Carthaette ' ) ; has_onetime_filter_without_constraint_exclusion = \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 234 , 'Cayla ' , 'Statter ' , ' B ' , 'Christopher ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 146 , 'Dunstan ' , 'Cressey ' , ' B ' , 'Bella ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 240 , 'Britte ' , 'Muge ' , ' B ' , 'Clara ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 156 , 'Allistir ' , 'Frary ' , ' C ' , 'Beth ' ) ; qep_parser_with_constraint_exclusion.parse ( self.sql_statement ) SQL_NO_IMPLIED_EXPRESSION = \ insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 88 , 210.95 , 158 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 117 , 'Marysa ' , 'Wadman ' , ' C ' , 'Asenath ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 133 , 'Clementia ' , 'Fergusson ' , ' B ' , 'Barbie ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 237 , 'Jeramie ' , 'Gallehock ' , ' C ' , 'Cinderella ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 161 , 184.39 , 94 ) ; len ( qep_analysis_with_constraint_exclusion.root.rfind ( finder ) ) > 0 insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 130 , 575.58 , 235 ) ; SqlParser , insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 178 , 'Rogers ' , 'Plose ' , ' B ' , 'Brittney ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 42 , 'Pyotr ' , 'Feldhorn ' , ' C ' , 'Alexis ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 209 , 'Dulcea ' , 'Akister ' , ' C ' , 'Cathleen ' ) ; CREATE TABLE { CUSTOMERS_TABLE_NAME } ( insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 66 , 454.41 , 11 ) ; assert warning_msg ! = None insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 23 , 236.48 , 51 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 41 , 158.78 , 145 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 43 , 133.73 , 196 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 59 , 'Lin ' , 'Race ' , ' B ' , 'Almina ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 182 , 478.47 , 70 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 54 , 591.44 , 145 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 79 , 94.87 , 194 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 128 , 415.86 , 243 ) ; QEPParser , insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 160 , 'Patti ' , 'Louis ' , ' C ' , 'Biddie ' ) ; def finder ( node : QEPNode ) - > bool : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 166 , 'Angelo ' , 'Vanstone ' , ' C ' , 'Boetius ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 98 , 'Elfreda ' , 'Tome ' , ' C ' , 'Ariadne ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 136 , 411.87 , 10 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 157 , 477.53 , 205 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 15 , 47.79 , 248 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 77 , 335.23 , 149 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 57 , 349.14 , 58 ) ; sql_statement = SQL_NO_IMPLIED_EXPRESSION insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 87 , 'Nanette ' , 'McElwee ' , ' B ' , 'Antoinette ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 48 , 'Marve ' , 'Eykel ' , ' C ' , 'Alicia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 61 , 'Blisse ' , 'Dillway ' , ' C ' , 'Alonzo ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 167 , 547.07 , 197 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 45 , 'Seymour ' , 'Mayer ' , ' B ' , 'Alfreda ' ) ; qep_parser_without_constraint_exclusion.parse ( self.sql_statement ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 112 , 38.97 , 239 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 223 , 'Annice ' , 'Haynes ' , ' B ' , 'Chet ' ) ; QEPParser ( conn=self.db_connection , constraint_exclusion=True ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 24 , 'Jacinthe ' , 'Kleeman ' , ' B ' , 'Adrienne ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 62 , 418.98 , 60 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 27 , 137.86 , 21 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 170 , 539.11 , 92 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 67 , 550.21 , 63 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 181 , 'Daria ' , 'Wistance ' , ' C ' , 'Caitlyn ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 26 , 590.52 , 50 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 170 , 'Bard ' , 'Shaw ' , ' C ' , 'Brady ' ) ; self.sql_statement : str = sql_statement ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 45 , 46.05 , 177 ) ; conn : Connection = psycopg.connect ( * * kwargs ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 49 , 376.9 , 89 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 19 , 107.53 , 94 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 92 , 'Raven ' , 'Eilles ' , ' C ' , 'Ara ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 139 , 'Kelsi ' , 'Suddell ' , ' C ' , 'Bazaleel ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 141 , 'Jacinta ' , 'Villiers ' , ' B ' , 'Beatrice ' ) ; class ImpliedExpressionChecker : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 234 , 254.56 , 98 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 48 , 199.52 , 234 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 68 , 73.27 , 189 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 245 , 'Holly ' , 'Roy ' , ' C ' , 'Claudia ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 232 , 330.85 , 204 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 99 , 'Phineas ' , 'Yuryaev ' , ' B ' , 'Arielle ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 114 , 339.9 , 108 ) ; assert checker ! = None insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 142 , 509.25 , 190 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 213 , 'Rubin ' , 'Lunney ' , ' B ' , 'Celeste ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 41 , 'Reilly ' , 'Kennler ' , ' B ' , 'Alexandria ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 76 , 'Ardys ' , 'Currm ' , ' B ' , 'Andriane ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 202 , 99.52 , 171 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 159 , 'Carilyn ' , 'Vinecombe ' , ' B ' , 'Bezaleel ' ) ; DROP TABLE IF EXISTS { ORDERS_TABLE_NAME } ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 75 , 238.65 , 203 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 39 , 42.62 , 95 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 129 , 'Ashla ' , 'De-Ville ' , ' C ' , 'Bab ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 82 , 'Abey ' , 'Darridon ' , ' C ' , 'Anne ' ) ; Returns warning_msg if implied expression is detected , otherwise None . insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 248 , 'Norby ' , 'Biernacki ' , ' C ' , 'Clementine ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 22 , 'Grazia ' , 'Syne ' , ' C ' , 'Adrian ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 153 , 'Alfy ' , 'McCahill ' , ' B ' , 'Bertha ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 214 , 520.52 , 98 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 63 , 542.48 , 52 ) ; customer_id INT insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 17 , 'Carlyle ' , 'Zimek ' , ' B ' , 'Adelbert ' ) ; return SqlParser ( db_connection=postgresql ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 165 , 84.61 , 1 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 142 , 'Elfrieda ' , 'Cleary ' , ' C ' , 'Becca ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 154 , 'Conney ' , 'Riteley ' , ' C ' , 'Bertram ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 180 , 'Leonelle ' , 'Chiommienti ' , ' B ' , 'Caitlin ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 61 , 343.91 , 223 ) ; f '' '' '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 224 , 'Dayle ' , 'Eirwin ' , ' B ' , 'Chick ' ) ; with conn.cursor ( ) as cur : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 190 , 'Kara ' , 'Backs ' , ' B ' , 'Campbell ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 220 , 'Kylen ' , 'Bewicke ' , ' B ' , 'Cheryl ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 113 , 305.06 , 123 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 2 , 'Tomlin ' , 'Nozzolinii ' , ' B ' , 'Abbigail ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 31 , 394.48 , 62 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 141 , 183.27 , 44 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 89 , 'Nickie ' , 'Bloss ' , ' C ' , 'Antonio ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 243 , 209.34 , 31 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 157 , 'Noach ' , 'MacRitchie ' , ' C ' , 'Bethena ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 191 , 'Frankie ' , 'Canny ' , ' B ' , 'Candace ' ) ; from pytest_postgresql import factories Column , , fname VARCHAR ( 50 ) NOT NULL insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 11 , 'Amby ' , 'Ligoe ' , ' C ' , 'Absalom ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 185 , 505.7 , 49 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 250 , 'Langston ' , 'Prosser ' , ' C ' , 'Clifford ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 126 , 'Lilllie ' , 'Annis ' , ' C ' , 'Aurelia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 51 , 'Kennan ' , 'Burstowe ' , ' B ' , 'Alixandra ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 3 , 189.43 , 19 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 163 , 'Gerhardt ' , 'Simcock ' , ' B ' , 'Blanche ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 188 , 495.68 , 39 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 123 , 370.87 , 115 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 74 , 63.02 , 117 ) ; factory = factories.postgresql_proc ( insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 191 , 183.55 , 142 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 116 , 292.86 , 97 ) ; db_connection : Connection ) : checker = ImpliedExpressionChecker ( parsed_sql = sql_parser.parse_one ( sql_statement ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 71 , 'Cynthie ' , 'Rouby ' , ' B ' , 'Anastasia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 47 , 'Tracey ' , 'Sauvan ' , ' B ' , 'Alice ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 129 , 426.3 , 136 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 131 , 255.66 , 127 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 233 , 'Tibold ' , 'Sleigh ' , ' C ' , 'Christoph ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 249 , 'Rhoda ' , 'Leheude ' , ' C ' , 'Cliff ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 146 , 184.13 , 22 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 16 , 330.92 , 130 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 65 , 'Glenna ' , 'Alastair ' , ' C ' , 'Alyssa ' ) ; cur.execute ( insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 225 , 'Egbert ' , 'Vasyunin ' , ' B ' , 'Chloe ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 197 , 'Missie ' , 'Fealty ' , ' C ' , 'Carol ' ) ; from .. sqlparser import SqlParser insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 25 , 83.54 , 79 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 84 , 'Birk ' , 'Malling ' , ' C ' , 'Annie ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 122 , 406.1 , 80 ) ; qep_parser_without_constraint_exclusion = \ with self._conn.cursor ( ) as cur : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 213 , 329.78 , 105 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 86 , 'Lauren ' , 'Tolworth ' , ' B ' , 'Anthony ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 90 , 169.25 , 30 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 103 , 'Ede ' , 'Golden of Ireland ' , ' C ' , 'Armanda ' ) ; CUSTOMERS_TABLE_NAME = `` implied_expression_orderby_test_table_customers '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 37 , 322.11 , 41 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 79 , 'Preston ' , 'Groves ' , ' B ' , 'Angelina ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 179 , 453.95 , 43 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 200 , 592.16 , 137 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 139 , 441.16 , 97 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 124 , 'Penelope ' , 'Quadling ' , ' C ' , 'Augustine ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 209 , 203.86 , 244 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 124 , 552.02 , 191 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 212 , 'Annecorinne ' , 'Soles ' , ' B ' , 'Cedric ' ) ; qep_analysis_with_constraint_exclusion = \ insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 56 , 501.06 , 129 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 90 , 'Forest ' , 'Trim ' , ' B ' , 'Appoline ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 134 , 'Georgetta ' , 'Crossley ' , ' B ' , 'Barnabas ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 168 , 'Melicent ' , 'Cheston ' , ' B ' , 'Bradford ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 227 , 'Jeralee ' , 'Atwill ' , ' C ' , 'Christa ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 152 , 'Towny ' , 'Middell ' , ' B ' , 'Bert ' ) ; def load_database ( * * kwargs ) : def sql_parser ( postgresql : Connection ) : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 62 , 'Seline ' , 'McGray ' , ' B ' , 'Alphinias ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 70 , 'Carmela ' , 'Sedgeworth ' , ' C ' , 'Amos ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 148 , 'Lidia ' , 'Quinane ' , ' C ' , 'Benjamin ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 243 , 'Hannah ' , 'Mattheis ' , ' C ' , 'Clarinda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 241 , 296.03 , 169 ) ; SELECT ( 1 , 2 , 3 ) ; '' '' '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 69 , 266.3 , 39 ) ; ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 238 , 'Gregor ' , 'Crinion ' , ' B ' , 'Cindy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 117 , 23.13 , 46 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 85 , 'Brig ' , 'Triswell ' , ' C ' , 'Anselm ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 109 , 'Marquita ' , 'Impy ' , ' B ' , 'Aron ' ) ; CREATE TABLE { ORDERS_TABLE_NAME } ( insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 132 , 488.95 , 234 ) ; , type CHAR ( 1 ) NOT NULL insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 84 , 396.02 , 111 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 87 , 441.16 , 191 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 229 , 'Melessa ' , 'MacAleese ' , ' C ' , 'Christiana ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 231 , 51.77 , 118 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 19 , 'Daphne ' , 'Bullen ' , ' B ' , 'Adeline ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 134 , 296.72 , 222 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 133 , 499.73 , 235 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 204 , 'Cassy ' , 'Pearcehouse ' , ' C ' , 'Casper ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 17 , 302.31 , 225 ) ; f '' '' '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 195 , 'Dewey ' , 'Bottom ' , ' C ' , 'Carmelo ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 80 , 'Petey ' , 'Colloby ' , ' B ' , 'Ann ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 180 , 452.67 , 234 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 140 , 297.41 , 101 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 228 , 'Rudd ' , 'Ames ' , ' B ' , 'Christian ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 238 , 448.86 , 16 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 172 , 'Pammi ' , 'Codling ' , ' B ' , 'Breeanna ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 199 , 376.5 , 53 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 110 , 'Donall ' , 'Labrenz ' , ' B ' , 'Artelepsa ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 250 , 367.56 , 214 ) ; '' '' '' ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 111 , 'Torey ' , 'Sessuns ' , ' B ' , 'Artemus ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 25 , 'Neely ' , 'Merrydew ' , ' B ' , 'Agatha ' ) ; SQL_NOT_NULL_CONSTRAINT_VIOLATION = \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 244 , 'Katrine ' , 'Janiak ' , ' B ' , 'Clarissa ' ) ; def db_connection ( postgresql : Connection ) : warning_msg = checker.check ( ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 195 , 504.28 , 117 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 131 , 'Ive ' , 'Matches ' , ' B ' , 'Barbara ' ) ; WHERE sname > fname ; '' '' '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 161 , 'Barron ' , 'Dishmon ' , ' B ' , 'Bill ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 12 , 591.72 , 143 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 55 , 'Terrill ' , 'Syde ' , ' B ' , 'Allison ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 187 , 271.52 , 242 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 222 , 416.65 , 59 ) ; from psycopg import Connection insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 100 , 424.83 , 50 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 241 , 'Sigismund ' , 'Mowsdill ' , ' B ' , 'Clare ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 193 , 449.91 , 213 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 210 , 'Pamelina ' , 'Vittery ' , ' C ' , 'Cathy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 178 , 563.08 , 161 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 156 , 130.63 , 188 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 126 , 384.61 , 226 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 106 , 'Merrily ' , 'Coundley ' , ' C ' , 'Arminda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 196 , 259.0 , 244 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 192 , 'Dudley ' , 'Vesco ' , ' B ' , 'Carlotta ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 113 , 'Dania ' , 'Foxton ' , ' C ' , 'Arthusa ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 211 , 399.2 , 138 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 98 , 177.22 , 86 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 247 , 'Dulcie ' , 'Crutchley ' , ' B ' , 'Clement ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 164 , 'Abel ' , 'Bezants ' , ' C ' , 'Bob ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 154 , 291.52 , 54 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 35 , 389.81 , 218 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 164 , 193.39 , 169 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 21 , 'Nady ' , 'Lempertz ' , ' B ' , 'Adolphus ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 244 , 273.35 , 153 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 215 , 'Nollie ' , 'Jemmett ' , ' B ' , 'Charity ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 95 , 'Amandie ' , 'Botham ' , ' B ' , 'Araminta ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 27 , 'Callean ' , 'Werlock ' , ' C ' , 'Aileen ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 172 , 15.3 , 30 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 105 , 'Cary ' , 'Sells ' , ' C ' , 'Armilda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 13 , 503.52 , 216 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 136 , 'Aretha ' , 'Arias ' , ' C ' , 'Bart ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 3 , 'Christen ' , 'Culley ' , ' C ' , 'Abednego ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 135 , 'Janenna ' , 'McCamish ' , ' C ' , 'Barney ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 15 , 'Zachary ' , 'Faloon ' , ' C ' , 'Adela ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 102 , 158.53 , 220 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 71 , 175.29 , 115 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 93 , 'Sashenka ' , 'Fedorski ' , ' C ' , 'Arabella ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 198 , 120.47 , 95 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 152 , 291.54 , 10 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 106 , 236.57 , 4 ) ; with self._conn.cursor ( ) as cur : conn.commit ( ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 92 , 156.72 , 192 ) ; print ( warning_msg ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 76 , 281.92 , 183 ) ; SQL_CHECK_CONSTRAINT_VIOLATION = \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 107 , 'Celisse ' , 'Rubra ' , ' B ' , 'Arminta ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 34 , 'Lorens ' , 'Buzin ' , ' C ' , 'Aldo ' ) ; self.parsed_sql : exp.Expression = parsed_sql self._conn.commit ( ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 116 , 'Annmarie ' , 'Errichelli ' , ' B ' , 'Asaph ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 115 , 'Shirl ' , 'Pilpovic ' , ' C ' , 'Asahel ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 225 , 26.43 , 228 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 46 , 'Mechelle ' , 'Vinick ' , ' B ' , 'Algernon ' ) ; CHECK ( type IN ( ' C ' , ' B ' ) ) -- C = customer , B = business insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 38 , 'Web ' , 'Catterill ' , ' B ' , 'Alex ' ) ; warning_msg = `` Warning : Found impossible comparison due to column/table constraints [ pg4n : :ImpliedExpression ] '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 224 , 293.35 , 186 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 54 , 'Malchy ' , 'Hearty ' , ' B ' , 'Allisandra ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 217 , 'Lucy ' , 'Durtnell ' , ' C ' , 'Charlie ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 94 , 'Halimeda ' , 'Freak ' , ' B ' , 'Arabelle ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 9 , 519.43 , 175 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 230 , 'Cordell ' , 'Bineham ' , ' B ' , 'Christiano ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 75 , 'Erma ' , 'Cranstone ' , ' B ' , 'Andrew ' ) ; DROP TABLE IF EXISTS { CUSTOMERS_TABLE_NAME } ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 184 , 380.46 , 98 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 68 , 'Leisha ' , 'Darlington ' , ' C ' , 'Ambrose ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 219 , 'Adriane ' , 'Ccomini ' , ' B ' , 'Chauncey ' ) ; , sname VARCHAR ( 50 ) NOT NULL insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 59 , 141.8 , 118 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 236 , 'Garnette ' , 'Tabrett ' , ' C ' , 'Cicely ' ) ; , FOREIGN KEY ( customer_id ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 43 , 'Belle ' , 'Barsham ' , ' B ' , 'Alfonse ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 145 , 'Adena ' , 'Wenham ' , ' C ' , 'Belinda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 197 , 529.63 , 46 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 39 , 'Tabbie ' , 'Glison ' , ' B ' , 'Alexander ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 33 , 140.92 , 236 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 29 , 217.18 , 124 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 80 , 17.1 , 21 ) ; if not has_implied_expression : self.db_connection : Connection = db_connection insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 96 , 311.78 , 173 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 185 , 'Tanitansy ' , 'Headington ' , ' C ' , 'Calista ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 120 , 'Corinna ' , 'Pyburn ' , ' B ' , 'Audrey ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 33 , 'Amble ' , 'Jewes ' , ' B ' , 'Alberta ' ) ; , nickname VARCHAR ( 20 ) NOT NULL insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 165 , 'Angele ' , 'Wildbore ' , ' C ' , 'Bobby ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 108 , 'Janene ' , 'Motten ' , ' C ' , 'Arnold ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 107 , 23.63 , 179 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 168 , 137.02 , 109 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 6 , 'Daisey ' , 'Hamill ' , ' B ' , 'Abigail ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 167 , 'Ninnette ' , 'Steere ' , ' C ' , 'Brad ' ) ; has_onetime_filter_with_constraint_exclusion = \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 69 , 'Maryjo ' , 'Pink ' , ' C ' , 'Amelia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 50 , 'Anne-marie ' , 'Mounsie ' , ' B ' , 'Alison ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 151 , 'Prentiss ' , 'Filby ' , ' B ' , 'Berney ' ) ; return node.get ( `` One-Time Filter '' ) ! = None insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 231 , 'Calhoun ' , 'BoHlingolsen ' , ' C ' , 'Christina ' ) ; SELECT customer_id , fname , sname insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 49 , 'Theodosia ' , 'Rosson ' , ' B ' , 'Aline ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 220 , 367.15 , 163 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 99 , 354.37 , 66 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 51 , 244.27 , 119 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 158 , 'Anett ' , 'Hercules ' , ' B ' , 'Beverly ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 26 , 'Jenica ' , 'Martina ' , ' C ' , 'Agnes ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 175 , 161.61 , 58 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 72 , 539.87 , 62 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 203 , 545.33 , 116 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 21 , 471.12 , 179 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 138 , 223.81 , 183 ) ; qep_parser_with_constraint_exclusion = \ insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 40 , 33.89 , 23 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 101 , 'Hamilton ' , 'Pellew ' , ' B ' , 'Arizona ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 88 , 'Sansone ' , 'Copsey ' , ' C ' , 'Antonia ' ) ; from .sqlparser import ( cur.execute ( `` set constraint_exclusion = off ; '' ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 111 , 490.85 , 191 ) ; import sqlglot.expressions as exp insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 232 , 'Maritsa ' , 'Cowpland ' , ' C ' , 'Christine ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 163 , 61.42 , 69 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 247 , 123.55 , 179 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 60 , 'Sibyl ' , 'Thoms ' , ' C ' , 'Almira ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 236 , 485.18 , 167 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 83 , 451.45 , 203 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 193 , 'Brucie ' , 'Coning ' , ' C ' , 'Carlton ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 228 , 542.3 , 42 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 127 , 451.77 , 17 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 120 , 454.18 , 214 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 174 , 'Carolyn ' , 'Quinlan ' , ' C ' , 'Brian ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 199 , 'Matilda ' , 'Malenoir ' , ' C ' , 'Caroline ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 179 , 'Daphne ' , 'Kells ' , ' C ' , 'Broderick ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 9 , 'Lester ' , 'Markus ' , ' C ' , 'Abraham ' ) ; postgresql = factories.postgresql ( `` factory '' ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 143 , 239.98 , 109 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 53 , 592.15 , 207 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 7 , 'Lorin ' , 'Dollimore ' , ' C ' , 'Abijah ' ) ; , customer_id INT NOT NULL insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 55 , 391.93 , 128 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 1 , 'Josi ' , 'Grimsell ' , ' B ' , 'Aaron ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 175 , 'Davy ' , 'Blomefield ' , ' B ' , 'Brianna ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 118 , 'Hermy ' , 'Whieldon ' , ' B ' , 'Ashley ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 44 , 'Buffy ' , ' O '' Cridigan ' , ' B ' , 'Alfred ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 177 , 334.0 , 167 ) ; def check ( self ) - > Optional [ str ] : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 86 , 537.64 , 201 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 85 , 404.96 , 79 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 53 , 'Riva ' , 'Scawen ' , ' C ' , 'Allen ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 249 , 491.05 , 63 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 105 , 107.29 , 12 ) ; from typing import Optional insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 223 , 200.44 , 47 ) ; assert warning_msg == None insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 73 , 144.33 , 52 ) ; , PRIMARY KEY ( customer_id ) from .qepparser import ( insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 74 , 'Giffy ' , 'Cottee ' , ' C ' , 'Andrea ' ) ; , PRIMARY KEY ( order_id ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 207 , 'Elise ' , 'Kamenar ' , ' C ' , 'Caswell ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 155 , 274.14 , 151 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 215 , 515.79 , 96 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 22 , 193.12 , 6 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 150 , 'Agnesse ' , 'Liebmann ' , ' B ' , 'Bernard ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 104 , 'Timofei ' , 'Grene ' , ' B ' , 'Armena ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 160 , 144.6 , 82 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 8 , 'Gasparo ' , 'Bohlje ' , ' C ' , 'Abner ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 60 , 473.05 , 208 ) ; cur.execute ( `` set constraint_exclusion = on ; '' ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 58 , 'Lettie ' , 'Coffin ' , ' B ' , 'Almena ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 125 , 'Leo ' , 'Creaney ' , ' B ' , 'Augustus ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 190 , 401.19 , 88 ) ; `` `` '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 108 , 294.25 , 131 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 110 , 144.28 , 59 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 144 , 'Ange ' , 'Pasterfield ' , ' C ' , 'Bedelia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 138 , 'Ainsley ' , 'Wraighte ' , ' C ' , 'Barticus ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 147 , 180.39 , 2 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 58 , 10.24 , 74 ) ; has_onetime_filter_with_constraint_exclusion and \ qep_analysis_without_constraint_exclusion = \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 203 , 'Rory ' , 'Hallatt ' , ' C ' , 'Casey ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 216 , 'Elsbeth ' , 'MacGaughie ' , ' B ' , 'Charles ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 149 , 340.62 , 215 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 186 , 'Chloette ' , 'Ratt ' , ' B ' , 'Calpurnia ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 174 , 597.34 , 184 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 184 , 'Louise ' , 'Jansey ' , ' C ' , 'California ' ) ; def __init__ ( self , * args , conn=None , constraint_exclusion=True , * * kwargs ) : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 189 , 'Merle ' , 'Erridge ' , ' C ' , 'Camille ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 2 , 409.8 , 217 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 158 , 65.82 , 201 ) ; sql_statement = SQL_SIMPLE else : QEPNode , insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 198 , 'Kellby ' , 'Threlfall ' , ' C ' , 'Carolann ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 101 , 328.66 , 189 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 239 , 'Atalanta ' , 'Girdler ' , ' C ' , 'Claire ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 217 , 302.24 , 189 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 230 , 389.39 , 247 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 143 , 'Sasha ' , 'Eunson ' , ' C ' , 'Beck ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 235 , 230.72 , 168 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 95 , 367.31 , 48 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 36 , 225.6 , 136 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 208 , 'Legra ' , 'Drought ' , ' C ' , 'Catherine ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 100 , 'Gypsy ' , 'Bottrell ' , ' C ' , 'Aristotle ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 206 , 'Ardyth ' , 'Conningham ' , ' B ' , 'Cassidy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 94 , 406.59 , 129 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 194 , 'Corilla ' , 'Aldwinckle ' , ' C ' , 'Carmellia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 81 , 'Sharline ' , 'Rosenwald ' , ' B ' , 'Anna ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 6 , 132.85 , 206 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 235 , 'Justus ' , 'Barthrup ' , ' B ' , 'Christy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 135 , 574.1 , 222 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 205 , 'Orlan ' , 'Kynder ' , ' C ' , 'Cassandra ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 147 , 'Wilmer ' , 'MacWhan ' , ' B ' , 'Benedict ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 47 , 163.79 , 141 ) ; REFERENCES { CUSTOMERS_TABLE_NAME } ( customer_id ) def __init__ ( self , * args , conn=None , * * kwargs ) : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 52 , 81.47 , 212 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 205 , 508.59 , 59 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 5 , 582.52 , 172 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 211 , 'Jobi ' , 'Bails ' , ' B ' , 'Cecilia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 40 , 'Olva ' , 'Leborgne ' , ' C ' , 'Alexandra ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 114 , 'Fara ' , 'Arkil ' , ' B ' , 'Arzada ' ) ; self._conn.commit ( ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 149 , 'Erik ' , 'Cushe ' , ' B ' , 'Benjy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 64 , 534.3 , 108 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 66 , 'Sadella ' , 'Boxhall ' , ' B ' , 'Alzada ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 4 , 'Nancey ' , 'Fawlkes ' , ' C ' , 'Abel ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 125 , 170.66 , 131 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 38 , 366.31 , 59 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 72 , 'Nadiya ' , 'Gingles ' , ' B ' , 'Anderson ' ) ; QEPAnalysis , insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 35 , 'Lainey ' , 'Davidow ' , ' C ' , 'Aldrich ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 226 , 'Emelina ' , 'Ayliff ' , ' B ' , 'Chris ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 145 , 112.51 , 162 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 34 , 64.76 , 13 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 20 , 'Robbi ' , ' O '' Caherny ' , ' B ' , 'Adelphia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 36 , 'Bendite ' , 'Morfett ' , ' B ' , 'Aleksandr ' ) ; def __init__ ( self , parsed_sql : exp.Expression , sql_statement : str , insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 73 , 'Seymour ' , 'Maffioletti ' , ' B ' , 'Andre ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 16 , 'Augustin ' , 'Blaxall ' , ' C ' , 'Adelaide ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 155 , 'Murdock ' , 'Dix ' , ' C ' , 'Bess ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 207 , 205.25 , 199 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 173 , 297.4 , 85 ) ; load= [ load_database ] , insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 18 , 438.38 , 26 ) ; has_implied_expression = \ WHERE sname IS NULL ; '' '' '' from .. implied_expression_checker import ImpliedExpressionChecker insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 65 , 318.64 , 6 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 91 , 331.76 , 115 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 200 , 'Fanni ' , 'Iacopetti ' , ' C ' , 'Carolyn ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 67 , 'Zsazsa ' , 'Bellocht ' , ' C ' , 'Amanda ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 97 , 'Germain ' , 'Haly ' , ' B ' , 'Archilles ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 222 , 'Hazel ' , 'Rushforth ' , ' C ' , 'Chester ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 81 , 490.65 , 41 ) ; return warning_msg insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 218 , 'Raffarty ' , 'Sweeney ' , ' C ' , 'Charlotte ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 182 , 'Sasha ' , 'Stiffkins ' , ' C ' , 'Caldonia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 31 , 'Dario ' , 'Siehard ' , ' C ' , 'Alazama ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 112 , 'Nanci ' , 'Byrd ' , ' C ' , 'Arthur ' ) ; not has_onetime_filter_without_constraint_exclusion","['src/pg4n/implied_expression_checker.py', 'src/pg4n/qepparser.py', 'src/pg4n/test/test_implied_expression_checker.py']",2022-09-23 11:37:52+00:00,2022-11-08 08:09:34+00:00,2022-11-08 10:09:32+02:00
14,deb3a2a40e7985cd361fcd18ccfebab53b113d71,1.0441794074722566e-05,1,"For proper modularisation , remove magic function/string from L87 and let class constructor choose it .",Add str- > str hook function parameter to Wrapper constructor,Merge pull request # 4 from Project-C-SQL/feat/pexpect-wrapper,"if len ( sys.argv ) > 1 : else : import pexpect # so = > was lost when flushing output log if self.debug : # ? 2004 are return output db_name : bytes = b '' previous_prompt_ends_at : int = psql_log.rfind ( prompt ) c.interact ( input_filter=self.ifilter , # ANSI escape codes ( \x1b [ ) used by psql : # = output_log : bytes = b '' self.fout.write ( str ( new_output ) + '\n ' ) Forward output to check_and_act_on_repl_output ( ) and flush output log if substitute output is returned and replace output with it accordingly . from typing import TextIO def ifilter ( self , input : bytes ) - > bytes : return None new_output : bytes = self.check_and_act_on_repl_output ( output , fout : TextIO helpful_message : str = `` Helpful message '' # give_message_for ( decoded_stmt_and_result ) psql_log [ previous_prompt_ends_at + 1 : ] ) + bytes.decode ( latest_output [ : latest_output.find ( prompt ) ] ) # b ) amidst a return statement else : # psql output for new prompt will ( pending bug reports ) look like this b'db_name= > ' self.fout.write ( str ( output ) + '\n ' ) there_is_new_prompt : bool = latest_output.endswith ( prompt ) self.output_log = self.output_log + output # ? 1049 these self.db_name = db_name_parameter psql_log is only needed for analysis . latest_output is what 's being changed and returned in new form . self.fout = open ( 'wrapper.log ' , ' w ' ) latest_output ) if newline_pos < 0 : previous_prompt_ends_at = -1 # a ) start from previous prompt class Wrapper : decoded_stmt_and_result : str = bytes.decode ( def ofilter ( self , output : bytes ) - > bytes : input_log : bytes = b '' return input # trivial case def __init__ ( self , db_name_parameter : bytes ) : # User has entered a new statement right on our previously modified prompt , print ( `` python3 main.py < database name > '' ) return new_output wrap = wrapper.Wrapper ( sys.argv [ 1 ] .encode ( `` utf-8 '' ) ) output_filter=self.ofilter ) encoding= '' utf-8 '' , import sys # K clear part of the line return prompt [ : prompt_line_begins_at - 1 ] + \ Start wrapper on selected database . # m SGR ( set graphics mode ) def check_and_act_on_repl_output ( self , latest_output : bytes , Fit the new message in the right place , just on the previous line before new prompt # ? 1h cursor ? import wrapper prompt_line_begins_at : int = prompt.rfind ( b'\x1b ' ) self.input_log = self.input_log + input self.output_log = b '' if self.debug : newline_pos : int = prompt.rfind ( b'\n ' ) c = pexpect.spawn ( `` psql `` + bytes.decode ( self.db_name ) , new_prompt_msg.encode ( `` utf-8 '' ) + b'\r\n ' + prompt [ prompt_line_begins_at : ] # ? 1l escapes ( h = high , l = low ) dimensions= ( 48 , 160 ) ) return self.replace_prompt ( helpful_message , prompt : bytes ) : # > debug : bool = True return new_prompt_msg.encode ( `` utf-8 '' ) + b'\r\n ' + prompt # b'\x1b [ ? 2004hpgdb= > ' if there_is_new_prompt : psql_log : bytes ) - > bytes : self.output_log ) `` `` '' self.fout.write ( decoded_stmt_and_result ) Detect if psql has run a statement and is asking for a new statement ( `` = > `` prompt ) . Entering a statement will always lead to a new prompt , so now the output_log will be examined if an interesting statement was run , and if it was run successfully . If so , add a fitting message in before the new prompt . if previous_prompt_ends_at < 0 : def replace_prompt ( self , new_prompt_msg : str , prompt : bytes = self.db_name + b'= > ' if new_output is not None : # prompt is more complicated and has newlines in it : psql REPL has outputted a multiline chunk that may","['main.py', 'wrapper.py']",2022-09-25 06:00:26+00:00,2022-10-11 13:58:22+00:00,2022-09-25 06:01:08+00:00
15,576ff1d3f49e6180a05f05e0e2ae13ba93d7ecb4,1.040008464769926e-05,1,"Add requirements.txt , directory structure , thought out main.py , etc .",Incorporate project template and a thought out main.py,Merge pull request # 31 from Project-C-SQL/feat/add-docs,"version = `` 65.4.1 '' pytz = [ { file = `` PyYAML-6.0-cp37-cp37m-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_12_x86_64.manylinux2010_x86_64.whl '' , hash = `` sha256:231710d57adfd809ef5d34183b8ed1eeae3f76459c18fb4a0b373ad56bedcdd9 '' } , dev = [ `` pre-commit '' , `` tox '' ] { file = `` psutil-5.9.2-cp27-cp27mu-manylinux2010_x86_64.whl '' , hash = `` sha256:256098b4f6ffea6441eb54ab3eb64db9ecef18f6a80d7ba91549195d55420f84 '' } , version = `` 2.0.1 '' version = `` 1.26.12 '' name = `` iniconfig '' version = `` 1.4.1 '' sphinx = `` > =4 , < 6 '' { file = `` psutil-5.9.2-cp37-cp37m-macosx_10_9_x86_64.whl '' , hash = `` sha256:42638876b7f5ef43cef8dcf640d3401b27a51ee3fa137cb2aa2e72e188414c32 '' } , { file = `` psutil-5.9.2.tar.gz '' , hash = `` sha256 : feb861a10b6c3bb00701063b37e4afc754f8217f0f09c42280586bd6ac712b5c '' } , description = `` A tool that automatically formats Python code to conform to the PEP 8 style guide '' { file = `` pexpect-4.8.0.tar.gz '' , hash = `` sha256 : fc65a43959d153d0114afe13997d439c22823a27cefceb5ff35c2178c6784c0c '' } , python-versions = `` * '' test = [ `` html5lib '' , `` pytest '' ] python-versions = `` > =2.6 , ! =3.0 . * , ! =3.1 . * , ! =3.2 . * '' project = 'PostgreSQL for novices ' name = `` pytest '' mdurl = `` > =0.1 , < 1.0 '' { file = `` psutil-5.9.2-cp36-cp36m-manylinux_2_12_i686.manylinux2010_i686.manylinux_2_17_i686.manylinux2014_i686.whl '' , hash = `` sha256 : d75291912b945a7351d45df682f9644540d564d62115d4a20d45fa17dc2d48f8 '' } , description = `` Utility that helps with local TCP ports management . It can find an unused TCP localhost port and remember the association . '' { file = `` psutil-5.9.2-cp310-cp310-macosx_10_9_x86_64.whl '' , hash = `` sha256:614337922702e9be37a39954d67fdb9e855981624d8011a9927b8f2d3c9625d9 '' } , { file = `` iniconfig-1.1.1.tar.gz '' , hash = `` sha256 : bc3af051d7d14b2ee5ef9969666def0cd1a000e121eaea580d4a313df4b37f32 '' } , { file = `` markdown-it-py-2.1.0.tar.gz '' , hash = `` sha256 : cf7e59fed14b5ae17c0006eff14a2d9a00ed5f3a846148153899a0224e2c07da '' } , { file = `` mirakuru-2.4.2.tar.gz '' , hash = `` sha256 : ec84d4d81b4bca96cb0e598c6b3d198a92f036a0c1223c881482c02a98508226 '' } , # ` virtualenvs-in-project : true ` creates a ` .venv ` in test dir for easy caching description = `` Python package for providing Mozilla 's CA Bundle . '' certifi = `` > =2017.4.17 '' services : To enter a shell session within the Poetry virtual environment , type ` poetry shell ` . { file = `` psycopg_binary-3.1.3-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl '' , hash = `` sha256:6ab64f067aa6db2119902d80d17d7cb3f0345bc55d56b1140985e478d0355f0f '' } , { file = `` psycopg_binary-3.1.3-cp37-cp37m-win_amd64.whl '' , hash = `` sha256 : bac38acebd15d60b2a051491273c61905c17b1aa015b81d323e07449f39f6855 '' } , { file = `` MarkupSafe-2.1.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl '' , hash = `` sha256:4b9fe39a2ccc108a4accc2676e77da025ce383c108593d65cc909add5c3bd601 '' } , alabaster = `` > =0.7 , < 0.8 '' { file = `` psutil-5.9.2-cp310-cp310-win32.whl '' , hash = `` sha256 : e4c4a7636ffc47b7141864f1c5e7d649f42c54e49da2dd3cceb1c5f5d29bfc85 '' } , sphinxcontrib-serializinghtml = `` > =1.1.5 '' user=getenv ( `` POSTGRES_USER '' , `` postgres '' ) , version = `` 1.0.2 '' optional = false { file = `` tzdata-2022.4-py2.py3-none-any.whl '' , hash = `` sha256:74da81ecf2b3887c94e53fc1d466d4362aaf8b26fc87cda18f22004544694583 '' } , { file = `` urllib3-1.26.12.tar.gz '' , hash = `` sha256:3fa96cf423e6987997fc326ae8df396db2a8b7c667747d47ddd8ecba91f4a74e '' } , { file = `` typing_extensions-4.4.0-py3-none-any.whl '' , hash = `` sha256:16fa4864408f655d35ec496218b85f79b3437c829e93320c7c9215ccfd92489e '' } , name = `` attrs '' version = `` 2.4.2 '' health-interval 10s py = [ { file = `` imagesize-1.4.1.tar.gz '' , hash = `` sha256:69150444affb9cb0d5cc5a92b3676f0b2fb7cd9ae39e947a5e11a36b4497cd4a '' } , } docutils = `` > =0.14 , < 0.20 '' dev = [ `` bump2version '' , `` sphinxcontrib-httpdomain '' , `` transifex-client '' ] Parse for an empty prompt , usually to detect when a query evaluation has ended . { file = `` psycopg_binary-3.1.3-cp37-cp37m-musllinux_1_1_aarch64.whl '' , hash = `` sha256:61eea4dd3da1947e7fee1cbf98924935c78247cb5426d6156693caec31506e53 '' } , name = `` babel '' { file = `` psycopg_binary-3.1.3-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl '' , hash = `` sha256:18446766f3e1f3a8b6e2046a176c55992d2617b4c2b64c007969192210ee790f '' } , autopep8 = [ { file = `` psycopg_binary-3.1.3-cp38-cp38-manylinux_2_17_aarch64.manylinux2014_aarch64.whl '' , hash = `` sha256 : b4460ebf333e6e7c212dfcd0d46bf9fd1dd04b406aaff34713d960f9e87f77d9 '' } , description = `` This package provides 29 stemmers for 28 languages generated from Snowball algorithms . '' name = `` sphinxcontrib-htmlhelp '' { file = `` psycopg_binary-3.1.3-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl '' , hash = `` sha256:62baa7ed5e0507d4436d16fb5ff13a540850f30b29b06bccac5185e14270d651 '' } , tomli = [ name = `` docutils '' description = `` Run a subprocess in a pseudo terminal '' # # Notes for developers { file = `` mdit_py_plugins-0.3.1-py3-none-any.whl '' , hash = `` sha256:606a7f29cf56dbdfaf914acb21709b8f8ee29d857e8f29dcc33d8cb84c57bfa1 '' } , if self.debug : colorama = { version = `` > =0.4.5 '' , markers = `` sys_platform == \ '' win32\ '' '' } code-style = [ `` pre-commit ( ==2.6 ) '' ] # Editor testing-integration = [ `` build [ virtualenv ] '' , `` filelock ( > =3.4.0 ) '' , `` jaraco.envs ( > =2.2 ) '' , `` jaraco.path ( > =3.2.0 ) '' , `` pytest '' , `` pytest-enabler '' , `` pytest-xdist '' , `` tomli '' , `` virtualenv ( > =13.0.0 ) '' , `` wheel '' ] version = `` 2.28.1 '' { file = `` imagesize-1.4.1-py2.py3-none-any.whl '' , hash = `` sha256:0d8d18d08f840c19d0ee7ca1fd82490fdc3729b7ac93f49870406ddde8ef8d8b '' } , [ tool.poetry.group.dev.dependencies ] description = `` The Real First Universal Charset Detector . Open , modern and actively maintained alternative to Chardet . '' ` psql ` is the psql REPL log to be inspected . version = `` 0.7.12 '' psycopg = [ docutils = `` > =0.15 , < 0.20 '' MarkupSafe = `` > =2.0 '' Pygments = `` > =2.12 '' { file = `` certifi-2022.9.24.tar.gz '' , hash = `` sha256:0d9c601124e5a6ba9712dbc60d9c53c21e34f5f641fe83002317394311bdce14 '' } , version = `` 6.3.5 '' { file = `` PyYAML-6.0-cp36-cp36m-win_amd64.whl '' , hash = `` sha256:07751360502caac1c067a8132d150cf3d61339af5691fe9e87803040dbc5db57 '' } , { file = `` MarkupSafe-2.1.1-cp37-cp37m-win_amd64.whl '' , hash = `` sha256:97a68e6ada378df82bc9f16b800ab77cbf4b2fada0081794318520138c088e4a '' } , { file = `` charset_normalizer-2.1.1-py3-none-any.whl '' , hash = `` sha256:83e9a75d1911279afd89352c68b45348559d1fc0506b054b346651b5e7fee29f '' } , { file = `` sphinx_rtd_theme-1.0.0-py2.py3-none-any.whl '' , hash = `` sha256:4d35a56f4508cfee4c4fb604373ede6feae2a306731d533f409ef5c3496fdbd8 '' } , description = `` Safely add untrusted strings to HTML/XML markup . '' { file = `` PyYAML-6.0-cp310-cp310-macosx_11_0_arm64.whl '' , hash = `` sha256:9df7ed3b3d2e0ecfe09e14741b857df43adb5a3ddadc919a2d94fbdf78fea53c '' } , import psycopg2 { file = `` PyYAML-6.0-cp36-cp36m-win32.whl '' , hash = `` sha256:0283c35a6a9fbf047493e3a0ce8d79ef5030852c51e9d911a27badfde0605293 '' } , # mypy = `` ^0.982 '' docs = [ `` furo '' , `` jaraco.packaging ( > =9 ) '' , `` jaraco.tidelift ( > =1.4 ) '' , `` pygments-github-lexers ( ==0.0.5 ) '' , `` rst.linker ( > =1.9 ) '' , `` sphinx ( > =3.5 ) '' , `` sphinx-favicon '' , `` sphinx-hoverxref ( < 2 ) '' , `` sphinx-inline-tabs '' , `` sphinx-notfound-page ( ==0.8.3 ) '' , `` sphinx-reredirects '' , `` sphinxcontrib-towncrier '' ] { file = `` sphinx_rtd_theme-1.0.0.tar.gz '' , hash = `` sha256 : eec6d497e4c2195fa0e8b2016b337532b8a699a68bcb22a512870e16925c6a5c '' } , { file = `` psutil-5.9.2-cp39-cp39-manylinux_2_12_i686.manylinux2010_i686.manylinux_2_17_i686.manylinux2014_i686.whl '' , hash = `` sha256:14b29f581b5edab1f133563272a6011925401804d52d603c5c606936b49c8b97 '' } , ` parser ` is an implementation of PsqlParser interface . { file = `` psycopg_binary-3.1.3-cp39-cp39-macosx_10_9_x86_64.whl '' , hash = `` sha256:7d8cca88f1b3e79895d9becbb9ed30b31324050e5502bd20bc94219cb80bc039 '' } , name = `` mdit-py-plugins '' { file = `` PyYAML-6.0-cp38-cp38-manylinux_2_17_aarch64.manylinux2014_aarch64.whl '' , hash = `` sha256:213c60cd50106436cc818accf5baa1aba61c0189ff610f64f4a3e8c6726218ba '' } , key : pydeps- $ { { hashFiles ( ' * * /poetry.lock ' ) } } name = `` toml '' 'sphinx_autodoc_typehints ' , description = `` iniconfig : brain-dead simple config-ini parsing '' { file = `` psutil-5.9.2-cp37-cp37m-win32.whl '' , hash = `` sha256:7cbb795dcd8ed8fd238bc9e9f64ab188f3f4096d2e811b5a82da53d164b84c3f '' } , { file = `` docutils-0.17.1-py2.py3-none-any.whl '' , hash = `` sha256 : cf316c8370a737a022b72b56874f6602acf974a37a9fba42ec2876387549fc61 '' } , babel = `` > =2.9 '' docs = [ `` furo '' , `` sphinx '' , `` sphinx-notfound-page '' , `` zope.interface '' ] python-versions = `` > =3.6.0 '' name = `` urllib3 '' setuptools = [ description = `` Getting image size from png/jpeg/jpeg2000/gif file '' jobs : 'sphinx.ext.viewcode ' , python-versions = `` > =3.5 '' { file = `` psycopg_binary-3.1.3-cp310-cp310-win_amd64.whl '' , hash = `` sha256 : ec872e3664334805e50c704ee9ba8fb6b7c5c0da269cd1e982792dd07b8d1ba8 '' } , name = `` setuptools '' pytest = `` > =6.2.0 '' autopep8 = `` ^1.7.0 '' description = `` Python documentation generator '' { file = `` PyYAML-6.0-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl '' , hash = `` sha256:77f396e6ef4c73fdc33a9157446466f1cff553d979bd00ecb64385760c6babdc '' } , { file = `` MarkupSafe-2.1.1-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl '' , hash = `` sha256:99a2a507ed3ac881b975a2976d59f38c19386d128e7a9a18b7df6fff1fd4c1d6 '' } , pycodestyle = `` > =2.9.1 '' docs = [ `` Sphinx ( > =5.0 ) '' , `` furo ( ==2022.6.21 ) '' , `` sphinx-autobuild ( > =2021.3.14 ) '' , `` sphinx-autodoc-typehints ( > =1.12 ) '' ] { file = `` PyYAML-6.0-cp37-cp37m-win_amd64.whl '' , hash = `` sha256 : d15a181d1ecd0d4270dc32edb46f7cb7733c7c508857278d3d378d14d606db2d '' } , category = `` main '' { file = `` MarkupSafe-2.1.1-cp38-cp38-macosx_10_9_x86_64.whl '' , hash = `` sha256:0212a68688482dc52b2d45013df70d169f542b7394fc744c02a57374a4207003 '' } , Having PostgreSQL running on port 5432 , do ` poetry run pytest ` ( or , if on port x , just do ` PGPORT=x poetry run pytest ` ) . password=getenv ( `` PGPASSWORD '' , `` postgres '' ) ) { file = `` psutil-5.9.2-cp27-cp27m-win_amd64.whl '' , hash = `` sha256:404f4816c16a2fcc4eaa36d7eb49a66df2d083e829d3e39ee8759a411dbc9ecf '' } , { file = `` Sphinx-5.2.3.tar.gz '' , hash = `` sha256:5b10cb1022dac8c035f75767799c39217a05fc0fe2d6fe5597560d38e44f0363 '' } , description = `` A sphinx extension which renders display math in HTML via JavaScript '' { file = `` MarkupSafe-2.1.1-cp37-cp37m-musllinux_1_1_x86_64.whl '' , hash = `` sha256 : e1c0b87e09fa55a220f058d1d49d3fb8df88fbfab58558f1198e08c1e1de842a '' } , import sys def parser ( postgresql : Connection ) : { file = `` PyYAML-6.0-cp39-cp39-win32.whl '' , hash = `` sha256 : b5b9eccad747aabaaffbc6064800670f0c297e52c12754eb1d976c57e4f74dcb '' } , virtualenvs-create : true packaging = `` * '' templates_path = [ '_templates ' ] description = `` PostgreSQL database adapter for Python -- C optimisation distribution '' { file = `` PyYAML-6.0-cp310-cp310-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_12_x86_64.manylinux2010_x86_64.whl '' , hash = `` sha256 : f84fbc98b019fef2ee9a1cb3ce93e3187a6df0b2538a651bfb890254ba9f90b5 '' } , { file = `` Pygments-2.13.0-py3-none-any.whl '' , hash = `` sha256 : f643f331ab57ba3c9d89212ee4a2dabc6e94f117cf4eefde99a0574720d14c42 '' } , pyyaml = `` * '' version = `` 2.1.1 '' name = `` psutil '' psqlparser.PsqlParser ( ) ) { file = `` sphinxcontrib_serializinghtml-1.1.5-py2.py3-none-any.whl '' , hash = `` sha256:352a9a00ae864471d3a7ead8d7d79f5fc0b57e8b3f95e9867eb9eb28999b92fd '' } , health-retries 5 { file = `` sphinxcontrib-devhelp-1.0.2.tar.gz '' , hash = `` sha256 : ff7f1afa7b9642e7060379360a67e9c41e8f3121f2ce9164266f61b9f4b338e4 '' } , # # PsqlWrapper import psycopg pluggy = [ docutils = `` < 0.18 '' ports : { file = `` toml-0.10.2.tar.gz '' , hash = `` sha256 : b3bda1d108d5dd99f4a20d24d9c348e91c4db7ab1b749200bded2f839ccbe68f '' } , babel = [ readme = `` README.md '' sphinx = `` > =1.6 '' sphinx-rtd-theme = `` ^1.0.0 '' description = `` sphinxcontrib-applehelp is a sphinx extension which outputs Apple help books '' name = `` pyparsing '' name = `` alabaster '' python-versions = `` > =2.7 , ! =3.0. * , ! =3.1. * , ! =3.2. * , ! =3.3 . * '' During development , you must run the program as a module , e.g. , ` poetry run python -m src.pg4n.main ` , so that the imports work . { file = `` idna-3.4.tar.gz '' , hash = `` sha256:814f528e8dead7d329833b91c5faa87d60bf71824cd12a7530b5526063d02cb4 '' } , # Documentation { file = `` Pygments-2.13.0.tar.gz '' , hash = `` sha256:56a8508ae95f98e2b9bdf93a6be5ae3f7d8af858b43e02c5a2ff083726be40c1 '' } , pyparsing = [ description = `` Backported and Experimental Type Hints for Python 3.7+ '' password=getenv ( `` POSTGRES_PASSWORD '' , `` postgres '' ) ) lambda x : x.parent is not None , health-timeout 5s { file = `` MarkupSafe-2.1.1-cp310-cp310-musllinux_1_1_i686.whl '' , hash = `` sha256:694deca8d702d5db21ec83983ce0bb4b26a578e71fbdbd4fdcd387daa90e4d5e '' } , subqueries = \ PostgreSQL for novices # [ tool.poetry.group.ci.dependencies ] { file = `` PyYAML-6.0-cp311-cp311-macosx_11_0_arm64.whl '' , hash = `` sha256:81957921f441d50af23654aa6c5e5eaf9b06aba7f0a19c18a538dc7ef291c5a1 '' } , imagesize = [ git-config-name : github-actions description = `` Read the Docs theme for Sphinx '' { file = `` alabaster-0.7.12.tar.gz '' , hash = `` sha256 : a661d72d58e6ea8a57f7a86e37d86716863ee5e92788398526d58b26a4e4dc02 '' } , { file = `` psycopg_binary-3.1.3-cp310-cp310-manylinux_2_17_i686.manylinux2014_i686.whl '' , hash = `` sha256:5f3a0045946b1638a1d3a3c02313902d8cbd70c7dd973d9408fb9c341385c9a9 '' } , { file = `` mdurl-0.1.2-py3-none-any.whl '' , hash = `` sha256:84008a41e51615a49fc9966191ff91509e3c40b939176e643fd50a5c2196b8f8 '' } , { file = `` charset-normalizer-2.1.1.tar.gz '' , hash = `` sha256:5a3d016c7c547f69d6f81fb0db9449ce888b418b5b9952cc5e6e66843e9dd845 '' } , { file = `` PyYAML-6.0-cp38-cp38-win32.whl '' , hash = `` sha256 : d4eccecf9adf6fbcc6861a38015c2a64f38b9d94838ac1810a9023a0609e1b78 '' } , name = `` psycopg '' pg4n = `` pg4n : main.main '' pytest-postgresql = `` ^4.1.1 '' sphinx-autodoc-typehints = [ sphinxcontrib-serializinghtml = [ { file = `` psycopg_binary-3.1.3-cp38-cp38-macosx_11_0_arm64.whl '' , hash = `` sha256:6f5d16496db28a79bce834a5f919133ee491c4e5ae6ab555eef03d7590c77e05 '' } , { file = `` pytest-7.1.3-py3-none-any.whl '' , hash = `` sha256:1377bda3466d70b55e3f5cecfa55bb7cfcf219c7964629b967c37cf0bda818b7 '' } , language = 'en ' name = `` port-for '' [ Documentation ] ( https : //project-c-sql.github.io/ ) { file = `` snowballstemmer-2.2.0-py2.py3-none-any.whl '' , hash = `` sha256 : c8e1716e83cc398ae16824e5572ae04e0d9fc2c6b985fb0f900f5f0c96ecba1a '' } , { file = `` PyYAML-6.0-cp39-cp39-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_12_x86_64.manylinux2010_x86_64.whl '' , hash = `` sha256:40527857252b61eacd1d9af500c3337ba8deb8fc298940291486c465c8b46ec0 '' } , { file = `` requests-2.28.1.tar.gz '' , hash = `` sha256:7c5599b102feddaa661c826c56ab4fee28bfd17f5abca1ebbe3e7f19d7c97983 '' } , { file = `` psycopg-3.1.3.tar.gz '' , hash = `` sha256 : d2c7c012e62083f800f9eb5eef849d5ed89940c3b31081d420279598f34c647e '' } , { file = `` PyYAML-6.0-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl '' , hash = `` sha256 : d67d839ede4ed1b28a4e8909735fc992a923cdb84e618544973d7dfc71540803 '' } , todo_include_todos = True # # # Poetry testing = [ `` beautifulsoup4 '' , `` coverage [ toml ] '' , `` pytest ( > =6 , < 7 ) '' , `` pytest-cov '' , `` pytest-param-files ( > =0.3.4 , < 0.4.0 ) '' , `` pytest-regressions '' , `` sphinx ( < 5.2 ) '' , `` sphinx-pytest '' ] version = `` 3.1.3 '' testing = [ `` coverage '' , `` pytest '' , `` pytest-cov '' , `` pytest-regressions '' ] { file = `` colorama-0.4.5-py2.py3-none-any.whl '' , hash = `` sha256:854bf444933e37f5824ae7bfc1e98d5bce2ebe4160d46b5edf346a89358e99da '' } , name = `` sphinxcontrib-qthelp '' { file = `` MarkupSafe-2.1.1-cp38-cp38-musllinux_1_1_aarch64.whl '' , hash = `` sha256:6d0072fea50feec76a4c418096652f2c3238eaa014b2f94aeb1d56a66b41403f '' } , { file = `` tzdata-2022.4.tar.gz '' , hash = `` sha256 : ada9133fbd561e6ec3d1674d3fba50251636e918aa97bd59d63735bef5a513bb '' } , name = `` autopep8 '' description = `` HTTP library with thread-safe connection pooling , file post , and more . '' import sys { file = `` ptyprocess-0.7.0-py2.py3-none-any.whl '' , hash = `` sha256:4b41f3967fce3af57cc7e94b888626c18bf37a083e3651ca8feeb66d492fef35 '' } , { file = `` Jinja2-3.1.2-py3-none-any.whl '' , hash = `` sha256:6088930bfe239f0e6710546ab9c19c9ef35e29792895fed6e6e31a023a182a61 '' } , { file = `` psutil-5.9.2-cp36-cp36m-win_amd64.whl '' , hash = `` sha256:9770c1d25aee91417eba7869139d629d6328a9422ce1cdd112bd56377ca98444 '' } , attrs = [ # poetry run isort `` src '' / * * / * .py -m 3 -- trailing-comma -c & & \ lint = [ `` docutils-stubs '' , `` flake8 ( > =3.5.0 ) '' , `` flake8-bugbear '' , `` flake8-comprehensions '' , `` flake8-simplify '' , `` isort '' , `` mypy ( > =0.981 ) '' , `` sphinx-lint '' , `` types-requests '' , `` types-typed-ast '' ] > import sqlparser { file = `` port-for-0.6.2.tar.gz '' , hash = `` sha256:9d4e73523d98f2f9f270308bbf415926c698b5439db8909384a79f152328b4d2 '' } , { file = `` MarkupSafe-2.1.1-cp39-cp39-musllinux_1_1_aarch64.whl '' , hash = `` sha256:33b74d289bd2f5e527beadcaa3f401e0df0a89927c1559c8566c066fa4248ab7 '' } , name = `` tzdata '' { file = `` sphinxcontrib_devhelp-1.0.2-py2.py3-none-any.whl '' , hash = `` sha256:8165223f9a335cc1af7ffe1ed31d2871f325254c0423bc0c4c7cd1c1e4734a2e '' } , { file = `` py-1.11.0.tar.gz '' , hash = `` sha256:51c75c4126074b472f746a24399ad32f6053d1b34b68d2fa41e558e6f4a98719 '' } , [ metadata ] { file = `` psycopg_binary-3.1.3-cp38-cp38-musllinux_1_1_i686.whl '' , hash = `` sha256 : e72011077546d7284b3bce59942a84805613eb1166fe7b6d6e6483b0a87ac2fc '' } , description = `` sphinxcontrib-serializinghtml is a sphinx extension which outputs \ '' serialized\ '' HTML files ( json and pickle ) . '' { file = `` MarkupSafe-2.1.1-cp38-cp38-musllinux_1_1_i686.whl '' , hash = `` sha256:089cf3dbf0cd6c100f02945abeb18484bd1ee57a079aefd52cffd17fba910b88 '' } , { file = `` packaging-21.3-py3-none-any.whl '' , hash = `` sha256 : ef103e05f519cdc783ae24ea4e2e0f508a9c99b2d4969652eed6a2e1ea5bd522 '' } , from psycopg2.extensions import connection version = `` 1.1.5 '' python-versions = `` ^3.10 '' { file = `` Jinja2-3.1.2.tar.gz '' , hash = `` sha256:31351a702a408a9e7595a8fc6150fc3f43bb6bf7e319770cbc0db9df9437e852 '' } , # # PsqlParser { file = `` MarkupSafe-2.1.1-cp310-cp310-macosx_10_9_x86_64.whl '' , hash = `` sha256 : f121a1420d4e173a5d96e47e9a0c0dcff965afdf1626d28de1460815f7c4ee7a '' } , { file = `` pluggy-1.0.0.tar.gz '' , hash = `` sha256:4224373bacce55f955a878bf9cfa763c1e360858e330072059e10bad68531159 '' } , # Program architecture toml = [ version = `` 1.11.0 '' 2 . To generate the documentation : < br > ` poetry run sphinx-build -b html docs docs/build ` virtualenvs-in-project : true exclude_patterns = [ 'build ' , 'Thumbs.db ' , '.DS_Store ' ] { file = `` PyYAML-6.0.tar.gz '' , hash = `` sha256:68fb519c14306fec9720a2a5b45bc9f0c8d1b9c72adf45c37baedfcd949c35a2 '' } , version = `` 7.1.3 '' sphinx = `` > =5.2.1 '' name = `` idna '' markdown-it-py = `` > =1.0.0 , < 3.0.0 '' author = 'Heikkilä et al . ' program-architecture authors = [ description = `` Provider of IANA time zone data '' name = `` mirakuru '' { file = `` ptyprocess-0.7.0.tar.gz '' , hash = `` sha256:5c5d0a3b48ceee0b48485e0c26037c0acd7d29765ca3fbb5cb3831d347423220 '' } , { file = `` sphinxcontrib-applehelp-1.0.2.tar.gz '' , hash = `` sha256 : a072735ec80e7675e3f432fcae8610ecf509c5f1869d17e2eecff44389cdbc58 '' } , `` WHERE order_total_eur = 0 AND order_total_eur = 100 ; '' name = `` markupsafe '' { file = `` psycopg_binary-3.1.3-cp37-cp37m-manylinux_2_17_x86_64.manylinux2014_x86_64.whl '' , hash = `` sha256:355eb31f6ff5d4438cf7ac108c9ee1dec36950dd6b98651e5877be0dc699b49f '' } , name = `` py '' { file = `` psutil-5.9.2-cp39-cp39-macosx_10_9_x86_64.whl '' , hash = `` sha256 : b3591616fa07b15050b2f87e1cdefd06a554382e72866fcc0ab2be9d116486c8 '' } , { file = `` psycopg_binary-3.1.3-cp39-cp39-macosx_11_0_arm64.whl '' , hash = `` sha256 : e52062352bc133733d8dd284b1613a5d095fcae7ed0c608b89a6e4c674590bf9 '' } , version = `` 0.3.1 '' { file = `` MarkupSafe-2.1.1-cp38-cp38-macosx_10_9_universal2.whl '' , hash = `` sha256 : e8c843bbcda3a2f1e3c2ab25913c80a3c5376cd00c6e8c4a86a89a28c8dc5452 '' } , run : poetry install -- no-interaction -- with ci -- no-root psutil = [ c = [ `` psycopg-c ( ==3.1.3 ) '' ] '.rst ' : 'restructuredtext ' , name = `` ptyprocess '' token : $ { { secrets.BOT_SECRET } } { file = `` myst-parser-0.18.1.tar.gz '' , hash = `` sha256:79317f4bb2c13053dd6e64f9da1ba1da6cd9c40c8a430c447a7b146a594c246d '' } , python-versions = `` > =2.7 , ! =3.0 . * , ! =3.1 . * , ! =3.2 . * , ! =3.3 . * , ! =3.4 . * , ! =3.5 . * , < 4 '' { file = `` mirakuru-2.4.2-py3-none-any.whl '' , hash = `` sha256 : fdb67d141cc9f7abd485a515d618daf3272c3e6ff48380749997ff8e8c5f2cb2 '' } , { file = `` psutil-5.9.2-cp310-cp310-manylinux_2_12_i686.manylinux2010_i686.manylinux_2_17_i686.manylinux2014_i686.whl '' , hash = `` sha256:39ec06dc6c934fb53df10c1672e299145ce609ff0611b569e75a88f313634969 '' } , : caption : Contents : run : poetry run pytest black src -- check & & { file = `` psycopg_binary-3.1.3-cp310-cp310-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl '' , hash = `` sha256:5dba8866d9628916a249fc428bd7baef607e24a4b54d54825ec8866624114fb2 '' } , { file = `` PyYAML-6.0-cp38-cp38-win_amd64.whl '' , hash = `` sha256:1e4747bc279b4f613a09eb64bba2ba602d8a6664c6ce6396a4d0cd413a50ce07 '' } , sphinxcontrib-applehelp = `` * '' # Interfaces iniconfig = `` * '' description = `` World timezone definitions , modern and historical '' { file = `` PyYAML-6.0-cp39-cp39-macosx_10_9_x86_64.whl '' , hash = `` sha256:055d937d65826939cb044fc8c9b08889e8c743fdc6a32b33e2390f66013e449b '' } , if : steps.cache-deps.outputs.cache-hit ! = 'true ' PGPORT : 5432 if : github.ref == 'refs/heads/main ' typing-extensions = { version = `` > =4.1 '' , markers = `` python_version < \ '' 3.11\ '' '' } name = `` jinja2 '' tests-no-zope = [ `` cloudpickle '' , `` coverage [ toml ] ( > =5.0.2 ) '' , `` hypothesis '' , `` mypy ( > =0.900 , ! =0.940 ) '' , `` pympler '' , `` pytest ( > =4.3.0 ) '' , `` pytest-mypy-plugins '' ] conn : Connection = psycopg.connect ( * * kwargs ) { file = `` MarkupSafe-2.1.1-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl '' , hash = `` sha256 : a49907dd8420c5685cfa064a1335b6754b74541bbb3706c259c02ed65b644b3e '' } , This project uses [ Poetry ] ( https : //python-poetry.org/ ) for packaging . Although one should refer to [ Poetry docs ] ( https : //python-poetry.org/docs/ ) for a thorough introduction , here 's a short summary of the intended workflow with Poetry : /docs/api PGHOST : localhost description = `` Type hints ( PEP 484 ) support for the Sphinx autodoc extension '' mdit-py-plugins = `` > =0.3.1 , < 0.4.0 '' { file = `` mdit-py-plugins-0.3.1.tar.gz '' , hash = `` sha256:3fc13298497d6e04fe96efdd41281bfe7622152f9caa1815ea99b5c893de9441 '' } , { file = `` sphinxcontrib-serializinghtml-1.1.5.tar.gz '' , hash = `` sha256 : aa5f6de5dfdf809ef505c4895e51ef5c9eac17d0f287933eb49ec495280b6952 '' } , py = `` > =1.8.2 '' setuptools = `` * '' description = `` Markdown URL utilities '' binary = [ `` psycopg-binary ( ==3.1.3 ) '' ] { file = `` psutil-5.9.2-cp37-cp37m-win_amd64.whl '' , hash = `` sha256:5d39e3a2d5c40efa977c9a8dd4f679763c43c6c255b1340a56489955dbca767c '' } , { file = `` psutil-5.9.2-cp38-cp38-manylinux_2_12_i686.manylinux2010_i686.manylinux_2_17_i686.manylinux2014_i686.whl '' , hash = `` sha256 : b315febaebae813326296872fdb4be92ad3ce10d1d742a6b0c49fb619481ed0b '' } , { file = `` PyYAML-6.0-cp37-cp37m-win32.whl '' , hash = `` sha256 : c5687b8d43cf58545ade1fe3e055f70eac7a5a1a0bf42824308d868289a95737 '' } , psycopg-binary = { version = `` 3.1.3 '' , optional = true , markers = `` extra == \ '' binary\ '' '' } { file = `` PyYAML-6.0-cp39-cp39-manylinux_2_17_s390x.manylinux2014_s390x.whl '' , hash = `` sha256 : cba8c411ef271aa037d7357a2bc8f9ee8b58b9965831d9e51baf703280dc73d3 '' } , { file = `` sqlglot-6.3.5.tar.gz '' , hash = `` sha256:5ebc4f04d7d6771d5a4ed8c638f71044b28b1ccb754bfd5cc8fbef95d250260c '' } , { file = `` psutil-5.9.2-cp27-cp27m-win32.whl '' , hash = `` sha256 : b1928b9bf478d31fdffdb57101d18f9b70ed4e9b0e41af751851813547b2a9ab '' } , name = `` sphinxcontrib-jsmath '' description = `` pytest : simple powerful testing with Python '' ================== { file = `` py-1.11.0-py2.py3-none-any.whl '' , hash = `` sha256:607c53218732647dff4acdfcd50cb62615cedf612e72d1724fb1a0cc6405b378 '' } , # poetry run black src -- check & & \ with : { file = `` typing_extensions-4.4.0.tar.gz '' , hash = `` sha256:1511434bb92bf8dd198c12b1cc812e800d4181cfcb867674e0f8279cc93087aa '' } , { file = `` psycopg_binary-3.1.3-cp39-cp39-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl '' , hash = `` sha256:1ae68869d7338f917db476da44928b58fd19137867694ff8075f44d2adab7f31 '' } , python-version : 3.10.7 { file = `` MarkupSafe-2.1.1-cp310-cp310-win32.whl '' , hash = `` sha256:4a33dea2b688b3190ee12bd7cfa29d39c9ed176bda40bfa11099a3ce5d3a7ac6 '' } , ci-flow : { file = `` setuptools-65.4.1.tar.gz '' , hash = `` sha256:3050e338e5871e70c72983072fe34f6032ae1cdeeeb67338199c2f74e083a80e '' } , { file = `` psycopg_binary-3.1.3-cp37-cp37m-macosx_10_9_x86_64.whl '' , hash = `` sha256:94edc0bcaf336def6189e7613e3bfb1c182523c2d90300c0af6d846e38c9bdfa '' } , { file = `` Babel-2.10.3.tar.gz '' , hash = `` sha256:7614553711ee97490f732126dc077f8d0ae084ebc6a96e23db1482afabdb2c51 '' } , python-versions = `` > =3.6 '' # postgresql-for-novices [ tool.poetry.scripts ] { file = `` MarkupSafe-2.1.1-cp37-cp37m-musllinux_1_1_i686.whl '' , hash = `` sha256 : bcb3ed405ed3222f9904899563d6fc492ff75cce56cba05e32eff40e6acbeaa3 '' } , { file = `` toml-0.10.2-py2.py3-none-any.whl '' , hash = `` sha256:806143ae5bfb6a3c6e736a764057db0e6a0e05e338b5630894a5f779cabb4f9b '' } , # isort = `` ^5.10.1 '' self._conn : connection = conn or psycopg2.connect ( * args , * * kwargs ) [ metadata.files ] packaging = `` > =21.0 '' import psqlwrapper Handle a user 's psql session transparently with select injections to psql output . { file = `` psycopg_binary-3.1.3-cp37-cp37m-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl '' , hash = `` sha256:2be3770e558bed382b6bb5df39933501a92c7d2817e6965d270352a4af1cc281 '' } , { file = `` psutil-5.9.2-cp37-cp37m-manylinux_2_12_i686.manylinux2010_i686.manylinux_2_17_i686.manylinux2014_i686.whl '' , hash = `` sha256:91aa0dac0c64688667b4285fa29354acfb3e834e1fd98b535b9986c883c2ce1d '' } , testing = [ `` pytest '' , `` pytest-benchmark '' ] test = [ `` flake8 '' , `` mypy '' , `` pytest '' ] on : push version = `` 4.4.0 '' mirakuru = `` > =2.3.0 '' { file = `` PyYAML-6.0-cp36-cp36m-manylinux_2_17_aarch64.manylinux2014_aarch64.whl '' , hash = `` sha256:50602afada6d6cbfad699b0c7bb50d5ccffa7e46a3d738092afddc1f9758427f '' } , { file = `` sphinxcontrib_applehelp-1.0.2-py2.py3-none-any.whl '' , hash = `` sha256:806111e5e962be97c29ec4c1e7fe277bfd19e9652fb1a4392105b43e01af885a '' } , compare = [ `` commonmark ( > =0.9.1 , < 0.10.0 ) '' , `` markdown ( > =3.3.6 , < 3.4.0 ) '' , `` mistletoe ( > =0.8.1 , < 0.9.0 ) '' , `` mistune ( > =2.0.2 , < 2.1.0 ) '' , `` panflute ( > =2.1.3 , < 2.2.0 ) '' ] print ( f '' { os.path.basename ( sys.executable ) } main.py < database name > '' ) use-chardet-on-py3 = [ `` chardet ( > =3.0.2 , < 6 ) '' ] { file = `` pytest-7.1.3.tar.gz '' , hash = `` sha256:4f365fec2dff9c1162f834d9f18af1ba13062db0c708bf7b946f8a5c76180c39 '' } , description = `` PostgreSQL for novices - helps debug PostgreSQL queries '' 'sphinx.ext.autodoc ' , description = `` Pexpect allows easy control of interactive console applications . '' mdit-py-plugins = [ test = [ `` mypy ( > =0.981 ) '' , `` pproxy ( > =2.7 ) '' , `` pytest ( > =6.2.5 ) '' , `` pytest-asyncio ( > =0.17 ) '' , `` pytest-cov ( > =3.0 ) '' , `` pytest-randomly ( > =3.10 ) '' ] { file = `` MarkupSafe-2.1.1-cp37-cp37m-manylinux_2_17_aarch64.manylinux2014_aarch64.whl '' , hash = `` sha256:3799351e2336dc91ea70b034983ee71cf2f9533cdff7c14c90ea126bfd95d65a '' } , brotli = [ `` brotli ( > =1.0.9 ) '' , `` brotlicffi ( > =0.8.0 ) '' , `` brotlipy ( > =0.6.0 ) '' ] python-versions = `` > =3.7 '' { file = `` MarkupSafe-2.1.1-cp37-cp37m-win32.whl '' , hash = `` sha256:8dc1c72a69aa7e082593c4a203dcf94ddb74bb5c8a731e4e1eb68d031e8498ff '' } , sphinx = [ { file = `` packaging-21.3.tar.gz '' , hash = `` sha256 : dd47c42927d89ab911e606518907cc2d3a1f38bbd026385970643f9c5b8ecfeb '' } , { file = `` psycopg-3.1.3-py3-none-any.whl '' , hash = `` sha256:5d19e5d10c44fd858cfb72761635200f836847df0a07cb97c3aa5df264b1379d '' } , The psql wrapper module has following requirements : markdown-it-py = [ pylint src ' rtd = [ `` ipython '' , `` sphinx-book-theme '' , `` sphinx-design '' , `` sphinxcontrib.mermaid ( > =0.7.1 , < 0.8.0 ) '' , `` sphinxext-opengraph ( > =0.6.3 , < 0.7.0 ) '' , `` sphinxext-rediraffe ( > =0.2.7 , < 0.3.0 ) '' ] Expected to be deprecated when detecting multiple statements is implemented . { file = `` psycopg_binary-3.1.3-cp310-cp310-musllinux_1_1_aarch64.whl '' , hash = `` sha256 : a8bd8becebc5e0945574cf99075a39f2942b885917c50091cea6ae2f7446e173 '' } , # postgresql-for-novices version = `` 0.18.1 '' { file = `` PyYAML-6.0-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl '' , hash = `` sha256:432557aa2c09802be39460360ddffd48156e30721f5e8d917f01d31694216782 '' } , steps : Returns an empty list if no prompt is found . Returns prompt text ( `` dbname= > '' or `` dbname= # '' ) if found . name = `` imagesize '' docutils = [ { file = `` PyYAML-6.0-cp310-cp310-manylinux_2_17_s390x.manylinux2014_s390x.whl '' , hash = `` sha256 : a80a78046a72361de73f8f395f1f1e49f956c6be882eed58505a15f3e430962b '' } , { file = `` MarkupSafe-2.1.1-cp39-cp39-win32.whl '' , hash = `` sha256 : d4306c36ca495956b6d568d276ac11fdd9c30a36f1b6eb928070dc5360b22e1c '' } , name = `` pytest-postgresql '' isort `` src '' / * * / * .py -m 3 -- trailing-comma -c & & packages = [ { include = `` pg4n '' , from = `` src '' } ] version = `` 21.3 '' # poetry run pylint src -- exit-zero self._conn : Connection = conn or psycopg.connect ( * args , * * kwargs ) { file = `` psutil-5.9.2-cp310-cp310-manylinux_2_12_x86_64.manylinux2010_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl '' , hash = `` sha256 : e3ac2c0375ef498e74b9b4ec56df3c88be43fe56cac465627572dbfb21c4be34 '' } , test = [ `` cython '' , `` html5lib '' , `` pytest ( > =4.6 ) '' , `` typed_ast '' ] { file = `` MarkupSafe-2.1.1-cp37-cp37m-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl '' , hash = `` sha256:6fbf47b5d3728c6aea2abb0589b5d30459e369baa772e0f37a0320185e87c980 '' } , pool = [ `` psycopg-pool '' ] sphinxcontrib-applehelp = [ PGUSER : postgres description = `` YAML parser and emitter for Python '' `` ` unicode-backport = [ `` unicodedata2 '' ] { file = `` psycopg_binary-3.1.3-cp310-cp310-macosx_11_0_arm64.whl '' , hash = `` sha256 : de1be1748d33ce3dbeacfec4e59886052dbbdff987ab9bd3025613d12fd716a3 '' } , docs = [ `` furo ( > =2022.9.15 ) '' , `` sphinx ( > =5.2.1 ) '' , `` sphinx-autodoc-typehints ( > =1.19.3 ) '' ] { file = `` PyYAML-6.0-cp36-cp36m-manylinux_2_17_s390x.manylinux2014_s390x.whl '' , hash = `` sha256:48c346915c114f5fdb3ead70312bd042a953a8ce5c7106d5bfb1a5254e47da92 '' } , benchmarking = [ `` psutil '' , `` pytest '' , `` pytest-benchmark ( > =3.2 , < 4.0 ) '' ] { file = `` idna-3.4-py3-none-any.whl '' , hash = `` sha256:90b77e79eaa3eba6de819a0c442c0b4ceefc341a7a2ab77d7562bf49f425c5c2 '' } , sqlglot.exp.Select ) ) # `` -0 '' allows invalidating the cache for upgrading Poetry { file = `` PyYAML-6.0-cp36-cp36m-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_12_x86_64.manylinux2010_x86_64.whl '' , hash = `` sha256:98c4d36e99714e55cfbaaee6dd5badbc9a1ec339ebfc3b1f52e293aee6bb71a4 '' } , { file = `` psycopg_binary-3.1.3-cp39-cp39-musllinux_1_1_ppc64le.whl '' , hash = `` sha256 : ccc2da1d4f5c9cea1686b645403e595d335b086792b240f83de331a4b4f8cfdc '' } , requests = [ { file = `` PyYAML-6.0-cp311-cp311-manylinux_2_17_s390x.manylinux2014_s390x.whl '' , hash = `` sha256 : dbad0e9d368bb989f4515da330b88a057617d16b6a8245084f1b05400f24609f '' } , version = `` 0.7.0 '' { file = `` MarkupSafe-2.1.1.tar.gz '' , hash = `` sha256:7f91197cc9e48f989d12e4e6fbc46495c446636dfc81b9ccf50bb0ec74b91d4b '' } , wrap = psqlwrapper.PsqlWrapper ( sys.argv [ 1 ] .encode ( `` utf-8 '' ) , pygments = [ user=getenv ( `` PGUSER '' , `` postgres '' ) , pytest = [ name = `` charset-normalizer '' { file = `` port_for-0.6.2-py3-none-any.whl '' , hash = `` sha256 : be154fdc1d8b2c50820cf1910151e0e9792f82a00ed09b8c277b551e5c99bb5a '' } , jinja2 = [ env : { file = `` psycopg_binary-3.1.3-cp38-cp38-musllinux_1_1_x86_64.whl '' , hash = `` sha256:9f1e11796963adcd29000649310e68b95260a786b54438bec19c14deb5e568dc '' } , sphinxcontrib-devhelp = `` * '' [ tool.poetry ] typehints_fully_qualified = False '.txt ' : 'markdown ' , name = `` pg4n '' dev = [ `` black ( > =22.3.0 ) '' , `` dnspython ( > =2.1 ) '' , `` flake8 ( > =4.0 ) '' , `` mypy ( > =0.981 ) '' , `` types-setuptools ( > =57.4 ) '' , `` wheel ( > =0.37 ) '' ] from . import psqlwrapper name = `` typing-extensions '' { file = `` psycopg_binary-3.1.3-cp37-cp37m-musllinux_1_1_i686.whl '' , hash = `` sha256:4a34d2487d2a62b66cc5b18f849749ee206294aa8a134c4adb8fafc0415a47f6 '' } , lock-version = `` 1.1 '' tests = [ `` pytest-cov '' , `` pytest-xdist '' ] name = `` tomli '' description = `` An easily customizable SQL parser and transpiler '' { file = `` pexpect-4.8.0-py2.py3-none-any.whl '' , hash = `` sha256:0b48a55dcb3c05f3329815901ea4fc1537514d6ba867a152b581d69ae3710937 '' } , # Architecture name = `` colorama '' version = `` 22.1.0 '' { file = `` MarkupSafe-2.1.1-cp37-cp37m-manylinux_2_17_x86_64.manylinux2014_x86_64.whl '' , hash = `` sha256 : e72591e9ecd94d7feb70c1cbd7be7b3ebea3f548870aa91e2732960fa4d57a37 '' } , def __init__ ( self , * args , conn=None , * * kwargs ) : sphinx = `` ^5.2.3 '' sphinx-autodoc-typehints = `` ^1.19.4 '' { file = `` MarkupSafe-2.1.1-cp39-cp39-musllinux_1_1_i686.whl '' , hash = `` sha256:43093fb83d8343aac0b1baa75516da6092f58f41200907ef92448ecab8825135 '' } , type-comment = [ `` typed-ast ( > =1.5.4 ) '' ] { file = `` psycopg_binary-3.1.3-cp38-cp38-musllinux_1_1_aarch64.whl '' , hash = `` sha256:4658c6945060363c7e96b7742f9b8082703b05310975070b3247f5c751f6307b '' } , dev = [ `` cloudpickle '' , `` coverage [ toml ] ( > =5.0.2 ) '' , `` furo '' , `` hypothesis '' , `` mypy ( > =0.900 , ! =0.940 ) '' , `` pre-commit '' , `` pympler '' , `` pytest ( > =4.3.0 ) '' , `` pytest-mypy-plugins '' , `` sphinx '' , `` sphinx-notfound-page '' , `` zope.interface '' ] description = `` A configurable sidebar-enabled Sphinx theme '' { file = `` psycopg_binary-3.1.3-cp38-cp38-musllinux_1_1_ppc64le.whl '' , hash = `` sha256:3df3283361e5e1a8e36ca8f788d83441551d3fdf50f53495156f535eb41c2dcc '' } , description = `` Pygments is a syntax highlighting package written in Python . '' { file = `` pytz-2022.4.tar.gz '' , hash = `` sha256:48ce799d83b6f8aab2020e369b627446696619e79645419610b9facd909b3174 '' } , pyyaml = [ python-versions = `` > =3.6.8 '' { file = `` psutil-5.9.2-cp36-cp36m-win32.whl '' , hash = `` sha256 : f40ba362fefc11d6bea4403f070078d60053ed422255bd838cd86a40674364c9 '' } , sphinxcontrib-htmlhelp = `` > =2.0.0 '' Returns an empty list if none found . python-versions = `` > =2 '' { file = `` PyYAML-6.0-cp311-cp311-win32.whl '' , hash = `` sha256 : bfaef573a63ba8923503d27530362590ff4f576c626d86a9fed95822a8255fd7 '' } , name = `` pyyaml '' description = `` sphinxcontrib-devhelp is a sphinx extension which outputs Devhelp document . '' { file = `` MarkupSafe-2.1.1-cp39-cp39-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl '' , hash = `` sha256:3ce11ee3f23f79dbd06fb3d63e2f6af7b12db1d46932fe7bd8afa259a5996603 '' } , name = `` certifi '' docs = [ `` sphinxcontrib-websupport '' ] { file = `` PyYAML-6.0-cp311-cp311-macosx_10_9_x86_64.whl '' , hash = `` sha256 : d4b0ba9512519522b118090257be113b9468d804b19d63c71dbcf4a48fa32358 '' } , mypy src -- show-error-codes -- show-error-context -- pretty & & { file = `` pycodestyle-2.9.1.tar.gz '' , hash = `` sha256:2c9607871d58c76354b697b42f5d57e1ada7d261c261efac224b664affdc5785 '' } , { file = `` sphinxcontrib_qthelp-1.0.3-py2.py3-none-any.whl '' , hash = `` sha256 : bd9fc24bcb748a8d51fd4ecaade681350aa63009a347a8c14e637895444dfab6 '' } , { file = `` urllib3-1.26.12-py2.py3-none-any.whl '' , hash = `` sha256 : b930dd878d5a8afb066a637fbb35144fe7901e3b209d1cd4f524bd0e9deee997 '' } , tzdata = { version = `` * '' , markers = `` sys_platform == \ '' win32\ '' '' } touch docs/build/.nojekyll secure = [ `` certifi '' , `` cryptography ( > =1.3.4 ) '' , `` idna ( > =2.0.0 ) '' , `` ipaddress '' , `` pyOpenSSL ( > =0.14 ) '' , `` urllib3-secure-extra '' ] { file = `` setuptools-65.4.1-py3-none-any.whl '' , hash = `` sha256:1b6bdc6161661409c5f21508763dc63ab20a9ac2f8ba20029aaaa7fdb9118012 '' } , health-cmd pg_isready sqlglot = `` ^6.3.2 '' { file = `` PyYAML-6.0-cp39-cp39-win_amd64.whl '' , hash = `` sha256 : b3d267842bf12586ba6c734f89d1f5b871df0273157918b0ccefa29deb05c21c '' } , snowballstemmer = `` > =2.0 '' { file = `` pyparsing-3.0.9.tar.gz '' , hash = `` sha256:2b020ecf7d21b687f219b71ecad3631f644a47f01403fa1d1036b0c6416d70fb '' } , pyparsing = `` > =2.0.2 , < 3.0.5 || > 3.0.5 '' { file = `` psutil-5.9.2-cp27-cp27m-manylinux2010_x86_64.whl '' , hash = `` sha256 : b2f248ffc346f4f4f0d747ee1947963613216b06688be0be2e393986fe20dbbb '' } , from . import psqlparser pytz = `` > =2015.7 '' { file = `` MarkupSafe-2.1.1-cp39-cp39-macosx_10_9_x86_64.whl '' , hash = `` sha256 : b87db4360013327109564f0e591bd2a3b318547bcef31b468a92ee504d07ae4f '' } , .. toctree : : certifi = [ description = `` sphinxcontrib-htmlhelp is a sphinx extension which renders HTML help files '' urllib3 = [ def main ( ) : if __name__ == `` __main__ '' : { file = `` psycopg_binary-3.1.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl '' , hash = `` sha256 : e8bc439231b835d55127c955a7f8e95d3b88b9a4f7f6a43f1ec2117a959114c7 '' } , ` hook_f ` is the function that the wrapper sends prettified user input & program output to , and from where it gets its helpful messages to inject before next prompt . myst-parser = `` ^0.18.1 '' import os description = `` Postgresql fixtures and fixture factories for Pytest . '' id : cache-deps psycopg-binary = [ import qepparser { file = `` psutil-5.9.2-cp39-cp39-win_amd64.whl '' , hash = `` sha256:68b35cbff92d1f7103d8f1db77c977e72f49fcefae3d3d2b91c76b0e7aef48b8 '' } , sphinxcontrib-devhelp = [ ] content-hash = `` 414b5507791102a29568bebccebc8956b0259d914d547b98cbefa492fde7874f '' if self.debug : description = `` An extended commonmark compliant parser , with bridges to docutils & sphinx . '' subqueries = filter ( { file = `` psycopg_binary-3.1.3-cp37-cp37m-manylinux_2_17_i686.manylinux2014_i686.whl '' , hash = `` sha256:211035cbd159842db7358069d135b2e4646036c33595aa4f0012644b2c64db24 '' } , { file = `` PyYAML-6.0-cp37-cp37m-macosx_10_9_x86_64.whl '' , hash = `` sha256:819b3830a1543db06c4d4b865e70ded25be52a2e0631ccd2f6a47a2822f2fd7c '' } , { file = `` psycopg_binary-3.1.3-cp310-cp310-musllinux_1_1_i686.whl '' , hash = `` sha256 : c568aeaa0ec5f3130c49b713830bfe1ae85d89fb9300d14409b8dc4cfa86391d '' } , version = `` 1.0.3 '' from psycopg import Connection { file = `` psutil-5.9.2-cp39-cp39-manylinux_2_12_x86_64.manylinux2010_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl '' , hash = `` sha256:4642fd93785a29353d6917a23e2ac6177308ef5e8be5cc17008d885cb9f70f12 '' } , if len ( sys.argv ) > 1 : psycopg = { extras = [ `` binary '' ] , version = `` ^3.1.3 '' } Parse for the content between two prompts . Returns an empty list if there is no statement or there was an error . lambda x : `` Helpful message '' , { file = `` MarkupSafe-2.1.1-cp39-cp39-macosx_10_9_universal2.whl '' , hash = `` sha256 : e04e26803c9c3851c931eac40c695602c6295b8d432cbe78609649ad9bd2da8a '' } , 'sphinx.ext.todo ' , typehints_use_rtype = False To get a similar instance as with GitHub Actions workflow : < br > alabaster = [ { file = `` psycopg_binary-3.1.3-cp38-cp38-win_amd64.whl '' , hash = `` sha256:7b1e2461562f9164a90b755702fbbd1b9141dce0b96a099371d7af0a7b7fdbe0 '' } , { file = `` psycopg_binary-3.1.3-cp39-cp39-musllinux_1_1_i686.whl '' , hash = `` sha256 : f7bf6bd26271ce9fc3c9ce60570a67b12af4c00d4ddfe02442725816f639eeff '' } , filter ( lambda x : x.parent ! = None , sql.find_all ( sqlglot.exp.Select ) ) { file = `` attrs-22.1.0.tar.gz '' , hash = `` sha256:29adc2665447e5191d0e7c568fde78b21f9672d344281d0c6e1ab085429b22b6 '' } , { file = `` MarkupSafe-2.1.1-cp38-cp38-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl '' , hash = `` sha256:96e37a3dc86e80bf81758c152fe66dbf60ed5eca3d26305edf01892257049925 '' } , pycodestyle = [ name = `` packaging '' sql.find_all ( # # # ` Wrapper ( db_name : str , hook_f : Callable [ str , str ] , parser : PsqlParser ) ` idna = [ extensions = [ from . import sqlparser { file = `` MarkupSafe-2.1.1-cp37-cp37m-musllinux_1_1_aarch64.whl '' , hash = `` sha256 : d5ee4f386140395a2c818d149221149c54849dfcfcb9f1debfe07a8b8bd63f9a '' } , # # # ` parse_for_a_new_prompt ( psql : str ) - > List [ str ] ` { file = `` alabaster-0.7.12-py2.py3-none-any.whl '' , hash = `` sha256:446438bdcca0e05bd45ea2de1668c1d9b032e1a9154c2c259092d77031ddd359 '' } , PGPASSWORD : postgres description = `` Python Library for Tom 's Obvious , Minimal Language '' # - run : | pluggy = `` > =0.12 , < 2.0 '' { file = `` MarkupSafe-2.1.1-cp310-cp310-musllinux_1_1_aarch64.whl '' , hash = `` sha256 : b09bf97215625a311f669476f44b8b318b075847b49316d3e28c08e41a7a573f '' } , # # # Linting { file = `` mdurl-0.1.2.tar.gz '' , hash = `` sha256 : bb413d29f5eea38f31dd4754dd7377d4465116fb207585f97bf925588687c1ba '' } , python-versions = `` > =2.7 , ! =3.0 . * , ! =3.1 . * , ! =3.2 . * , ! =3.3 . * , ! =3.4 . * '' i18n = [ `` Babel ( > =2.7 ) '' ] socks = [ `` PySocks ( > =1.5.6 , ! =1.5.7 ) '' ] name = `` mdurl '' psqlparser.PsqlParser ( ) ) tomli = `` > =1.0.0 '' { file = `` colorama-0.4.5.tar.gz '' , hash = `` sha256 : e6c6b4334fc50988a639d9b98aa429a0b57da6e17b9a44f0451f930b6967b7a4 '' } , /docs/build name = `` sphinx-autodoc-typehints '' from . import util # used to test relative imports description = `` Easily download , build , install , upgrade , and uninstall Python packages '' ptyprocess = [ description = `` Python style guide checker '' { file = `` sphinxcontrib-jsmath-1.0.1.tar.gz '' , hash = `` sha256 : a9925e4a4587247ed2191a22df5f6970656cb8ca2bd6284309578f2153e0c4b8 '' } , conn : connection = psycopg2.connect ( * * kwargs ) { file = `` psutil-5.9.2-cp36-cp36m-manylinux_2_12_x86_64.manylinux2010_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl '' , hash = `` sha256 : b4018d5f9b6651f9896c7a7c2c9f4652e4eea53f10751c4e7d08a9093ab587ec '' } , description = `` Cross-platform colored terminal text . '' port-for = `` * '' version = `` 2.9.1 '' To make VS Code use Poetry 's virtual environment , type ` poetry env info ` , copy virtual environment executable path , press F1 and type ` Python : Select Interpreter ` > ` Enter interpreter path ... ` > paste path and press ` < ENTER > ` . snowballstemmer = [ { file = `` MarkupSafe-2.1.1-cp38-cp38-manylinux_2_17_aarch64.manylinux2014_aarch64.whl '' , hash = `` sha256:8e576a51ad59e4bfaac456023a78f6b5e6e7651dcd383bcc3e18d06f9b55d6d1 '' } , charset-normalizer = `` > =2 , < 3 '' { file = `` myst_parser-0.18.1-py3-none-any.whl '' , hash = `` sha256:61b275b85d9f58aa327f370913ae1bec26ebad372cc99f3ab85c8ec3ee8d9fb8 '' } , postgres : { file = `` MarkupSafe-2.1.1-cp38-cp38-musllinux_1_1_x86_64.whl '' , hash = `` sha256:6a074d34ee7a5ce3effbc526b7083ec9731bb3cbf921bbe1d3005d4d2bdb3a63 '' } , version = `` 4.1.1 '' { file = `` MarkupSafe-2.1.1-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl '' , hash = `` sha256:56442863ed2b06d19c37f94d999035e15ee982988920e12a5b4ba29b62ad1f77 '' } , run : poetry install -- no-interaction -- with ci code-style = [ `` pre-commit ( > =2.12 , < 3.0 ) '' ] test = [ `` enum34 '' , `` ipaddress '' , `` mock '' , `` pywin32 '' , `` wmi '' ] from psqlparser import PsqlParser profiling = [ `` gprof2dot '' ] ` db_name ` is name of the database psql needs to access path : .venv sphinxcontrib-jsmath = [ repository-name : Project-C-SQL/Project-C-SQL.github.io name = `` sqlglot '' version = `` 0.4.5 '' name = `` sphinxcontrib-serializinghtml '' packaging = [ # # # ` parse_first_found_stmt ( psql : str ) - > List [ str ] ` html_theme = 'sphinx_rtd_theme ' requests = `` > =2.5.0 '' { file = `` PyYAML-6.0-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl '' , hash = `` sha256 : afa17f5bc4d1b10afd4466fd3a44dc0e245382deca5b3c353d8b757f9e3ecb8d '' } , [ [ package ] ] run : | from .. import qepparser Returns an empty list if no SQL statement is found . If found , returns a list of strings containing complete statement ( `` SELECT ... ; '' ) if flattened . poetry run sphinx-apidoc -q -f -o docs/api src/pg4n ' * /test_ * ' & & \ { file = `` pycodestyle-2.9.1-py2.py3-none-any.whl '' , hash = `` sha256 : d1735fc58b418fd7c5f658d28d943854f8a849b01a5d0a1e6f3f3fdd0166804b '' } , description = `` Python port of markdown-it . Markdown parsing , done right ! '' { file = `` MarkupSafe-2.1.1-cp37-cp37m-macosx_10_9_x86_64.whl '' , hash = `` sha256:671cd1187ed5e62818414afe79ed29da836dde67166a9fac6d435873c44fdd02 '' } , test = [ `` pytest '' ] typing-extensions = [ { file = `` PyYAML-6.0-cp36-cp36m-macosx_10_9_x86_64.whl '' , hash = `` sha256:897b80890765f037df3403d22bab41627ca8811ae55e9a722fd0392850ec4d86 '' } , name = `` sphinxcontrib-devhelp '' port=getenv ( `` PGPORT '' , 5432 ) , markupsafe = [ { file = `` psutil-5.9.2-cp38-cp38-win32.whl '' , hash = `` sha256:561dec454853846d1dd0247b44c2e66a0a0c490f937086930ec4b8f83bf44f06 '' } , { file = `` psutil-5.9.2-cp27-cp27m-manylinux2010_i686.whl '' , hash = `` sha256:8f024fbb26c8daf5d70287bb3edfafa22283c255287cf523c5d81721e8e5d82c '' } , rtd = [ `` attrs '' , `` myst-parser '' , `` pyyaml '' , `` sphinx '' , `` sphinx-copybutton '' , `` sphinx-design '' , `` sphinx_book_theme '' ] def __init__ ( self , * args , conn=None , * * kwargs ) : always_document_param_types = False port-for = [ name = `` myst-parser '' { file = `` psycopg_binary-3.1.3-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl '' , hash = `` sha256 : a0cf56d57d6f1abc90ce724a8f98555c72d8b0c970cbf8b5cd4bedb0d0b352ec '' } , { file = `` PyYAML-6.0-cp37-cp37m-manylinux_2_17_aarch64.manylinux2014_aarch64.whl '' , hash = `` sha256:473f9edb243cb1935ab5a084eb238d842fb8f404ed2193a915d1784b5a6b5fc0 '' } , urllib3 = `` > =1.21.1 , < 1.27 '' version = `` 4.8.0 '' api/pg4n { file = `` psycopg_binary-3.1.3-cp39-cp39-win_amd64.whl '' , hash = `` sha256 : be1e65caeeff2a7b5454dfcea2af99d60e1a3ffade5a0dc627ef2b873a7419ac '' } , description = `` library with cross-python path , ini-parsing , io , code , log facilities '' sphinx-rtd-theme = [ colorama = { version = `` * '' , markers = `` sys_platform == \ '' win32\ '' '' } { file = `` attrs-22.1.0-py2.py3-none-any.whl '' , hash = `` sha256:86efa402f67bf2df34f51a335487cf46b1ec130d02b8d39fd248abfd30da551c '' } , { file = `` sphinx-5.2.3-py3-none-any.whl '' , hash = `` sha256:7abf6fabd7b58d0727b7317d5e2650ef68765bbe0ccb63c8795fa8683477eaa2 '' } , typing-extensions = `` * '' < ! -- TODO : generate appropriately scoped access token so a bot can comment lint results version = `` 0.10.2 '' version : 1.2.2 { file = `` PyYAML-6.0-cp37-cp37m-manylinux_2_17_s390x.manylinux2014_s390x.whl '' , hash = `` sha256:0ce82d761c532fe4ec3f87fc45688bdd3a4c1dc5e0b4a19814b9009a29baefd4 '' } , tests = [ `` cloudpickle '' , `` coverage [ toml ] ( > =5.0.2 ) '' , `` hypothesis '' , `` mypy ( > =0.900 , ! =0.940 ) '' , `` pympler '' , `` pytest ( > =4.3.0 ) '' , `` pytest-mypy-plugins '' , `` zope.interface '' ] { file = `` PyYAML-6.0-cp38-cp38-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_12_x86_64.manylinux2010_x86_64.whl '' , hash = `` sha256:277a0ef2981ca40581a47093e9e2d13b3f1fbbeffae064c1d21bfceba2030287 '' } , { file = `` psycopg_binary-3.1.3-cp310-cp310-macosx_10_9_x86_64.whl '' , hash = `` sha256:77a881b5bf6f7e5a5d9f0c0ad516e3577c1eff466398e50fc795cc703e022e7c '' } , '.md ' : 'markdown ' , tests = [ `` pytest '' , `` pytest-cov '' ] version = `` 1.1.1 '' To add/remove a dependency , type ` poetry add < dep > ` / ` poetry remove < dep > ` . poetry run sphinx-build -q -b html docs docs/build & & \ description = `` Collection of plugins for markdown-it-py '' poetry run ' version = `` 0.6.2 '' { file = `` psutil-5.9.2-cp27-cp27mu-manylinux2010_i686.whl '' , hash = `` sha256:94e621c6a4ddb2573d4d30cba074f6d1aa0186645917df42c811c473dd22b339 '' } , pexpect = [ mdurl = [ POSTGRES_PASSWORD : postgres { file = `` Babel-2.10.3-py3-none-any.whl '' , hash = `` sha256 : ff56f4892c1c4bf0d814575ea23471c230d544203c7748e8c68f0089478d48eb '' } , testing = [ `` covdefaults ( > =2.2 ) '' , `` coverage ( > =6.4.4 ) '' , `` diff-cover ( > =7.0.1 ) '' , `` nptyping ( > =2.3.1 ) '' , `` pytest ( > =7.1.3 ) '' , `` pytest-cov ( > =3 ) '' , `` sphobjinv ( > =2.2.2 ) '' , `` typing-extensions ( > =4.3 ) '' ] typehints_document_rtype = True version = `` 1.7.0 '' charset-normalizer = [ version = `` 2.0.0 '' description = `` Core utilities for Python packages '' { file = `` certifi-2022.9.24-py3-none-any.whl '' , hash = `` sha256:90c1a32f1d68f940488354e36370f6cca89f0f106db09518524c88d6ed83f382 '' } , { file = `` psutil-5.9.2-cp37-cp37m-manylinux_2_12_x86_64.manylinux2010_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl '' , hash = `` sha256:4fb54941aac044a61db9d8eb56fc5bee207db3bc58645d657249030e15ba3727 '' } , { file = `` PyYAML-6.0-cp310-cp310-win32.whl '' , hash = `` sha256:2cd5df3de48857ed0544b34e2d40e9fac445930039f3cfe4bcc592a1f836d513 '' } , { file = `` pyparsing-3.0.9-py3-none-any.whl '' , hash = `` sha256:5026bae9a10eeaefb61dab2f09052b9f4307d44aee4eda64b309723d8d206bbc '' } , { file = `` markdown_it_py-2.1.0-py3-none-any.whl '' , hash = `` sha256:93de681e5c021a432c63147656fe21790bc01231e0cd2da73626f1aa3ac0fe27 '' } , { file = `` MarkupSafe-2.1.1-cp310-cp310-macosx_10_9_universal2.whl '' , hash = `` sha256:86b1f75c4e7c2ac2ccdaec2b9022845dbb81880ca318bb7a0a01fbf7813e3812 '' } , { file = `` psycopg_binary-3.1.3-cp310-cp310-musllinux_1_1_ppc64le.whl '' , hash = `` sha256 : fb7e9e17a8ec29d0199ee3f6f63fc10f7673887f0e13784764281a10bc6630da '' } , description = `` pyparsing module - Classes and methods to define and execute parsing grammars '' socks = [ `` PySocks ( > =1.5.6 , ! =1.5.7 , < 2.0 ) '' ] jinja2 = `` * '' { file = `` psycopg_binary-3.1.3-cp39-cp39-musllinux_1_1_x86_64.whl '' , hash = `` sha256:680ec51370ba42adb69c7ebe29bf12bed6e56caa7d94e85f814423c1b24fc848 '' } , main ( ) { file = `` PyYAML-6.0-cp38-cp38-macosx_10_9_x86_64.whl '' , hash = `` sha256:0b4624f379dab24d3725ffde76559cff63d9ec94e1736b556dacdfebe5ab6d4b '' } , # poetry run mypy src -- show-error-codes -- show-error-context -- pretty & & \ # nothing here else : python = `` ^3.10 '' { file = `` psutil-5.9.2-cp38-cp38-win_amd64.whl '' , hash = `` sha256:67b33f27fc0427483b61563a16c90d9f3b547eeb7af0ef1b9fe024cdc9b3a6ea '' } , { file = `` autopep8-1.7.0-py2.py3-none-any.whl '' , hash = `` sha256:6f09e90a2be784317e84dc1add17ebfc7abe3924239957a37e5040e27d812087 '' } , version = `` 2.2.0 '' sqlglot = [ { file = `` pytest-postgresql-4.1.1.tar.gz '' , hash = `` sha256:144d6af4000641decb1f0e8025d9bfdd4a0572f418c5fec7ef409b51b991295d '' } , description = `` Internationalization utilities '' { file = `` PyYAML-6.0-cp310-cp310-macosx_10_9_x86_64.whl '' , hash = `` sha256 : d4db7c7aef085872ef65a8fd7d6d09a14ae91f691dec3e87ee5ee0539d516f53 '' } , category = `` dev '' description = `` Docutils -- Python Documentation Utilities '' To install all dependencies and the application , type ` poetry install ` . After installation , if the Python scripts folder is in your PATH , you should be able to invoke ` main.main ( ) ` with ` pg4n ` . ` docker run -- rm -P -p 127.0.0.1:5432:5432 -- name pg -e POSTGRES_PASSWORD=postgres -d postgres:14.5-alpine ` { file = `` MarkupSafe-2.1.1-cp310-cp310-musllinux_1_1_x86_64.whl '' , hash = `` sha256 : efc1913fd2ca4f334418481c7e595c00aad186563bbc1ec76067848c7ca0a933 '' } , interfaces architecture key : poetry-1.2.2-0 { file = `` psutil-5.9.2-cp36-cp36m-macosx_10_9_x86_64.whl '' , hash = `` sha256 : dc9bda7d5ced744622f157cc8d8bdd51735dafcecff807e928ff26bdb0ff097d '' } , name = `` pycodestyle '' plugins = [ `` mdit-py-plugins '' ] name = `` pexpect '' description = `` Python HTTP for Humans . '' { file = `` pytest_postgresql-4.1.1-py3-none-any.whl '' , hash = `` sha256 : e4fca93189ce7e4f306ed5974cd5fdbb988f6b18ea51d12465dd301fcace933f '' } , { file = `` psycopg_binary-3.1.3-cp37-cp37m-manylinux_2_17_aarch64.manylinux2014_aarch64.whl '' , hash = `` sha256 : a70d12928b379603605e71fe0a319cec829d244ea9dad82cb9387946b81be095 '' } , idna = `` > =2.5 , < 4 '' code-style = [ `` pre-commit '' ] { file = `` psutil-5.9.2-cp310-cp310-win_amd64.whl '' , hash = `` sha256 : f4cb67215c10d4657e320037109939b1c1d2fd70ca3d76301992f89fe2edb1f1 '' } , rtd = [ `` attrs '' , `` myst-parser ( > =0.16.1 , < 0.17.0 ) '' , `` sphinx-book-theme ( > =0.1.0 , < 0.2.0 ) '' ] { file = `` MarkupSafe-2.1.1-cp38-cp38-win_amd64.whl '' , hash = `` sha256 : fc7b548b17d238737688817ab67deebb30e8073c95749d55538ed473130ec0c7 '' } , name = `` sphinxcontrib-applehelp '' { file = `` autopep8-1.7.0.tar.gz '' , hash = `` sha256 : ca9b1a83e53a7fad65d731dc7a2a2d50aa48f43850407c59f6a1a306c4201142 '' } , diagrams = [ `` jinja2 '' , `` railroad-diagrams '' ] tzdata = [ version = `` 5.9.2 '' `` WHERE order_total_eur = 0 AND order_total_eur = 100 ; '' { file = `` PyYAML-6.0-cp310-cp310-win_amd64.whl '' , hash = `` sha256 : daf496c58a8c52083df09b80c860005194014c3698698d1a57cbcfa182142a3a '' } , * : ref : ` modindex ` name = `` snowballstemmer '' name = `` markdown-it-py '' This psql output analysis program is built around three essential modules : { file = `` MarkupSafe-2.1.1-cp39-cp39-win_amd64.whl '' , hash = `` sha256:46d00d6cfecdde84d40e572d63735ef81423ad31184100411e6e3388d405e247 '' } , name = `` pytz '' [ tool.poetry.dependencies ] { file = `` PyYAML-6.0-cp311-cp311-win_amd64.whl '' , hash = `` sha256:01b45c0191e6d66c470b6cf1b9531a771a83c1c4208272ead47a3ae4f2f603bf '' } , pytest-postgresql = [ path : ~/.local : maxdepth : 2 version = `` 3.0.9 '' folder : docs/build options : > Running all linters : colorama = [ python-versions = `` > =2.7 , ! =3.0 . * , ! =3.1 . * , ! =3.2 . * , ! =3.3 . * '' name = `` sphinx-rtd-theme '' { file = `` psycopg_binary-3.1.3-cp38-cp38-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl '' , hash = `` sha256 : bb1894056f00fba3d684b7bfc336fc25c18983861cadcfb0cad0be7eb841f485 '' } , { file = `` sphinxcontrib_htmlhelp-2.0.0-py2.py3-none-any.whl '' , hash = `` sha256 : d412243dfb797ae3ec2b59eca0e52dac12e75a241bf0e4eb861e450d06c6ed07 '' } , runs-on : ubuntu-latest { file = `` MarkupSafe-2.1.1-cp310-cp310-win_amd64.whl '' , hash = `` sha256 : dda30ba7e87fbbb7eab1ec9f58678558fd9a6b8b853530e176eabd064da81417 '' } , testing = [ `` argcomplete '' , `` hypothesis ( > =3.56 ) '' , `` mock '' , `` nose '' , `` pygments ( > =2.7.2 ) '' , `` requests '' , `` xmlschema '' ] { file = `` psycopg_binary-3.1.3-cp38-cp38-manylinux_2_17_i686.manylinux2014_i686.whl '' , hash = `` sha256:329a5515cdda94d13da64f3c5088307f91220538e4d6d089845e3f323d5c364d '' } , else : To execute a command from within virtual environment shell , type ` poetry run < cmd > ` . { file = `` sphinxcontrib-qthelp-1.0.3.tar.gz '' , hash = `` sha256:4c33767ee058b70dba89a6fc5c1892c0d57a54be67ddd3e7875a18d14cba5a72 '' } , toml = `` * '' For linting , you need the CI tools : ` poetry install -with ci ` . 1 . If ` docs/api ` is not up-to-date or does n't exist , run : < br > ` poetry run sphinx-apidoc -f -o docs/api src/pg4n ' * /test_ * ' ` name = `` requests '' # # # Building documents description = `` Cross-platform lib for process and system monitoring in Python . '' version = `` 0.17.1 '' description = `` A lil ' TOML parser '' version = `` 0.1.0 '' Note that the GitHub Pages site is only updated on pushes to ` main ` branch . * [ Psql wrapper interface ] ( psql-wrapper ) pytest = `` ^7.1.3 '' psutil = { version = `` > =4.0.0 '' , markers = `` sys_platform ! = \ '' cygwin\ '' '' } version = `` 2.13.0 '' myst-parser = [ sphinxcontrib-qthelp = `` * '' { file = `` psycopg_binary-3.1.3-cp310-cp310-musllinux_1_1_x86_64.whl '' , hash = `` sha256 : a799eaa75dedf60630665e2fe8f74bafa1a3a79b9a5f56769236eee131112a01 '' } , sphinxcontrib-htmlhelp = [ Jinja2 = `` > =3.0 '' { file = `` psycopg_binary-3.1.3-cp39-cp39-musllinux_1_1_aarch64.whl '' , hash = `` sha256:0a4b8a0935153dbfe4d9546b3b6594a0e5114d6ef17eb5ae57c83e581bd06c37 '' } , { file = `` sphinxcontrib-htmlhelp-2.0.0.tar.gz '' , hash = `` sha256 : f5f8bb2d0d629f398bf47d0d69c07bc13b65f75a81ad9e2f71a63d4b7a2f6db2 '' } , version = `` 1.0.1 '' { file = `` tomli-2.0.1-py3-none-any.whl '' , hash = `` sha256:939de3e7a6161af0c887ef91b7d41a53e7c5a1ca976325f429cb46ea9bc30ecc '' } , version = `` 3.4 '' tests = [ `` pytest '' , `` pytest-cov '' , `` python-daemon '' ] { file = `` psutil-5.9.2-cp39-cp39-win32.whl '' , hash = `` sha256 : ed29ea0b9a372c5188cdb2ad39f937900a10fb5478dc077283bf86eeac678ef1 '' } , Constructor is the only currently required interface . linkify = [ `` linkify-it-py ( > =1.0 , < 2.0 ) '' ] python-versions = `` > =3.7 , < 4 '' { file = `` psutil-5.9.2-cp38-cp38-manylinux_2_12_x86_64.manylinux2010_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl '' , hash = `` sha256 : f7929a516125f62399d6e8e026129c8835f6c5a3aab88c3fff1a05ee8feb840d '' } , wrap = psqlwrapper.PsqlWrapper ( sys.argv [ 1 ] .encode ( `` utf-8 '' ) , description = `` sphinxcontrib-qthelp is a sphinx extension which outputs QtHelp document . '' imagesize = `` > =1.3 '' name = `` sphinx '' source_suffix = { version = `` 5.2.3 '' # black = `` ^22.10.0 '' { file = `` psycopg_binary-3.1.3-cp37-cp37m-musllinux_1_1_ppc64le.whl '' , hash = `` sha256:0d9fa168faf2b87d09148450819a7842d1ba499585e921725a1e0abfd132b770 '' } , image : postgres:14.5-alpine git-config-email : < > # # # Imports 5432:5432 version = `` 2022.4 '' lambda x : `` Helpful message '' , version = `` 0.1.2 '' iniconfig = [ { file = `` MarkupSafe-2.1.1-cp310-cp310-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl '' , hash = `` sha256 : b7bd98b796e2b6553da7225aeb61f447f80a1ca64f41d83612e6139ca5213aa4 '' } , attrs = `` > =19.2.0 '' [ package.extras ] version = `` 6.0 '' version = `` 1.0.0 '' import os version = `` 3.1.2 '' name = `` psycopg-binary '' { file = `` pytz-2022.4-py2.py3-none-any.whl '' , hash = `` sha256:2c0784747071402c6e99f0bafdb7da0fa22645f06554c7ae06bf6358897e9c91 '' } , { file = `` PyYAML-6.0-cp38-cp38-manylinux_2_17_s390x.manylinux2014_s390x.whl '' , hash = `` sha256:9fa600030013c4de8165339db93d182b9431076eb98eb40ee068700c9c813e34 '' } , ====================== { file = `` sphinxcontrib_jsmath-1.0.1-py2.py3-none-any.whl '' , hash = `` sha256:2ec2eaebfb78f3f2078e73666b1415417a116cc848b72e5172e596c871103178 '' } , description = `` plugin and hook calling mechanisms for python '' { file = `` iniconfig-1.1.1-py2.py3-none-any.whl '' , hash = `` sha256:011e24c64b7f47f6ebd835bb12a743f2fbe9a26d4cecaa7f53bc4f35ee9da8b3 '' } , # TODO : generate appropriately scoped access token so a bot can comment lint results print ( f '' { os.path.basename ( sys.executable ) } main.py < database name > '' ) { file = `` MarkupSafe-2.1.1-cp39-cp39-musllinux_1_1_x86_64.whl '' , hash = `` sha256:8e3dcf21f367459434c18e71b2a9532d96547aef8a871872a5bd69a715c15f96 '' } , { file = `` PyYAML-6.0-cp39-cp39-macosx_11_0_arm64.whl '' , hash = `` sha256 : e61ceaab6f49fb8bdfaa0f92c4b57bcfbea54c09277b1b4f7ac376bfb7a7c174 '' } , { file = `` requests-2.28.1-py3-none-any.whl '' , hash = `` sha256:8fefa2a1a1365bf5520aac41836fbee479da67864514bdb821f31ce07ce65349 '' } , description = `` Classes Without Boilerplate '' description = `` PostgreSQL database adapter for Python '' Indices and tables [ package.dependencies ] { file = `` sqlglot-6.3.5-py3-none-any.whl '' , hash = `` sha256:913628dc6cbeef5e7fee725ffe206fbc6363421d1bf2ab8f5de5a465029a522d '' } , * : ref : ` genindex ` # pylint = `` ^2.15.4 '' ptyprocess = `` > =0.5 '' version = `` 2.10.3 '' sphinxcontrib-qthelp = [ { file = `` tomli-2.0.1.tar.gz '' , hash = `` sha256 : de526c12914f0c550d15924c62d72abc48d6fe7364aa87328337a31007fe8a4f '' } , name = `` pygments '' { file = `` psutil-5.9.2-cp38-cp38-macosx_10_9_x86_64.whl '' , hash = `` sha256 : fd331866628d18223a4265371fd255774affd86244fc307ef66eaf00de0633d5 '' } , # # # Running tests if len ( sys.argv ) > 1 : Get query statements and their results , and sanitize them for syntactic analysis name = `` pluggy '' host=getenv ( `` PGHOST '' , `` 127.0.0.1 '' ) , description = `` Internationalized Domain Names in Applications ( IDNA ) '' { file = `` psycopg_binary-3.1.3-cp39-cp39-manylinux_2_17_i686.manylinux2014_i686.whl '' , hash = `` sha256:9a07815dec9b06a686e61320a4f3733c4750cd44f5338d742d2fa86b72ff4ee4 '' } , sphinxcontrib-jsmath = `` * '' def parser ( postgresql : connection ) : 'myst_parser ' , from .psqlparser import PsqlParser version = `` 2022.9.24 '' { file = `` psycopg_binary-3.1.3-cp38-cp38-macosx_10_9_x86_64.whl '' , hash = `` sha256:590fde0fbf5d94736c29bce210d9c975829f0eb667930102e7783c5ef35fa7c3 '' } , version = `` 1.19.4 '' description = `` Process executor ( not only ) for tests . '' import psqlparser { file = `` psycopg_binary-3.1.3-cp37-cp37m-musllinux_1_1_x86_64.whl '' , hash = `` sha256:69f5b4b1da0cb1432de36c044a705aff61a8ab130ccafab3548a7a3b789538fd '' } , { file = `` sphinx_autodoc_typehints-1.19.4-py3-none-any.whl '' , hash = `` sha256 : e190d8ee8204c3de05a64f41cf10e592e987e4063c8ec0de7e4b11f6e036b2e2 '' } , pexpect = `` ^4.8.0 '' { file = `` docutils-0.17.1.tar.gz '' , hash = `` sha256:686577d2e4c32380bb50cbb22f575ed742d58168cee37e99117a854bcd88f125 '' } , { file = `` sphinx_autodoc_typehints-1.19.4.tar.gz '' , hash = `` sha256 : ffd8e710f6757471b5c831c7ece88f52a9ff15f27836f4ef1c8695a64f8dcca8 '' } , { file = `` pluggy-1.0.0-py2.py3-none-any.whl '' , hash = `` sha256:74134bbf457f031a36d68416e1509f34bd5ccc019f0bcc952c7b909d06b37bd3 '' } , copyright = '2022 , Heikkilä et al . ' testing = [ `` build [ virtualenv ] '' , `` filelock ( > =3.4.0 ) '' , `` flake8 ( < 5 ) '' , `` flake8-2020 '' , `` ini2toml [ lite ] ( > =0.9 ) '' , `` jaraco.envs ( > =2.2 ) '' , `` jaraco.path ( > =3.2.0 ) '' , `` mock '' , `` pip ( > =19.1 ) '' , `` pip-run ( > =8.8 ) '' , `` pytest ( > =6 ) '' , `` pytest-black ( > =0.3.7 ) '' , `` pytest-checkdocs ( > =2.4 ) '' , `` pytest-cov '' , `` pytest-enabler ( > =1.3 ) '' , `` pytest-flake8 '' , `` pytest-mypy ( > =0.9.1 ) '' , `` pytest-perf '' , `` pytest-xdist '' , `` tomli-w ( > =1.0.0 ) '' , `` virtualenv ( > =13.0.0 ) '' , `` wheel '' ] description = `` A very fast and expressive template engine . '' { file = `` MarkupSafe-2.1.1-cp38-cp38-win32.whl '' , hash = `` sha256:421be9fbf0ffe9ffd7a378aafebbf6f4602d564d34be190fc19a193232fd12b1 '' } , { file = `` snowballstemmer-2.2.0.tar.gz '' , hash = `` sha256:09b16deb8547d3412ad7b590689584cd0fe25ec8db3be37788be3810cbf19cb1 '' } , { file = `` MarkupSafe-2.1.1-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl '' , hash = `` sha256:10c1bfff05d95783da83491be968e8fe789263689c02724e0c691933c52994f5 '' } , version = `` 2.1.0 '' lint = [ `` docutils-stubs '' , `` flake8 '' , `` mypy '' ] plugins = [ `` importlib-metadata '' ] .vscode/ mirakuru = [ # TODO : generate appropriately scoped access token so a bot can comment lint results","['.github/workflows/ci-flow.yml', '.gitignore', 'README.md', 'docs/architecture.md', 'docs/conf.py', 'docs/index.rst', 'docs/interfaces.md', 'docs/program-architecture.md', 'main.py', 'orderby.py', 'poetry.lock', 'psqlparser.py', 'psqlwrapper.py', 'pyproject.toml', 'qepparser.py', 'sqlparser.py', 'src/pg4n/__init__.py', 'src/pg4n/main.py', 'src/pg4n/orderby.py', 'src/pg4n/psqlparser.py', 'src/pg4n/psqlwrapper.py', 'src/pg4n/qepparser.py', 'src/pg4n/sqlparser.py', 'src/pg4n/test/__init__.py', 'src/pg4n/test/test_qepparser.py', 'src/pg4n/util.py', 'test_qepparser.py']",2022-09-25 13:26:43+00:00,2022-10-13 09:22:39+00:00,2022-10-13 12:22:38+03:00
18,149f24e74104b324b62326453e7cbe12b53a5f5a,1.0247912541672122e-05,1,Design required classes and interfaces according to SOLID principles and potentially GoF design patterns . Document them in GitHub wiki .,Document architecture and interfaces for semantic analysis,Merge pull request # 101 from Project-C-SQL/feat/maintenance-plan,"# # # Extending parsers Returns warning message if the sql has SUM/AVG ( DISTINCT ... ) , otherwise None Handle a user 's psql session transparently with select injections to psql output . Wildcards without LIKE ( Error 34 per Brass and Goldberg , 2005 ) ( ` EqWildcardChecker ` ) Returns an empty list if none found . Returns an empty list if no SQL statement is found . If found , returns a list of strings containing complete statement ( `` SELECT ... ; '' ) if flattened . Inconsistent expression ( Error 1 per Brass and Goldberg , 2005 ) ( ` InconsistentExpressionChecker ` ) # # # # ConfigReader Frontend handles user 's psql session completely transparently via ` PsqlWrapper ` , although also injecting insightful messages regarding user 's semantic errors into the terminal output stream . It parses user 's SQL queries via ` PsqlParser ` for consumption in the backend . otherwise None . Strange HAVING ( Error 32 per Brass and Goldberg , 2005 ) ( ` StrangeHavingChecker ` ) Expected to be deprecated when detecting multiple statements is implemented . ` PsqlParser ` uses ` pyparsing ` parser combinator library to provide parsing functions for SELECT in subquery uses no tuple variable of subquery ( Error 29 per Brass and Goldberg , 2005 ) ( ` SubquerySelectChecker ` ) Get query statements and their results , and sanitize them for syntactic analysis Pg4n only injects messages for the user , and is otherwise completely transparent . For this reason , usage is identical to ` psql ` usage . [ PostgreSQL : Documentation : 14 : psql ] ( https : //www.postgresql.org/docs/14/app-psql.html ) Comparison between different domains ( Error 31 per Brass and Goldberg , 2005 ) ( ` CmpDomainChecker ` ) # # Updating pg4n If improper parsing is suspected , turn ` PsqlParser.debug ` to ` True ` , that way all ` ParserException.explain ` s are saved into ` psqlparser.log ` . These exceptions are verbose , and will require fair amount of sifting . If improper interception by ` PsqlWrapper ` is suspected , turn ` PsqlWrapper.debug ` to ` True ` , to have current ` pyte ` display contents copied to ` pyte.screen ` on every update , and ` pexpect ` terminal control stream appended into ` psqlwrapper.log ` . Any wrapper issues are expected to be quite obtuse to fix , as they likely are ` pexpect ` or ` pyte ` library issues . # # # ErrorFormatter Returns warning message if the sql has equals operation to a string with For example : x = 10 AND x = 20 This psql output analysis program is built around three essential modules : * [ Psql wrapper interface ] ( ./interfaces.md # psqlwrapper ) pg4n # # PsqlParser Implied expression ( Table already enforces the given expression ) ( ` ImpliedExpressionChecker ` ) See API docs . ` parser ` is an implementation of PsqlParser interface . ` pyparsing ` documentation is available on [ Welcome to PyParsing ’ s documentation ! ] ( https : //pyparsing-docs.readthedocs.io/en/latest/ ) # # # Fixing parsing/interception bugs $ HOME/.config/pg4n.conf , and lastly from $ PWD/pg4n.conf , with each new value Does analysis for suspicous comparisons between different domains . # # # SQLParser # Interfaces This checker only finds a small subset of such expression , where postgresql # # # ` parse_for_a_new_prompt ( psql : str ) - > List [ str ] ` # # # # InconsistentExpressionChecker # # # SemanticRouter # # # PsqlWrapper # # Known limitations ` PsqlWrapper ` also checks ` psql ` version info and checks it against ` PsqlWrapper.supported_psql_versions ` . # # # Analysis modules # Program architecture Contains option values specied in the configuration files . Condition in the subquery can be moved up ( Error 30 per Brass and Goldberg , 2005 ) ( ` SubquerySelectChecker ` ) # General information Each Checker class must use this to format their warning messages . ` PsqlWrapper ` is responsible for spawning and intercepting the user-interfacing ` psql ` process . ` pexpect ` library allows both spawning and intercepting the terminal control stream . ` pyte ` library keeps track of current terminal display . Unified error formatting . Parsing rules common to more than 1 of these functions are listed in ` PsqlParser ` body , but otherwise rules are inside respective functions . parsing last SQL SELECT query in a string ( ` parse_last_stmt ` ) # # # Program configuration Also provides some utilities like finding all tables in a sql statement . # # # # StrangeHavingChecker ` PsqlConnInfo ` fetches PostgresSQL connection info by running a ` psql ` command with given arguments ( usually same arguments as with what the main ` psql ` process was called with ) . e.g. , comparing columns off type VARCHAR ( 20 ) and VARCHAR ( 50 ) Reads all configuration files and combines their option output into a ` ConfigValues ` class . The psql wrapper module has following requirements : Options in the configuration file are written like : `` option\_name value '' where value may be : true , 1 , yes , false , 0 , no Returns an empty list if no prompt is found . Returns prompt text ( `` dbname= > '' or `` dbname= # '' ) if found . # # # # SubquerySelectChecker # # Using pg4n Overall working logic is handled by ` _check_and_act_on_repl_output ` , where it can be seen that queries are checked for every time user presses Return . If ` PsqlParser ` finds an SQL SELECT query , it 's passed to ` SemanticRouter ` for further analysis , and any insightful message returned is saved for later . Once all query results have been printed , and a new prompt ( e.g ` .. = > ` ) is going to be printed next per ` latest_output ` parameter , the wrapper injects the returned message . If results included ` ERROR : ` .. ` ^ ` , it is sent to syntax error analysis , and any returned message will be injected immediately . ! [ Program architecture sketch ] ( ./architecture.jpg ) # # Semantic errors detected ` psql ` is the psql REPL log to be inspected . ` PsqlWrapper ` has a ` hook_syntax_f ` function parameter ( of type ` str - > str ` ) , which is called with ` PsqlParser.parse_syntax_error ` -produced string , ideally `` ERROR : ... ^ '' , which , to our understanding , will always include the whole result , and also the SQL query itself ( as caret will point to it ) , so it does not have to be parsed separately . A syntax error analysis component should then return a message string , and it will be displayed in exactly the same way as semantic error strings . # # # # EqWildcardChecker Binary files a/docs/architecture.jpg and /dev/null differ Parse for an empty prompt , usually to detect when a query evaluation has ended . # # # ` Wrapper ( db_name : str , hook_f : Callable [ str , str ] , parser : PsqlParser ) ` Returns a warning message if something was found , otherwise None . Returns warning message if there no column SELECTed in a subquery is # # # # SumDistinctChecker # # # # ConfigValues Parses a configuration file . introduced in latter files overriding the previous value . The configuration files are read in order from : /etc/pg4n.conf then from $ XDG\_CONFIG\_HOME/pg4n.conf , or if $ XDG\_CONFIG\_HOME is not set , from Most of the semantic analysis modules have been implemented by parsing the SQL with ` sqlglot ` . Only few of the Checker classes use the query evaluation plan ( QEP ) . program-architecture maintenance-plan checking if given string has a new prompt ( e.g ` = > ` ) ( ` output_has_new_prompt ` ) # # # # ConfigParser # # Installing pg4n ` hook_f ` is the function that the wrapper sends prettified user input & program output to , and from where it gets its helpful messages to inject before next prompt . To our knowledge , there are no interdependencies with the parser functions , so they should be able to be extended as needed , and new ones added . By default all warnings are enabled . Warnings can be disabled by warning type ( which can be found from every warning message 's end ) e.g . parsing ` psql -- version ` output for version number ( ` parse_psql_version ` ) Constructor is the only currently required interface . # # Backend should never give false positives , only false negatives . exposes that information via its query execution plan . Returns warning message if there exists ORDER BY in a subquery , ` pip install pg4n ` itself detects the inconsistent expression in its query optimizer and wild card character ( the ' % ' character ) , otherwise None . ` CmpDomains false ` Semantic error modules are expected to produce false negatives . Parse for the content between two prompts . Returns an empty list if there is no statement or there was an error . # # # QEPParser DISTINCT in SUM and AVG ( Error 33 per Brass and Goldberg , 2005 ) ( ` SumDistinctChecker ` ) parsing syntax errors ( ` ERROR : ` .. ` ^ ` ) ( ` parse_syntax_error ` ) ` pip install -- upgrade pg4n ` Transforms sql string into a syntax tree . # # PsqlWrapper # # # # SubqueryOrderByChecker # # # Implementing semantic analysis modules # Maintaining pg4n # # # # CmpDomainChecker not used in that subquery of its own columns , otherwise returns None . Returns warning message if there exists HAVING without a GROUP BY , otherwise None . Runs SQLParser , QEPParser and semantic error analysis modules ( as configured ) against given SQL query string . ` pexpect ` does not seem to handle all terminal traffic . ` pyte ` and user terminal occasionally disagree on contents when user uses ctrl-R to fetch past queries , which prevents screenscraping SQL query properly . ` pyte ` also disagrees on display contents when exiting a separate query results screen , but this has no impact on ` pg4n ` performance . # # # PsqlParser interfaces # # # PsqlConnInfo # # # Thoughts on syntax error analysis ORDER BY in a subquery ( ` SubqueryOrderByChecker ` ) checking for non-obvious Return presses ( ` output_has_magical_return ` ) # # # ` parse_first_found_stmt ( psql : str ) - > List [ str ] ` ` db_name ` is name of the database psql needs to access Inconsistent expression is some expression that is never true . Returns warning message if implied expression is detected , otherwise None . # # # # ImpliedExpressionChecker # # Frontend parsing a new prompt and everything that precedes it in a string , to allow easy message injection ( ` parse_new_prompt_and_rest ` ) This check gives misses some situations with redundant ORDER BY but","['docs/architecture.jpg', 'docs/architecture.md', 'docs/index.rst', 'docs/interfaces.md', 'docs/maintenance-plan.md', 'docs/pg4n.md', 'docs/program-architecture.md']",2022-09-29 09:55:51+00:00,2022-11-10 10:38:14+00:00,2022-12-16 18:54:08+02:00
19,149f24e74104b324b62326453e7cbe12b53a5f5a,1.026375775836641e-05,1,Design required classes and interfaces according to SOLID principles and potentially GoF design patterns . Document them in wiki .,Document architecture and interfaces for QEP parser,Merge pull request # 101 from Project-C-SQL/feat/maintenance-plan,"# # # Extending parsers Returns warning message if the sql has SUM/AVG ( DISTINCT ... ) , otherwise None Handle a user 's psql session transparently with select injections to psql output . Wildcards without LIKE ( Error 34 per Brass and Goldberg , 2005 ) ( ` EqWildcardChecker ` ) Returns an empty list if none found . Returns an empty list if no SQL statement is found . If found , returns a list of strings containing complete statement ( `` SELECT ... ; '' ) if flattened . Inconsistent expression ( Error 1 per Brass and Goldberg , 2005 ) ( ` InconsistentExpressionChecker ` ) # # # # ConfigReader Frontend handles user 's psql session completely transparently via ` PsqlWrapper ` , although also injecting insightful messages regarding user 's semantic errors into the terminal output stream . It parses user 's SQL queries via ` PsqlParser ` for consumption in the backend . otherwise None . Strange HAVING ( Error 32 per Brass and Goldberg , 2005 ) ( ` StrangeHavingChecker ` ) Expected to be deprecated when detecting multiple statements is implemented . ` PsqlParser ` uses ` pyparsing ` parser combinator library to provide parsing functions for SELECT in subquery uses no tuple variable of subquery ( Error 29 per Brass and Goldberg , 2005 ) ( ` SubquerySelectChecker ` ) Get query statements and their results , and sanitize them for syntactic analysis Pg4n only injects messages for the user , and is otherwise completely transparent . For this reason , usage is identical to ` psql ` usage . [ PostgreSQL : Documentation : 14 : psql ] ( https : //www.postgresql.org/docs/14/app-psql.html ) Comparison between different domains ( Error 31 per Brass and Goldberg , 2005 ) ( ` CmpDomainChecker ` ) # # Updating pg4n If improper parsing is suspected , turn ` PsqlParser.debug ` to ` True ` , that way all ` ParserException.explain ` s are saved into ` psqlparser.log ` . These exceptions are verbose , and will require fair amount of sifting . If improper interception by ` PsqlWrapper ` is suspected , turn ` PsqlWrapper.debug ` to ` True ` , to have current ` pyte ` display contents copied to ` pyte.screen ` on every update , and ` pexpect ` terminal control stream appended into ` psqlwrapper.log ` . Any wrapper issues are expected to be quite obtuse to fix , as they likely are ` pexpect ` or ` pyte ` library issues . # # # ErrorFormatter Returns warning message if the sql has equals operation to a string with For example : x = 10 AND x = 20 This psql output analysis program is built around three essential modules : * [ Psql wrapper interface ] ( ./interfaces.md # psqlwrapper ) pg4n # # PsqlParser Implied expression ( Table already enforces the given expression ) ( ` ImpliedExpressionChecker ` ) See API docs . ` parser ` is an implementation of PsqlParser interface . ` pyparsing ` documentation is available on [ Welcome to PyParsing ’ s documentation ! ] ( https : //pyparsing-docs.readthedocs.io/en/latest/ ) # # # Fixing parsing/interception bugs $ HOME/.config/pg4n.conf , and lastly from $ PWD/pg4n.conf , with each new value Does analysis for suspicous comparisons between different domains . # # # SQLParser # Interfaces This checker only finds a small subset of such expression , where postgresql # # # ` parse_for_a_new_prompt ( psql : str ) - > List [ str ] ` # # # # InconsistentExpressionChecker # # # SemanticRouter # # # PsqlWrapper # # Known limitations ` PsqlWrapper ` also checks ` psql ` version info and checks it against ` PsqlWrapper.supported_psql_versions ` . # # # Analysis modules # Program architecture Contains option values specied in the configuration files . Condition in the subquery can be moved up ( Error 30 per Brass and Goldberg , 2005 ) ( ` SubquerySelectChecker ` ) # General information Each Checker class must use this to format their warning messages . ` PsqlWrapper ` is responsible for spawning and intercepting the user-interfacing ` psql ` process . ` pexpect ` library allows both spawning and intercepting the terminal control stream . ` pyte ` library keeps track of current terminal display . Unified error formatting . Parsing rules common to more than 1 of these functions are listed in ` PsqlParser ` body , but otherwise rules are inside respective functions . parsing last SQL SELECT query in a string ( ` parse_last_stmt ` ) # # # Program configuration Also provides some utilities like finding all tables in a sql statement . # # # # StrangeHavingChecker ` PsqlConnInfo ` fetches PostgresSQL connection info by running a ` psql ` command with given arguments ( usually same arguments as with what the main ` psql ` process was called with ) . e.g. , comparing columns off type VARCHAR ( 20 ) and VARCHAR ( 50 ) Reads all configuration files and combines their option output into a ` ConfigValues ` class . The psql wrapper module has following requirements : Options in the configuration file are written like : `` option\_name value '' where value may be : true , 1 , yes , false , 0 , no Returns an empty list if no prompt is found . Returns prompt text ( `` dbname= > '' or `` dbname= # '' ) if found . # # # # SubquerySelectChecker # # Using pg4n Overall working logic is handled by ` _check_and_act_on_repl_output ` , where it can be seen that queries are checked for every time user presses Return . If ` PsqlParser ` finds an SQL SELECT query , it 's passed to ` SemanticRouter ` for further analysis , and any insightful message returned is saved for later . Once all query results have been printed , and a new prompt ( e.g ` .. = > ` ) is going to be printed next per ` latest_output ` parameter , the wrapper injects the returned message . If results included ` ERROR : ` .. ` ^ ` , it is sent to syntax error analysis , and any returned message will be injected immediately . ! [ Program architecture sketch ] ( ./architecture.jpg ) # # Semantic errors detected ` psql ` is the psql REPL log to be inspected . ` PsqlWrapper ` has a ` hook_syntax_f ` function parameter ( of type ` str - > str ` ) , which is called with ` PsqlParser.parse_syntax_error ` -produced string , ideally `` ERROR : ... ^ '' , which , to our understanding , will always include the whole result , and also the SQL query itself ( as caret will point to it ) , so it does not have to be parsed separately . A syntax error analysis component should then return a message string , and it will be displayed in exactly the same way as semantic error strings . # # # # EqWildcardChecker Binary files a/docs/architecture.jpg and /dev/null differ Parse for an empty prompt , usually to detect when a query evaluation has ended . # # # ` Wrapper ( db_name : str , hook_f : Callable [ str , str ] , parser : PsqlParser ) ` Returns a warning message if something was found , otherwise None . Returns warning message if there no column SELECTed in a subquery is # # # # SumDistinctChecker # # # # ConfigValues Parses a configuration file . introduced in latter files overriding the previous value . The configuration files are read in order from : /etc/pg4n.conf then from $ XDG\_CONFIG\_HOME/pg4n.conf , or if $ XDG\_CONFIG\_HOME is not set , from Most of the semantic analysis modules have been implemented by parsing the SQL with ` sqlglot ` . Only few of the Checker classes use the query evaluation plan ( QEP ) . program-architecture maintenance-plan checking if given string has a new prompt ( e.g ` = > ` ) ( ` output_has_new_prompt ` ) # # # # ConfigParser # # Installing pg4n ` hook_f ` is the function that the wrapper sends prettified user input & program output to , and from where it gets its helpful messages to inject before next prompt . To our knowledge , there are no interdependencies with the parser functions , so they should be able to be extended as needed , and new ones added . By default all warnings are enabled . Warnings can be disabled by warning type ( which can be found from every warning message 's end ) e.g . parsing ` psql -- version ` output for version number ( ` parse_psql_version ` ) Constructor is the only currently required interface . # # Backend should never give false positives , only false negatives . exposes that information via its query execution plan . Returns warning message if there exists ORDER BY in a subquery , ` pip install pg4n ` itself detects the inconsistent expression in its query optimizer and wild card character ( the ' % ' character ) , otherwise None . ` CmpDomains false ` Semantic error modules are expected to produce false negatives . Parse for the content between two prompts . Returns an empty list if there is no statement or there was an error . # # # QEPParser DISTINCT in SUM and AVG ( Error 33 per Brass and Goldberg , 2005 ) ( ` SumDistinctChecker ` ) parsing syntax errors ( ` ERROR : ` .. ` ^ ` ) ( ` parse_syntax_error ` ) ` pip install -- upgrade pg4n ` Transforms sql string into a syntax tree . # # PsqlWrapper # # # # SubqueryOrderByChecker # # # Implementing semantic analysis modules # Maintaining pg4n # # # # CmpDomainChecker not used in that subquery of its own columns , otherwise returns None . Returns warning message if there exists HAVING without a GROUP BY , otherwise None . Runs SQLParser , QEPParser and semantic error analysis modules ( as configured ) against given SQL query string . ` pexpect ` does not seem to handle all terminal traffic . ` pyte ` and user terminal occasionally disagree on contents when user uses ctrl-R to fetch past queries , which prevents screenscraping SQL query properly . ` pyte ` also disagrees on display contents when exiting a separate query results screen , but this has no impact on ` pg4n ` performance . # # # PsqlParser interfaces # # # PsqlConnInfo # # # Thoughts on syntax error analysis ORDER BY in a subquery ( ` SubqueryOrderByChecker ` ) checking for non-obvious Return presses ( ` output_has_magical_return ` ) # # # ` parse_first_found_stmt ( psql : str ) - > List [ str ] ` ` db_name ` is name of the database psql needs to access Inconsistent expression is some expression that is never true . Returns warning message if implied expression is detected , otherwise None . # # # # ImpliedExpressionChecker # # Frontend parsing a new prompt and everything that precedes it in a string , to allow easy message injection ( ` parse_new_prompt_and_rest ` ) This check gives misses some situations with redundant ORDER BY but","['docs/architecture.jpg', 'docs/architecture.md', 'docs/index.rst', 'docs/interfaces.md', 'docs/maintenance-plan.md', 'docs/pg4n.md', 'docs/program-architecture.md']",2022-09-29 09:56:52+00:00,2022-11-10 10:38:31+00:00,2022-12-16 18:54:08+02:00
21,149f24e74104b324b62326453e7cbe12b53a5f5a,1.0286275937687606e-05,1,Design required classes and interfaces according to SOLID principles and potentially GoF design patterns . Document in GitHub wiki,Document architecture and interfaces for the wrapper,Merge pull request # 101 from Project-C-SQL/feat/maintenance-plan,"# # # Extending parsers Returns warning message if the sql has SUM/AVG ( DISTINCT ... ) , otherwise None Handle a user 's psql session transparently with select injections to psql output . Wildcards without LIKE ( Error 34 per Brass and Goldberg , 2005 ) ( ` EqWildcardChecker ` ) Returns an empty list if none found . Returns an empty list if no SQL statement is found . If found , returns a list of strings containing complete statement ( `` SELECT ... ; '' ) if flattened . Inconsistent expression ( Error 1 per Brass and Goldberg , 2005 ) ( ` InconsistentExpressionChecker ` ) # # # # ConfigReader Frontend handles user 's psql session completely transparently via ` PsqlWrapper ` , although also injecting insightful messages regarding user 's semantic errors into the terminal output stream . It parses user 's SQL queries via ` PsqlParser ` for consumption in the backend . otherwise None . Strange HAVING ( Error 32 per Brass and Goldberg , 2005 ) ( ` StrangeHavingChecker ` ) Expected to be deprecated when detecting multiple statements is implemented . ` PsqlParser ` uses ` pyparsing ` parser combinator library to provide parsing functions for SELECT in subquery uses no tuple variable of subquery ( Error 29 per Brass and Goldberg , 2005 ) ( ` SubquerySelectChecker ` ) Get query statements and their results , and sanitize them for syntactic analysis Pg4n only injects messages for the user , and is otherwise completely transparent . For this reason , usage is identical to ` psql ` usage . [ PostgreSQL : Documentation : 14 : psql ] ( https : //www.postgresql.org/docs/14/app-psql.html ) Comparison between different domains ( Error 31 per Brass and Goldberg , 2005 ) ( ` CmpDomainChecker ` ) # # Updating pg4n If improper parsing is suspected , turn ` PsqlParser.debug ` to ` True ` , that way all ` ParserException.explain ` s are saved into ` psqlparser.log ` . These exceptions are verbose , and will require fair amount of sifting . If improper interception by ` PsqlWrapper ` is suspected , turn ` PsqlWrapper.debug ` to ` True ` , to have current ` pyte ` display contents copied to ` pyte.screen ` on every update , and ` pexpect ` terminal control stream appended into ` psqlwrapper.log ` . Any wrapper issues are expected to be quite obtuse to fix , as they likely are ` pexpect ` or ` pyte ` library issues . # # # ErrorFormatter Returns warning message if the sql has equals operation to a string with For example : x = 10 AND x = 20 This psql output analysis program is built around three essential modules : * [ Psql wrapper interface ] ( ./interfaces.md # psqlwrapper ) pg4n # # PsqlParser Implied expression ( Table already enforces the given expression ) ( ` ImpliedExpressionChecker ` ) See API docs . ` parser ` is an implementation of PsqlParser interface . ` pyparsing ` documentation is available on [ Welcome to PyParsing ’ s documentation ! ] ( https : //pyparsing-docs.readthedocs.io/en/latest/ ) # # # Fixing parsing/interception bugs $ HOME/.config/pg4n.conf , and lastly from $ PWD/pg4n.conf , with each new value Does analysis for suspicous comparisons between different domains . # # # SQLParser # Interfaces This checker only finds a small subset of such expression , where postgresql # # # ` parse_for_a_new_prompt ( psql : str ) - > List [ str ] ` # # # # InconsistentExpressionChecker # # # SemanticRouter # # # PsqlWrapper # # Known limitations ` PsqlWrapper ` also checks ` psql ` version info and checks it against ` PsqlWrapper.supported_psql_versions ` . # # # Analysis modules # Program architecture Contains option values specied in the configuration files . Condition in the subquery can be moved up ( Error 30 per Brass and Goldberg , 2005 ) ( ` SubquerySelectChecker ` ) # General information Each Checker class must use this to format their warning messages . ` PsqlWrapper ` is responsible for spawning and intercepting the user-interfacing ` psql ` process . ` pexpect ` library allows both spawning and intercepting the terminal control stream . ` pyte ` library keeps track of current terminal display . Unified error formatting . Parsing rules common to more than 1 of these functions are listed in ` PsqlParser ` body , but otherwise rules are inside respective functions . parsing last SQL SELECT query in a string ( ` parse_last_stmt ` ) # # # Program configuration Also provides some utilities like finding all tables in a sql statement . # # # # StrangeHavingChecker ` PsqlConnInfo ` fetches PostgresSQL connection info by running a ` psql ` command with given arguments ( usually same arguments as with what the main ` psql ` process was called with ) . e.g. , comparing columns off type VARCHAR ( 20 ) and VARCHAR ( 50 ) Reads all configuration files and combines their option output into a ` ConfigValues ` class . The psql wrapper module has following requirements : Options in the configuration file are written like : `` option\_name value '' where value may be : true , 1 , yes , false , 0 , no Returns an empty list if no prompt is found . Returns prompt text ( `` dbname= > '' or `` dbname= # '' ) if found . # # # # SubquerySelectChecker # # Using pg4n Overall working logic is handled by ` _check_and_act_on_repl_output ` , where it can be seen that queries are checked for every time user presses Return . If ` PsqlParser ` finds an SQL SELECT query , it 's passed to ` SemanticRouter ` for further analysis , and any insightful message returned is saved for later . Once all query results have been printed , and a new prompt ( e.g ` .. = > ` ) is going to be printed next per ` latest_output ` parameter , the wrapper injects the returned message . If results included ` ERROR : ` .. ` ^ ` , it is sent to syntax error analysis , and any returned message will be injected immediately . ! [ Program architecture sketch ] ( ./architecture.jpg ) # # Semantic errors detected ` psql ` is the psql REPL log to be inspected . ` PsqlWrapper ` has a ` hook_syntax_f ` function parameter ( of type ` str - > str ` ) , which is called with ` PsqlParser.parse_syntax_error ` -produced string , ideally `` ERROR : ... ^ '' , which , to our understanding , will always include the whole result , and also the SQL query itself ( as caret will point to it ) , so it does not have to be parsed separately . A syntax error analysis component should then return a message string , and it will be displayed in exactly the same way as semantic error strings . # # # # EqWildcardChecker Binary files a/docs/architecture.jpg and /dev/null differ Parse for an empty prompt , usually to detect when a query evaluation has ended . # # # ` Wrapper ( db_name : str , hook_f : Callable [ str , str ] , parser : PsqlParser ) ` Returns a warning message if something was found , otherwise None . Returns warning message if there no column SELECTed in a subquery is # # # # SumDistinctChecker # # # # ConfigValues Parses a configuration file . introduced in latter files overriding the previous value . The configuration files are read in order from : /etc/pg4n.conf then from $ XDG\_CONFIG\_HOME/pg4n.conf , or if $ XDG\_CONFIG\_HOME is not set , from Most of the semantic analysis modules have been implemented by parsing the SQL with ` sqlglot ` . Only few of the Checker classes use the query evaluation plan ( QEP ) . program-architecture maintenance-plan checking if given string has a new prompt ( e.g ` = > ` ) ( ` output_has_new_prompt ` ) # # # # ConfigParser # # Installing pg4n ` hook_f ` is the function that the wrapper sends prettified user input & program output to , and from where it gets its helpful messages to inject before next prompt . To our knowledge , there are no interdependencies with the parser functions , so they should be able to be extended as needed , and new ones added . By default all warnings are enabled . Warnings can be disabled by warning type ( which can be found from every warning message 's end ) e.g . parsing ` psql -- version ` output for version number ( ` parse_psql_version ` ) Constructor is the only currently required interface . # # Backend should never give false positives , only false negatives . exposes that information via its query execution plan . Returns warning message if there exists ORDER BY in a subquery , ` pip install pg4n ` itself detects the inconsistent expression in its query optimizer and wild card character ( the ' % ' character ) , otherwise None . ` CmpDomains false ` Semantic error modules are expected to produce false negatives . Parse for the content between two prompts . Returns an empty list if there is no statement or there was an error . # # # QEPParser DISTINCT in SUM and AVG ( Error 33 per Brass and Goldberg , 2005 ) ( ` SumDistinctChecker ` ) parsing syntax errors ( ` ERROR : ` .. ` ^ ` ) ( ` parse_syntax_error ` ) ` pip install -- upgrade pg4n ` Transforms sql string into a syntax tree . # # PsqlWrapper # # # # SubqueryOrderByChecker # # # Implementing semantic analysis modules # Maintaining pg4n # # # # CmpDomainChecker not used in that subquery of its own columns , otherwise returns None . Returns warning message if there exists HAVING without a GROUP BY , otherwise None . Runs SQLParser , QEPParser and semantic error analysis modules ( as configured ) against given SQL query string . ` pexpect ` does not seem to handle all terminal traffic . ` pyte ` and user terminal occasionally disagree on contents when user uses ctrl-R to fetch past queries , which prevents screenscraping SQL query properly . ` pyte ` also disagrees on display contents when exiting a separate query results screen , but this has no impact on ` pg4n ` performance . # # # PsqlParser interfaces # # # PsqlConnInfo # # # Thoughts on syntax error analysis ORDER BY in a subquery ( ` SubqueryOrderByChecker ` ) checking for non-obvious Return presses ( ` output_has_magical_return ` ) # # # ` parse_first_found_stmt ( psql : str ) - > List [ str ] ` ` db_name ` is name of the database psql needs to access Inconsistent expression is some expression that is never true . Returns warning message if implied expression is detected , otherwise None . # # # # ImpliedExpressionChecker # # Frontend parsing a new prompt and everything that precedes it in a string , to allow easy message injection ( ` parse_new_prompt_and_rest ` ) This check gives misses some situations with redundant ORDER BY but","['docs/architecture.jpg', 'docs/architecture.md', 'docs/index.rst', 'docs/interfaces.md', 'docs/maintenance-plan.md', 'docs/pg4n.md', 'docs/program-architecture.md']",2022-09-29 09:58:46+00:00,2022-11-10 10:37:40+00:00,2022-12-16 18:54:08+02:00
27,34b89977c8da671ed279950b4e5c98e364b2ee0a,1.0216492228209972e-05,1,Related to # 5,"Create FSM for interpreting control codes induced by e.g . up-/down-arrows , ctrl-R and backspace",Merge pull request # 48 from Project-C-SQL/feat/vt100decode,": returns : output with injected semantic error messages . psql.ofilter ( case_query_1 ) # Turn on memoization optimization control_codes : str = '\x1b ' + '\x08 ' `` `` '' Test PsqlParser . '' '' '' : param prompt : is where the message is injected . A fresh prompt is \ case_psql_start = \ wcwidth = `` * '' to and from which semantic error messages are received in return . analysis . It is also what the helpful message will be injected to . intercepted output . '' '' '' before the new prompt . from functools import reduce python-versions = `` * '' ( CaselessLiteral ( `` > - '' ) | CaselessLiteral ( `` # - '' ) ) + \ def test_parse_magical_return ( ) : content-hash = `` d36a59fb4927b0ae9d456fc7784468fd6eb6654450352279e7cdf1cfbe1e4441 '' `` `` '' Start psql process and then start feeding hook function with \ if self.debug : Expected to be deprecated when detecting multiple statements is to 2 cells . return results if parsed_psql_stmt : description = `` Simple VTXXX-compatible terminal emulator . '' lambda x : `` Test '' , bytes.decode ( latest_output ) ) ! = [ ] : # there is new prompt psqlparser.PsqlParser ( ) ) # prompt is more complicated and has newlines in it : # optimization : do not spend time parsing if there is no message : self.db_name : bytes = db_name_parameter [ `` \x1b [ ? 2004l\r order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n '' , `` \x1b [ ? 2004hpgdb= # `` ] CaselessLiteral ( `` - > '' ) | CaselessLiteral ( `` - # '' ) # cheaper and easier to reverse & start from the end optional = false stmt_res = match_last_stmt.parse_string ( psql_rev ) # TODO : strip `` - > '' / '' - # '' from string to allow multiline queries try : `` utf-8 '' ) ( self.cols , self.rows ) = get_terminal_size ( ) reduce ( lambda x , y : x + y [ : :-1 ] , results , `` '' ) : param psql : screenscraped psql string return new_output `` `` '' Parse for an empty prompt and everything preceding it \ { file = `` pyte-0.8.1-py3-none-any.whl '' , hash = `` sha256 : d760ea9a7d455d179d9d7a4288fac3d231190b5226715f1fe8c62547bed9b9aa '' } , from typing import List if self.parser.parse_magical_return ( match_rev_sql_stmt_start : ParserElement = \ def _replace_prompt ( self , prompt : bytes ) : self.input_log = self.input_log + input def parse_last_found_stmt ( self , psql : str ) - > str : [ `` '' , `` \x1b [ ? 2004hpgdb= > `` ] Literal ( `` > = '' ) | Literal ( `` # = '' ) # class debug ( Literal ( `` > = '' ) | Literal ( `` # = '' ) ) + \ # TODO : For some reason Literal ( `` > = '' ) does not provide a match , and if it was run successfully . If so , add a fitting message in \ to pick up relevant SQL statements for the hook function . '' '' '' match_rev_prompt_end : ParserElement = \ match_query_error : ParserElement = \ def _user_hit_return ( self , output : bytes ) - > bool : prompt_res = match_rev_prompt_end.parse_string ( psql_rev ) : param hook_f : is a callback to which scraped SQL queries are passed \ def __init__ ( self , db_name_parameter : bytes , `` `` '' User input filter function for pexpect.interact : not used . self.output_log = b '' results = [ stmt_res_list [ length - 1 ] , # b ' order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\r\nTest\r\n\r\n\x1b [ ? 2004hpgdb= # ' except ParseException as e : Only one ( static ) class instance is intended for use in program . g.write ( str ( new_output ) + '\n ' ) if self.debug : the output_log will be examined if an interesting statement was run , \ ] analyze : Callable [ str , str ] ParseException , ParseResults , ParserElement , StringEnd , Word , ZeroOrMore , \ if self.debug : # case_query_3 = \ # fresh prompt : `` `` '' Forward output to ` check_and_act_on_repl_output ( ) ` and feed \ assert p.parse_new_prompt_and_rest ( case_mixed_results ) == \ `` `` '' Inject saved semantic error message into given prompt . return results printable.translate ( str.maketrans ( `` '' , `` '' , stmt_end ) ) + control_codes ParserElement.setDefaultWhitespaceChars ( `` ) b'\x08\r\n ' def parse_magical_return ( self , psql : str ) - > List [ str ] : input_log : bytes = b '' return output # `` \r\n\x1b [ ? 2004l\r '' , `` \r\n\r\r\n '' and `` \x08\r\n '' . # BUG : control codes are not handled . # 27 case_query_1 = \ self.fout.write ( sql_stmt + '\n ' ) f = open ( `` pyte.screen '' , `` w '' ) output log if substitute output is returned and replace output \ self.match_rev_magical_returns.parse_string ( psql_rev ) if output [ 0:2 ] == b'\r\n ' : results = [ res_list [ 3 ] [ : :-1 ] , ... + self.match_sql_stmt_start + self.match_sql_stmt + \ if self.pg4n_message ! = `` '' \ case_long_return = \ `` `` '' Forward output to check_and_act_on_repl_output ( ) and flush \ `` \x1b [ ? 2004hpgdb= > `` f.close ( ) # then reverse the matched string . | Literal ( `` \x08\r\n '' [ : :-1 ] ) tok_rev_prompt : ParserElement = \ assert p.parse_new_prompt ( case_trivial ) == \ return bytes ( split_prompt [ 0 ] + `` \r\n '' # TODO : test case for multiline - > queries match_rev_prompt_and_then_rest : ParserElement = \ self.output_log = self.output_log + output self.pg4n_message = self.analyze ( parsed_sql_query ) # psql.ofilter ( b'\x08\x08\x08\x08\x08\x08 ' ) return new_output # Fix it by matching rev_stmt_start also against rev_prompt # assert psql.ofilter ( case_query_3_prompt ) == \ | Literal ( `` \r\n\r\r\n '' [ : :-1 ] ) \ else : res_list = prompt_res.as_list ( ) : param input : user input characters . assert p.parse_last_found_stmt ( case_select_then_select ) == \ # ANSI escape codes ( \x1b [ ) used by psql : `` `` '' Parse for last SQL query statement in a string . ( CaselessLiteral ( `` > = '' ) | CaselessLiteral ( `` # = '' ) ) + \ `` \r\x1b [ 16Ppgdb= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_tot\x08\r\n\x1b [ ? 2004l\r '' def replace_prompt ( self , new_prompt_msg : str , # b ) amidst a return statement version = `` 0.8.1 '' self.fout.write ( str ( new_output ) + '\n ' ) error_res : ParseResults = None : returns : unchanged input . # complicated case : user has ctrl-R 'd , copy-pasted command or something , Char ( '\n ' ) + Word ( prompt_chars ) + \ content-hash = `` be246bc88534ece065517f51ef31ec3cb98c4e31132da335493f7355474152d8 '' category = `` main '' # possibly provide a message to be included in next new prompt . printable.translate ( str.maketrans ( `` '' , `` '' , stmt_end ) ) return latest_output f.write ( '\n'.join ( from functools import reduce # psql REPL has outputted a multiline chunk that may case_select_then_select = \ prompt_res = self.match_prompt.parse_string ( psql ) split_prompt [ 1 ] , print ( e.explain ( ) ) # input does not trigger parsing ( Return is always at least 2 length ) from .. import psqlparser line.rstrip ( ) for line in self.pyte_screen.display ) ) def check_and_act_on_repl_output ( self , latest_output : bytes , ParseException , ParseResults , ParserElement , SkipTo , Word , \ bytes.decode ( latest_output ) ) ) > 0 helpful_message : str = \ case_query_2 = \ # simple query with single arrow-up to query psql_log is only needed for analysis . return False psql_log : bytes ) - > bytes : psql.ofilter ( b'\r ( reverse-i-search ) ` \ ' : ' ) tok_stmt_end + ... + match_rev_sql_stmt_start db_name : bytes = b '' results = [ ] fresh_prompt_1 = \ results : List [ str ] = [ ] # b'SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; ' `` `` '' User input filter function for pexpect.interact : not used . '' '' '' parser : PsqlParser assert p.parse_new_prompt ( case_mixed_results ) == \ b'\r\n ' psql.ofilter ( b '' \x08\x08\x08t ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_to\x1b [ 7mt\x1b [ 27mal_eur = 100 ; \x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08 '' ) [ [ package ] ] def check_and_act_on_repl_output ( self , latest_output : bytes ) - > bytes : Test PsqlWrapper , and secondarily PsqlParser . `` `` '' Detect if psql has run a statement and is asking for \ Uses pexpect in combination with pyte for interfacing and screen-scraping Word ( prompt_chars ) + Char ( '\n ' ) self.pyte_screen_output_sink.feed ( bytes.decode ( new_output ) ) self.parser.parse_new_prompt_and_rest ( : returns : a two-part list with everything before the prompt \ results = magical_return_res.as_list ( ) prompt [ prompt_line_begins_at : ] `` `` '' Build wrapper for selected database . self.db_name = db_name_parameter pyte = [ return psql return_press_2 = \ # If we have a semantic error message waiting and there is a fresh or if a fresh prompt has come in and we can show them a helpful \ # AND-clause will stop executing after first False . magical_return_res = \ ] bytes.decode ( output , `` utf-8 '' ) ) ! = [ ] : self.pg4n_message + `` \r\n\r\n '' # ctrl-R to previous query . Query includes a return press near end . self.match_sql_stmt_end def parse_new_prompt ( self , psql : str ) - > List [ str ] : # > prompt : bytes ) : # for optimization reasons , check output only if len ( ) > 1 , so keyboard # but works fine without the whitespace .. Word ( prompt_chars ) + ( CaselessLiteral ( `` = > '' ) | CaselessLiteral ( `` = # '' ) ) Otherwise has newline text . if self._user_hit_return ( latest_output ) : self.parser = parser b'\r\n ' + b'Test ' + b'\r\n\r\n ' + b'\x1b [ ? 2004hpgdb= # ' # User hit Return : parse for potential SQL query , analyze , and psql.ofilter ( case_query_2 ) output_log : bytes = b '' assert psql.ofilter ( case_query_2_prompt ) == \ psql.start ( ) : param psql : Raw console output that includes terminal control codes . # in live scenarios most of the time , but I can not reproduce it with this new_prompt_msg.encode ( `` utf-8 '' ) + b'\r\n ' + \ `` \x1b [ ? 2004l\r order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004hpgdb= # `` from pyte import Stream , Screen if magical_return_res : b'\r\n\x1b [ ? 2004l\r ' # case_select_then_insert = `` psql ( 14.5 ) \nType \ '' help\ '' for help.\n\npgdb= # SELECT * FROM orders ; \npgdb= # INSERT INTO orders VALUES ( 6 , 6 , 6 ) ; '' # saved stream of characters . length : int = len ( stmt_res_list ) psql.ofilter ( return_press_1 ) from typing import Callable , List ParserElement.enablePackrat ( None ) # memoization optimization # ? 2004 are # BUG ( ? ) : Assumes only single statement query # m SGR ( set graphics mode ) : param output : output seen on terminal screen . # psql.ofilter ( b'\x08\x08 ' ) # and the \r\n is somewhere in midst of output .. return_press_3 = \ # reverse given string , match reversed tokens , pick first match , `` SELECT * FROM orders ; '' if parsed_sql_query ! = `` '' : # pyte.Screen , pyte.Stream `` `` '' # ? 1h cursor ? match_stmt : ParserElement = \ f.write ( str ( e.explain ( ) ) + `` \n '' ) b ' order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n ' + b'\r\n ' + b'Test ' + b'\r\n\r\n ' + b'\x1b [ ? 2004hpgdb= # ' latest_output is what 's being changed and returned in new form . match_rev_magical_returns : ParserElement = \ newline_pos : int = prompt.rfind ( b'\n ' ) from shutil import get_terminal_size if error_res : name = `` wcwidth '' # assert p.parse_last_found_stmt ( case_select_then_insert ) == \ # psql.ofilter ( case_query_3 ) `` `` '' Parse for weird Return presses . self.parser.parse_last_found_stmt ( screen ) def test_parse_new_prompt_and_rest ( ) : `` `` '' Check if user has hit Return so we can start analyzing , \ # = return True stmt_res_list [ length - 3 ] ] # reverse order # `` '' psql_rev : str = psql [ : :-1 ] implemented . ZeroOrMore ( Char ( `` \n '' ) | Char ( `` \r '' ) ) + self.match_whole_rev_sql_stmt `` `` '' Check if user hit return . self.analyze = hook_f return prompt [ : prompt_line_begins_at - 1 ] + \ Word ( self.prompt_chars ) + Literal ( `` ? [ \x1b '' ) + \ # magic strings related to solely to ctrl-R use are # K clear part of the line def parse_for_new_prompt ( self , psql : str ) - > List [ str ] : output to pyte screen for future screen-scraping . f.close ( ) ( CaselessLiteral ( `` - > '' ) | CaselessLiteral ( `` - # '' ) ) from typing import Callable , List , TextIO `` psql ( 14.5 ) \nType \ '' help\ '' for help.\n\npgdb= # SELECT * FROM orders ; '' parsed_sql_query : str = \ psql : psqlwrapper.PsqlWrapper = new_psqlwrapper ( ) assert p.parse_new_prompt_and_rest ( case_trivial ) == \ ParserElement.enablePackrat ( None ) # fresh prompt in this case : assert p.parse_magical_return ( case_long_return ) == \ error_res = match_query_error.parse_string ( psql ) new_output : bytes = self.check_and_act_on_repl_output ( output , def __init__ ( self , db_name_parameter : bytes , new_output : bytes = self.check_and_act_on_repl_output ( output ) # shutil.get_terminal_size ( ) # Something weird going this test case . Pyte understands this case right SkipTo ( self.match_error ) if prompt_res : wrap = psqlwrapper.PsqlWrapper ( sys.argv [ 1 ] .encode ( `` utf-8 '' ) , # prompt : dimensions= ( 48 , 160 ) ) return self.replace_prompt ( helpful_message , [ ' # = ' ] . : returns : an empty list if no presses are found . \ return_press_1 = \ if there_is_new_prompt : stmt_res_list [ length - 2 ] , self.pyte_screen_output_sink : Stream = Stream ( self.pyte_screen ) : returns : a prompt with injected message . [ `` # = '' ] bytes.decode ( psql_log + latest_output ) ) Returns an empty list if none found . res_list [ 2 ] [ : :-1 ] if new_output ! = b '' : # default whitespace rules complicate things needlessly , remove them : parsed_psql_stmt : List [ str ] = \ stmt_res = match_stmt.parse_string ( psql ) `` psql ( 14.5 ) \nType \ '' help\ '' for help.\n\npgdb= # SELECT * FROM orders ; \npgdb= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; '' b'\r\x1b [ 16Ppgdb= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_tot\x08\r\n\x1b [ ? 2004l\r ' # extra whitespace : psql.ofilter ( case_psql_start ) `` `` '' : returns : if user has indeed hit return . latest_output ) magical_return_res : ParseResults = None def parse_new_prompt_and_rest ( self , psql : str ) - > List [ str ] : ( CaselessLiteral ( `` = > '' ) | CaselessLiteral ( `` = # '' ) ) f = open ( `` psqlparser.log '' , `` a '' ) dimensions= ( self.rows , self.cols ) ) # rev means reversed , these are for performance reasons . sql_stmt : str = reduce ( lambda x , y : x + y , parsed_psql_stmt ) def test_parse_last_found_stmt ( ) : to pick up relevant SQL statements for the hook function . return reversed_flattened_res split_prompt : List [ str ] = \ Literal ( `` \r\n\x1b [ ? 2004l\r '' [ : :-1 ] ) \ # ? 1l escapes ( h = high , l = low ) version = `` 0.2.5 '' `` `` '' Parse for an empty prompt , to detect when a query \ # current unfixed bug case , needs to be fixed after mid-presentations : self.parser.parse_first_found_stmt ( # trivial case . # b'\x1b [ ? 2004hpgdb= > ' if self.debug : if self.debug : # psql.ofilter ( return_press_1 ) return latest_output prompt_res = match_rev_prompt_and_then_rest.parse_string ( psql_rev ) def start ( self ) : # a ) start from previous prompt CaselessLiteral ( `` TCELES '' ) [ `` > = '' ] assert psql.ofilter ( fresh_prompt_1 ) == \ def test_ofilter ( ) : `` `` '' Parse for the content between two prompts . Returns an empty \ from typing import List , TextIO if newline_pos < 0 : line and then the prompt , to allow easy message injection . wcwidth = [ from .. import psqlwrapper case_trivial = \ match_last_stmt : ParserElement = \ description = `` Measures the displayed width of unicode strings in a terminal '' screen : str = '\n'.join ( def new_psqlwrapper ( ) : `` `` '' bytes.decode ( prompt , `` utf-8 '' ) ) self.fout.write ( str ( output ) + '\n ' ) # trivial case : psql = psqlwrapper.PsqlWrapper ( sys.argv [ 1 ] .encode ( `` utf-8 '' ) , : param db_name_parameter : is name of database we are connecting to . `` SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; '' prompt_res : ParseResults = None : param latest_output : is used for Return press and fresh prompt \ self.pg4n_message = `` '' new_output : bytes = self._replace_prompt ( latest_output ) self.fout = open ( 'wrapper.log ' , ' w ' ) `` `` '' Fit the new message in the right place , \ with it accordingly . '' '' '' message . match_whole_rev_sql_stmt : ParserElement = \ self.pyte_screen : Screen = Screen ( self.cols , self.rows ) pass self.analyze ( sql_stmt ) psql = psqlwrapper.PsqlWrapper ( `` '' , `` `` '' Parse for an empty prompt , usually to detect when a query \ g.close ( ) res_list [ 0 ] [ : :-1 ] stmt_res : ParseResults = None self.parser : PsqlParser = parser tok_rev_prompt_linebreak : ParserElement = \ # ? 1049 these from pyparsing import CaselessLiteral , Char , Literal , MatchFirst , \ list if there is no statement or there was an error . pyte = `` ^0.8.1 '' `` `` '' Interface with psql and capture all input and output . '' '' '' return new_prompt_msg.encode ( `` utf-8 '' ) + b'\r\n ' + prompt b'SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; ' `` `` '' Interface with psql and capture all input and output . just on the previous line before new prompt . '' '' '' stmt_res : ParseResults = None # feed query to hook function and save resulting message { file = `` wcwidth-0.2.5-py2.py3-none-any.whl '' , hash = `` sha256 : beb4802a9cebb9144e99086eff703a642a13d6a0052920003a230f3294bbe784 '' } , case_mixed_results = \ ... + StringEnd ( ) expected . # Analysis is always done when user presses Return p = psqlparser.PsqlParser ( ) self.analyze : Callable [ [ str ] , str ] = hook_f psql = new_psqlwrapper ( ) case_query_2_prompt = \ return new_output [ package.dependencies ] psql_rev = psql [ : :-1 ] # slicing is fastest operation for reversing `` `` '' Start wrapper on selected database . '' '' '' self.output_log ) # and resulting message is saved until when new prompt comes in hook_f : Callable [ str , str ] , parser : PsqlParser ) : { file = `` pyte-0.8.1.tar.gz '' , hash = `` sha256 : b9bfd1b781759e7572a6e553c010cc93eef58a19d8d1590446d84c19b1b097b0 '' } , hook_f : Callable [ [ str ] , str ] , parser : PsqlParser ) : return b '' self.fout = open ( 'psqlparser.log ' , ' w ' ) self.pg4n_message : str = `` '' from pyparsing import CaselessLiteral , Char , Literal , MatchFirst , OneOrMore , \ # psql.ofilter ( b'\x08\x08\x08\x08 ' ) res_list [ 1 ] [ : :-1 ] fout : TextIO g = open ( `` psqlwrapper.log '' , `` a '' ) : param output : is raw console output to be checked for return press . a new statement ( `` = > `` prompt ) . : returns : parsed SQL query as plain string . # we assume only situation with \r\n at start of name = `` pyte '' # line is when user has pressed enter and self.parser.parse_new_prompt ( # BUG : Will match until previous SELECT query , if newest is e.g INSERT def test_parse_new_prompt ( ) : reversed_flattened_res : str = \ line.rstrip ( ) for line in self.pyte_screen.display ) b'\x1b [ ? 2004hpgdb= # ' : param parser : A parser that implements the required parsing functions . results = [ stmt_res_list [ 1 ] , stmt_res_list [ 2 ] , stmt_res_list [ 3 ] ] # print ( psql.pyte_screen.display ) [ `` \rl4002 ? [ \x1b\n\r '' ] b ' order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004hpgdb= # ' # Arrow-up to previous query , alt-B until 'orders WHERE ' and remove the b'psql ( 14.5 ) \r\nType `` help '' for help.\r\n\r\n\x1b [ ? 2004hpgdb= # ' Entering a statement will always lead to a new prompt , so now \ # psql.ofilter ( b'\x08\x1b [ 1P ' ) if len ( latest_output ) < = 1 : assert p.parse_last_found_stmt ( case_trivial ) == \ # case_query_3_prompt = b ' order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004hpgdb= # ' there_is_new_prompt : bool = len ( self.parser.parse_for_new_prompt ( prompt_line_begins_at : int = prompt.rfind ( b'\x1b ' ) : returns : an empty list if no prompt found . Otherwise has [ ' > = ' ] or \ { file = `` wcwidth-0.2.5.tar.gz '' , hash = `` sha256 : c4d647b99872929fdb7bdcaa4fbe7f01413ed3d98077df798530e5b04f116c83 '' } , def parse_first_found_stmt ( self , psql : str ) - > List [ str ] :","['poetry.lock', 'pyproject.toml', 'src/pg4n/main.py', 'src/pg4n/psqlparser.py', 'src/pg4n/psqlwrapper.py', 'src/pg4n/test/test_psqlparser.py', 'src/pg4n/test/test_psqlwrapper.py']",2022-10-07 08:29:54+00:00,2022-11-06 14:07:53+00:00,2022-11-06 16:07:52+02:00
33,672575a8e3f414ce9ffa1f47b1e18b13d13fb9eb,1.1958014511037618e-05,1,Allow a visitor ( ? ) pattern for passing custom functions to examine tree structure for semantic analysis,Extend QEPAnalysis interface for easier analysis,Merge pull request # 44 from Project-C-SQL/feat/improve-qeps,"assert len ( qep.root.rfindval ( `` Node Type '' , `` Bitmap Heap Scan '' ) ) == 1 return self.find ( pred , recursive=True ) `` `` '' Finds nodes with the given key and value . assert qep.root.findval ( `` Alias '' , `` users '' ) == [ qep.plan ] assert qep.root.findval ( `` Actual Rows '' , 4 ) == [ qep.plan ] self._ref = bool ( conn ) assert qep.root.findval ( `` Actual Rows '' , 2 ) == [ qep.plan ] : param key : the key to search for To install all dependencies and the application , type ` poetry install ` . After installation , if the Python scripts folder is in your PATH , you should be able to invoke ` main.main ( ) ` with ` pg4n ` . : param key : the index of the child node to get qep = parser ( `` select * from comments where id = 1 '' ) password=getenv ( `` PGPASSWORD '' ) , Having PostgreSQL running on port 5432 , do ` poetry run pytest ` ( or , if on port x , just do ` PGPORT=x poetry run pytest ` ) . `` `` '' Test that the QEP find method works as expected . '' '' '' : returns : the child node at the given index `` `` '' Test that the QEP rfind ( recursive find ) method works as expected . '' '' '' return map ( QEPNode , self._node.get ( `` Plans '' , [ ] ) ) list ( chain.from_iterable ( x.find ( pr , True ) for x in iter ( self ) ) ) | -- -- -- -- -- -- | -- -- -- -- -- -- -- - | -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - | return self._node.get ( `` Plans '' , [ ] ) `` `` '' Finds nodes matching the predicate . assert qep.root.findval ( `` Alias '' , `` comments '' ) == [ qep.plan ] | ` PGDBNAME ` | ` test_database ` | Database name . | return self.find ( lambda x : x.get ( key ) == val , recursive ) : param val : the value to search for if recursive : def rfindval ( self , key : str , val : object ) - > list [ node ] : stmt = f '' explain ( format json , analyze , verbose ) { stmt.strip ( ) .rstrip ( ' ; ' ) } ; '' | Variable | Default value | Description | assert len ( qep.root.rfindval ( `` Node Type '' , `` BitmapOr '' ) ) == 2 | ` PGPASSWORD ` | | Password , in case password authentication is used . | qep = parser ( `` select * from stories where id = 1 '' ) assert qep.root.findval ( `` Alias '' , `` stories '' ) == [ qep.plan ] return map ( QEPNode , self._node [ `` Plans '' ] ) : param pr : a function that takes a node and returns True if it matches qep = parser ( `` select * from stories where id = 1 or id = 2 '' ) `` `` '' Get the child node at the given index . '' '' '' def rfind ( self , pred : Callable [ [ node ] , bool ] ) - > list [ node ] : assert qep.root.findval ( `` Relation Name '' , `` stories '' ) == [ qep.plan ] qep = parser ( `` select * from users where id = 1 '' ) | ` PGPORT ` | ` 5432 ` | Port to an active PostgreSQL instance . | this+children To install all dependencies and the application , type ` poetry install ` . After installation , if the Python scripts folder is in your PATH , you should be able to invoke ` main.main ( ) ` with ` pg4n ` . : param node_ : the node to wrap '' '' '' return self.find ( pr ) + \ self._conn.commit ( ) qep = parser ( `` select * from users '' ) | ` PGUSER ` | ` postgres ` | The user that will be used to manage the test database . | recursive=False ) - > list [ node ] : return self._node [ `` Plans '' ] with self._conn.cursor ( ) as cur : `` `` '' Finds nodes with the given key and value , recursively . : param pred : a function that takes a node and returns True if it matches : returns : a list of matching nodes Having PostgreSQL running on port 5432 , do ` poetry run pytest ` . qep = parser ( `` select * from users where id = 1 or id = 2 '' ) return self.findval ( key , val , recursive=True ) `` `` '' Find nodes matching the predicate . '' '' '' qep = parser ( `` select * from comments where id = 1 or id = 2 '' ) # use constraint_exclusion to avoid unnecessary index scans assert len ( qep.root.rfindval ( `` Node Type '' , `` Bitmap Index Scan '' ) ) == 4 def test_qep_find ( parser : qepparser.QEPParser ) : qep = parser ( `` select * from comments '' ) self._ref = not not conn def find ( self , pred : Callable [ [ node ] , bool ] ) - > list [ node ] : For example , if PostgreSQL is on port 5433 , just do ` PGPORT=5433 poetry run pytest ` ( Bash syntax ) . assert qep.root.findval ( `` Node Type '' , `` Seq Scan '' ) == [ qep.plan ] assert qep.root.findval ( `` Actual Rows '' , 1 ) == [ qep.plan ] def test_gep_rfind ( parser : qepparser.QEPParser ) : To get a similar instance as with GitHub Actions workflow : < br > : param recursive : if True , search recursively , otherwise only search `` `` '' Create a new QEPNode . qep = parser ( `` select * from stories '' ) def findval ( self , key : str , val : object , recursive=False ) - > list [ node ] : return list ( filter ( pr , chain ( ( self._node , ) , self.plans ) ) ) `` `` '' Get the child node at the given index . def find ( self , pr : Callable [ [ node ] , bool ] , dbname=getenv ( `` PGDBNAME '' , `` test_database '' ) ) return list ( filter ( pred , self._node [ `` Plans '' ] ) ) You may need to provide environment variables that match your config : from itertools import chain stmt.strip ( ) .rstrip ( ' ; ' ) + `` ; '' password=getenv ( `` PGPASSWORD '' , `` postgres '' ) ) `` `` '' cur.execute ( `` set constraint_exclusion = on ; '' ) stmt = `` explain ( format json , analyze , verbose ) '' + \ | ` PGHOST ` | ` 127.0.0.1 ` | Hostname of the PostgreSQL server . | assert qep.root.findval ( `` Relation Name '' , `` users '' ) == [ qep.plan ] assert qep.root.findval ( `` Node Type '' , `` Index Scan '' ) == [ qep.plan ] assert qep.root.findval ( `` Relation Name '' , `` comments '' ) == [ qep.plan ] To get a similar PostgreSQL instance as with GitHub Actions workflow : < br > `` `` '' Finds nodes matching the predicate , recursively .","['README.md', 'src/pg4n/qepparser.py', 'src/pg4n/test/test_qepparser.py']",2022-10-13 10:05:14+00:00,2022-11-10 10:55:29+00:00,2022-11-05 13:28:47+02:00
37,672575a8e3f414ce9ffa1f47b1e18b13d13fb9eb,1.092564343707636e-05,1,qepparser needs to use SET constraint_exclusion = 'on ' before doing its queries . This makes # 6 trivial search for One-Time Filter 's from the QEP .,constraint_exclusion option for qepparser,Merge pull request # 44 from Project-C-SQL/feat/improve-qeps,"assert len ( qep.root.rfindval ( `` Node Type '' , `` Bitmap Heap Scan '' ) ) == 1 return self.find ( pred , recursive=True ) `` `` '' Finds nodes with the given key and value . assert qep.root.findval ( `` Alias '' , `` users '' ) == [ qep.plan ] assert qep.root.findval ( `` Actual Rows '' , 4 ) == [ qep.plan ] self._ref = bool ( conn ) assert qep.root.findval ( `` Actual Rows '' , 2 ) == [ qep.plan ] : param key : the key to search for To install all dependencies and the application , type ` poetry install ` . After installation , if the Python scripts folder is in your PATH , you should be able to invoke ` main.main ( ) ` with ` pg4n ` . : param key : the index of the child node to get qep = parser ( `` select * from comments where id = 1 '' ) password=getenv ( `` PGPASSWORD '' ) , Having PostgreSQL running on port 5432 , do ` poetry run pytest ` ( or , if on port x , just do ` PGPORT=x poetry run pytest ` ) . `` `` '' Test that the QEP find method works as expected . '' '' '' : returns : the child node at the given index `` `` '' Test that the QEP rfind ( recursive find ) method works as expected . '' '' '' return map ( QEPNode , self._node.get ( `` Plans '' , [ ] ) ) list ( chain.from_iterable ( x.find ( pr , True ) for x in iter ( self ) ) ) | -- -- -- -- -- -- | -- -- -- -- -- -- -- - | -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - | return self._node.get ( `` Plans '' , [ ] ) `` `` '' Finds nodes matching the predicate . assert qep.root.findval ( `` Alias '' , `` comments '' ) == [ qep.plan ] | ` PGDBNAME ` | ` test_database ` | Database name . | return self.find ( lambda x : x.get ( key ) == val , recursive ) : param val : the value to search for if recursive : def rfindval ( self , key : str , val : object ) - > list [ node ] : stmt = f '' explain ( format json , analyze , verbose ) { stmt.strip ( ) .rstrip ( ' ; ' ) } ; '' | Variable | Default value | Description | assert len ( qep.root.rfindval ( `` Node Type '' , `` BitmapOr '' ) ) == 2 | ` PGPASSWORD ` | | Password , in case password authentication is used . | qep = parser ( `` select * from stories where id = 1 '' ) assert qep.root.findval ( `` Alias '' , `` stories '' ) == [ qep.plan ] return map ( QEPNode , self._node [ `` Plans '' ] ) : param pr : a function that takes a node and returns True if it matches qep = parser ( `` select * from stories where id = 1 or id = 2 '' ) `` `` '' Get the child node at the given index . '' '' '' def rfind ( self , pred : Callable [ [ node ] , bool ] ) - > list [ node ] : assert qep.root.findval ( `` Relation Name '' , `` stories '' ) == [ qep.plan ] qep = parser ( `` select * from users where id = 1 '' ) | ` PGPORT ` | ` 5432 ` | Port to an active PostgreSQL instance . | this+children To install all dependencies and the application , type ` poetry install ` . After installation , if the Python scripts folder is in your PATH , you should be able to invoke ` main.main ( ) ` with ` pg4n ` . : param node_ : the node to wrap '' '' '' return self.find ( pr ) + \ self._conn.commit ( ) qep = parser ( `` select * from users '' ) | ` PGUSER ` | ` postgres ` | The user that will be used to manage the test database . | recursive=False ) - > list [ node ] : return self._node [ `` Plans '' ] with self._conn.cursor ( ) as cur : `` `` '' Finds nodes with the given key and value , recursively . : param pred : a function that takes a node and returns True if it matches : returns : a list of matching nodes Having PostgreSQL running on port 5432 , do ` poetry run pytest ` . qep = parser ( `` select * from users where id = 1 or id = 2 '' ) return self.findval ( key , val , recursive=True ) `` `` '' Find nodes matching the predicate . '' '' '' qep = parser ( `` select * from comments where id = 1 or id = 2 '' ) # use constraint_exclusion to avoid unnecessary index scans assert len ( qep.root.rfindval ( `` Node Type '' , `` Bitmap Index Scan '' ) ) == 4 def test_qep_find ( parser : qepparser.QEPParser ) : qep = parser ( `` select * from comments '' ) self._ref = not not conn def find ( self , pred : Callable [ [ node ] , bool ] ) - > list [ node ] : For example , if PostgreSQL is on port 5433 , just do ` PGPORT=5433 poetry run pytest ` ( Bash syntax ) . assert qep.root.findval ( `` Node Type '' , `` Seq Scan '' ) == [ qep.plan ] assert qep.root.findval ( `` Actual Rows '' , 1 ) == [ qep.plan ] def test_gep_rfind ( parser : qepparser.QEPParser ) : To get a similar instance as with GitHub Actions workflow : < br > : param recursive : if True , search recursively , otherwise only search `` `` '' Create a new QEPNode . qep = parser ( `` select * from stories '' ) def findval ( self , key : str , val : object , recursive=False ) - > list [ node ] : return list ( filter ( pr , chain ( ( self._node , ) , self.plans ) ) ) `` `` '' Get the child node at the given index . def find ( self , pr : Callable [ [ node ] , bool ] , dbname=getenv ( `` PGDBNAME '' , `` test_database '' ) ) return list ( filter ( pred , self._node [ `` Plans '' ] ) ) You may need to provide environment variables that match your config : from itertools import chain stmt.strip ( ) .rstrip ( ' ; ' ) + `` ; '' password=getenv ( `` PGPASSWORD '' , `` postgres '' ) ) `` `` '' cur.execute ( `` set constraint_exclusion = on ; '' ) stmt = `` explain ( format json , analyze , verbose ) '' + \ | ` PGHOST ` | ` 127.0.0.1 ` | Hostname of the PostgreSQL server . | assert qep.root.findval ( `` Relation Name '' , `` users '' ) == [ qep.plan ] assert qep.root.findval ( `` Node Type '' , `` Index Scan '' ) == [ qep.plan ] assert qep.root.findval ( `` Relation Name '' , `` comments '' ) == [ qep.plan ] To get a similar PostgreSQL instance as with GitHub Actions workflow : < br > `` `` '' Finds nodes matching the predicate , recursively .","['README.md', 'src/pg4n/qepparser.py', 'src/pg4n/test/test_qepparser.py']",2022-10-25 08:51:21+00:00,2022-11-05 11:28:49+00:00,2022-11-05 13:28:47+02:00
39,4fa9eda88b8e6a94c4e6662a86f87da7bc41d060,1.0416502846055664e-05,1,Find out patterns in QEPs that allow detection of aforementioned errors . Use PostgreSQL documentation and the Telegram/Teams channel for help .,Error analysis for pattern violation errors 28-31,Merge pull request # 59 from Project-C-SQL/feat/implied-expression,"insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 221 , 487.39 , 227 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 13 , 'Marion ' , 'Penelli ' , ' B ' , 'Adaline ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 14 , 586.06 , 181 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 153 , 350.78 , 247 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 5 , 'Callida ' , 'Tomasello ' , ' B ' , 'Abiel ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 50 , 306.71 , 235 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 10 , 414.55 , 234 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 246 , 510.74 , 188 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 78 , 569.4 , 99 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 93 , 452.63 , 115 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 218 , 389.51 , 177 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 166 , 95.01 , 189 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 97 , 313.39 , 241 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 119 , 579.12 , 43 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 176 , 'Marylou ' , 'Guilloton ' , ' C ' , 'Bridget ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 23 , 'Jeanette ' , 'Fincher ' , ' B ' , 'Adriane ' ) ; return postgresql insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 132 , 'Olympe ' , 'Faber ' , ' B ' , 'Barbery ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 233 , 87.21 , 179 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 196 , 'Louisa ' , 'Matasov ' , ' B ' , 'Carmon ' ) ; return None insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 42 , 561.85 , 222 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 78 , 'Matilde ' , 'Froome ' , ' B ' , 'Angelica ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 159 , 281.36 , 198 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 20 , 207.6 , 9 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 216 , 388.15 , 142 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 4 , 144.14 , 157 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 192 , 206.39 , 151 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 24 , 538.88 , 38 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 77 , 'Maegan ' , 'Wheldon ' , ' C ' , 'Angela ' ) ; import pytest insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 82 , 106.39 , 237 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 29 , 'Dawna ' , 'Knipe ' , ' C ' , 'Alanson ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 242 , 356.69 , 244 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 210 , 332.45 , 47 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 63 , 'Gratia ' , 'Moss ' , ' B ' , 'Althea ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 187 , 'Donall ' , 'Casolla ' , ' B ' , 'Calvin ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 32 , 'Aubrie ' , 'Lockitt ' , ' C ' , 'Albert ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 176 , 22.8 , 175 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 245 , 327.9 , 212 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 169 , 'Elsbeth ' , 'Nucciotti ' , ' B ' , 'Bradley ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 37 , 'Talbot ' , 'Keddey ' , ' B ' , 'Aleva ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 237 , 293.23 , 140 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 229 , 89.34 , 147 ) ; len ( qep_analysis_without_constraint_exclusion.root.rfind ( finder ) ) > 0 import copy insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 56 , 'Kaitlin ' , 'Payle ' , ' B ' , 'Allyson ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 44 , 537.56 , 2 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 204 , 212.04 , 203 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 188 , 'Ferguson ' , 'Mackriell ' , ' B ' , 'Cameron ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 122 , 'Myrlene ' , 'Worcs ' , ' B ' , 'Augusta ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 183 , 'Harvey ' , 'Skinn ' , ' B ' , 'Caleb ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 226 , 212.04 , 28 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 201 , 411.07 , 202 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 46 , 362.72 , 240 ) ; SQL_SIMPLE = \ order_id INT insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 242 , 'Brenden ' , 'Simmons ' , ' B ' , 'Clarence ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 52 , 'Gerrilee ' , 'Ackland ' , ' B ' , 'Allan ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 119 , 'Gregg ' , 'Lazenbury ' , ' B ' , 'Aubrey ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 171 , 'Fredrick ' , 'Matuszynski ' , ' C ' , 'Breanna ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 137 , 'Lucilia ' , 'Bentick ' , ' C ' , 'Bartholomew ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 11 , 88.19 , 50 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 162 , 'Jessee ' , 'List ' , ' B ' , 'Billy ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 14 , 'Davon ' , 'Burris ' , ' C ' , 'Addison ' ) ; , order_total_eur DECIMAL ( 6,2 ) NOT NULL insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 32 , 331.93 , 144 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 83 , 'Wolf ' , 'Brenton ' , ' B ' , 'Annette ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 246 , 'Albert ' , 'Heimann ' , ' B ' , 'Cleatus ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 189 , 164.91 , 68 ) ; sql_statement = SQL_CHECK_CONSTRAINT_VIOLATION insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 240 , 384.87 , 107 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 144 , 504.73 , 154 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 127 , 'Rhoda ' , 'Kurton ' , ' C ' , 'Avarilla ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 28 , 'Nanice ' , 'MacMaster ' , ' B ' , 'Alan ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 151 , 221.16 , 212 ) ; sql_statement = SQL_NOT_NULL_CONSTRAINT_VIOLATION insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 148 , 203.36 , 180 ) ; QEPParser ( conn=self.db_connection , constraint_exclusion=False ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 169 , 552.88 , 241 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 57 , 'Vita ' , 'Dunnett ' , ' B ' , 'Allyssa ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 214 , 'Chalmers ' , 'Britton ' , ' C ' , 'Celinda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 70 , 596.2 , 221 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 12 , 'Tiffi ' , 'Riolfo ' , ' C ' , 'Ada ' ) ; WHERE type = ' A ' ; '' '' '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 173 , 'Kristopher ' , 'Mackelworth ' , ' B ' , 'Brenda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 7 , 183.92 , 236 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 219 , 594.84 , 121 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 130 , 'Rora ' , 'Adcock ' , ' C ' , 'Babs ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 162 , 168.92 , 27 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 89 , 556.68 , 74 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 183 , 546.08 , 88 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 118 , 23.96 , 195 ) ; if constraint_exclusion : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 18 , 'Odie ' , 'Rowling ' , ' C ' , 'Adele ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 30 , 'Colin ' , 'Jansie ' , ' C ' , 'Alastair ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 177 , 'Genvieve ' , 'Marthen ' , ' B ' , 'Brittany ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 150 , 439.75 , 18 ) ; import psycopg insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 102 , 'Ricca ' , 'Rupprecht ' , ' B ' , 'Arlene ' ) ; `` One-Time Filter '' : str , insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 227 , 189.25 , 230 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 206 , 226.62 , 228 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 186 , 561.85 , 156 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 1 , 535.36 , 111 ) ; FROM { CUSTOMERS_TABLE_NAME } insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 212 , 179.55 , 180 ) ; parsed_sql , sql_statement , db_connection ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 103 , 14.83 , 183 ) ; def test_check ( sql_parser : SqlParser , db_connection : Connection ) : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 171 , 175.72 , 249 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 128 , 'Jere ' , 'Cometti ' , ' B ' , 'Azariah ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 137 , 417.16 , 215 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 10 , 'Sonnie ' , 'Kelling ' , ' B ' , 'Abram ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 140 , 'Suki ' , 'Flinn ' , ' B ' , 'Bea ' ) ; SELECT * insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 104 , 97.04 , 11 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 115 , 351.68 , 153 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 30 , 435.57 , 105 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 208 , 344.91 , 150 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 239 , 327.06 , 34 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 91 , 'Bobby ' , 'Fortesquieu ' , ' B ' , 'Aquilla ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 121 , 'Clywd ' , 'Stokey ' , ' B ' , 'August ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 28 , 87.44 , 1 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 8 , 424.8 , 244 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 109 , 170.82 , 206 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 181 , 150.37 , 69 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 64 , 'Dyan ' , 'Crosbie ' , ' B ' , 'Alverta ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 194 , 328.76 , 41 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 121 , 132.25 , 50 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 123 , 'Lyon ' , 'Nolleau ' , ' C ' , 'Augustina ' ) ; cur.execute ( `` set constraint_exclusion = on ; '' ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 248 , 321.97 , 195 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 201 , 'Arv ' , 'Spawforth ' , ' B ' , 'Carrie ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 221 , 'Cassondra ' , 'Mattingson ' , ' B ' , 'Chesley ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 96 , 'Tiertza ' , 'Bunford ' , ' C ' , 'Archibald ' ) ; ORDERS_TABLE_NAME = `` implied_expression_test_table_orders '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 202 , 'Sonja ' , 'Pentycross ' , ' B ' , 'Carthaette ' ) ; has_onetime_filter_without_constraint_exclusion = \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 234 , 'Cayla ' , 'Statter ' , ' B ' , 'Christopher ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 146 , 'Dunstan ' , 'Cressey ' , ' B ' , 'Bella ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 240 , 'Britte ' , 'Muge ' , ' B ' , 'Clara ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 156 , 'Allistir ' , 'Frary ' , ' C ' , 'Beth ' ) ; qep_parser_with_constraint_exclusion.parse ( self.sql_statement ) SQL_NO_IMPLIED_EXPRESSION = \ insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 88 , 210.95 , 158 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 117 , 'Marysa ' , 'Wadman ' , ' C ' , 'Asenath ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 133 , 'Clementia ' , 'Fergusson ' , ' B ' , 'Barbie ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 237 , 'Jeramie ' , 'Gallehock ' , ' C ' , 'Cinderella ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 161 , 184.39 , 94 ) ; len ( qep_analysis_with_constraint_exclusion.root.rfind ( finder ) ) > 0 insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 130 , 575.58 , 235 ) ; SqlParser , insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 178 , 'Rogers ' , 'Plose ' , ' B ' , 'Brittney ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 42 , 'Pyotr ' , 'Feldhorn ' , ' C ' , 'Alexis ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 209 , 'Dulcea ' , 'Akister ' , ' C ' , 'Cathleen ' ) ; CREATE TABLE { CUSTOMERS_TABLE_NAME } ( insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 66 , 454.41 , 11 ) ; assert warning_msg ! = None insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 23 , 236.48 , 51 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 41 , 158.78 , 145 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 43 , 133.73 , 196 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 59 , 'Lin ' , 'Race ' , ' B ' , 'Almina ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 182 , 478.47 , 70 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 54 , 591.44 , 145 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 79 , 94.87 , 194 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 128 , 415.86 , 243 ) ; QEPParser , insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 160 , 'Patti ' , 'Louis ' , ' C ' , 'Biddie ' ) ; def finder ( node : QEPNode ) - > bool : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 166 , 'Angelo ' , 'Vanstone ' , ' C ' , 'Boetius ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 98 , 'Elfreda ' , 'Tome ' , ' C ' , 'Ariadne ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 136 , 411.87 , 10 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 157 , 477.53 , 205 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 15 , 47.79 , 248 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 77 , 335.23 , 149 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 57 , 349.14 , 58 ) ; sql_statement = SQL_NO_IMPLIED_EXPRESSION insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 87 , 'Nanette ' , 'McElwee ' , ' B ' , 'Antoinette ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 48 , 'Marve ' , 'Eykel ' , ' C ' , 'Alicia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 61 , 'Blisse ' , 'Dillway ' , ' C ' , 'Alonzo ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 167 , 547.07 , 197 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 45 , 'Seymour ' , 'Mayer ' , ' B ' , 'Alfreda ' ) ; qep_parser_without_constraint_exclusion.parse ( self.sql_statement ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 112 , 38.97 , 239 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 223 , 'Annice ' , 'Haynes ' , ' B ' , 'Chet ' ) ; QEPParser ( conn=self.db_connection , constraint_exclusion=True ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 24 , 'Jacinthe ' , 'Kleeman ' , ' B ' , 'Adrienne ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 62 , 418.98 , 60 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 27 , 137.86 , 21 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 170 , 539.11 , 92 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 67 , 550.21 , 63 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 181 , 'Daria ' , 'Wistance ' , ' C ' , 'Caitlyn ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 26 , 590.52 , 50 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 170 , 'Bard ' , 'Shaw ' , ' C ' , 'Brady ' ) ; self.sql_statement : str = sql_statement ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 45 , 46.05 , 177 ) ; conn : Connection = psycopg.connect ( * * kwargs ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 49 , 376.9 , 89 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 19 , 107.53 , 94 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 92 , 'Raven ' , 'Eilles ' , ' C ' , 'Ara ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 139 , 'Kelsi ' , 'Suddell ' , ' C ' , 'Bazaleel ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 141 , 'Jacinta ' , 'Villiers ' , ' B ' , 'Beatrice ' ) ; class ImpliedExpressionChecker : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 234 , 254.56 , 98 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 48 , 199.52 , 234 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 68 , 73.27 , 189 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 245 , 'Holly ' , 'Roy ' , ' C ' , 'Claudia ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 232 , 330.85 , 204 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 99 , 'Phineas ' , 'Yuryaev ' , ' B ' , 'Arielle ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 114 , 339.9 , 108 ) ; assert checker ! = None insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 142 , 509.25 , 190 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 213 , 'Rubin ' , 'Lunney ' , ' B ' , 'Celeste ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 41 , 'Reilly ' , 'Kennler ' , ' B ' , 'Alexandria ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 76 , 'Ardys ' , 'Currm ' , ' B ' , 'Andriane ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 202 , 99.52 , 171 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 159 , 'Carilyn ' , 'Vinecombe ' , ' B ' , 'Bezaleel ' ) ; DROP TABLE IF EXISTS { ORDERS_TABLE_NAME } ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 75 , 238.65 , 203 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 39 , 42.62 , 95 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 129 , 'Ashla ' , 'De-Ville ' , ' C ' , 'Bab ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 82 , 'Abey ' , 'Darridon ' , ' C ' , 'Anne ' ) ; Returns warning_msg if implied expression is detected , otherwise None . insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 248 , 'Norby ' , 'Biernacki ' , ' C ' , 'Clementine ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 22 , 'Grazia ' , 'Syne ' , ' C ' , 'Adrian ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 153 , 'Alfy ' , 'McCahill ' , ' B ' , 'Bertha ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 214 , 520.52 , 98 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 63 , 542.48 , 52 ) ; customer_id INT insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 17 , 'Carlyle ' , 'Zimek ' , ' B ' , 'Adelbert ' ) ; return SqlParser ( db_connection=postgresql ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 165 , 84.61 , 1 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 142 , 'Elfrieda ' , 'Cleary ' , ' C ' , 'Becca ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 154 , 'Conney ' , 'Riteley ' , ' C ' , 'Bertram ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 180 , 'Leonelle ' , 'Chiommienti ' , ' B ' , 'Caitlin ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 61 , 343.91 , 223 ) ; f '' '' '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 224 , 'Dayle ' , 'Eirwin ' , ' B ' , 'Chick ' ) ; with conn.cursor ( ) as cur : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 190 , 'Kara ' , 'Backs ' , ' B ' , 'Campbell ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 220 , 'Kylen ' , 'Bewicke ' , ' B ' , 'Cheryl ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 113 , 305.06 , 123 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 2 , 'Tomlin ' , 'Nozzolinii ' , ' B ' , 'Abbigail ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 31 , 394.48 , 62 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 141 , 183.27 , 44 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 89 , 'Nickie ' , 'Bloss ' , ' C ' , 'Antonio ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 243 , 209.34 , 31 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 157 , 'Noach ' , 'MacRitchie ' , ' C ' , 'Bethena ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 191 , 'Frankie ' , 'Canny ' , ' B ' , 'Candace ' ) ; from pytest_postgresql import factories Column , , fname VARCHAR ( 50 ) NOT NULL insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 11 , 'Amby ' , 'Ligoe ' , ' C ' , 'Absalom ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 185 , 505.7 , 49 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 250 , 'Langston ' , 'Prosser ' , ' C ' , 'Clifford ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 126 , 'Lilllie ' , 'Annis ' , ' C ' , 'Aurelia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 51 , 'Kennan ' , 'Burstowe ' , ' B ' , 'Alixandra ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 3 , 189.43 , 19 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 163 , 'Gerhardt ' , 'Simcock ' , ' B ' , 'Blanche ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 188 , 495.68 , 39 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 123 , 370.87 , 115 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 74 , 63.02 , 117 ) ; factory = factories.postgresql_proc ( insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 191 , 183.55 , 142 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 116 , 292.86 , 97 ) ; db_connection : Connection ) : checker = ImpliedExpressionChecker ( parsed_sql = sql_parser.parse_one ( sql_statement ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 71 , 'Cynthie ' , 'Rouby ' , ' B ' , 'Anastasia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 47 , 'Tracey ' , 'Sauvan ' , ' B ' , 'Alice ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 129 , 426.3 , 136 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 131 , 255.66 , 127 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 233 , 'Tibold ' , 'Sleigh ' , ' C ' , 'Christoph ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 249 , 'Rhoda ' , 'Leheude ' , ' C ' , 'Cliff ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 146 , 184.13 , 22 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 16 , 330.92 , 130 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 65 , 'Glenna ' , 'Alastair ' , ' C ' , 'Alyssa ' ) ; cur.execute ( insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 225 , 'Egbert ' , 'Vasyunin ' , ' B ' , 'Chloe ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 197 , 'Missie ' , 'Fealty ' , ' C ' , 'Carol ' ) ; from .. sqlparser import SqlParser insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 25 , 83.54 , 79 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 84 , 'Birk ' , 'Malling ' , ' C ' , 'Annie ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 122 , 406.1 , 80 ) ; qep_parser_without_constraint_exclusion = \ with self._conn.cursor ( ) as cur : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 213 , 329.78 , 105 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 86 , 'Lauren ' , 'Tolworth ' , ' B ' , 'Anthony ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 90 , 169.25 , 30 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 103 , 'Ede ' , 'Golden of Ireland ' , ' C ' , 'Armanda ' ) ; CUSTOMERS_TABLE_NAME = `` implied_expression_orderby_test_table_customers '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 37 , 322.11 , 41 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 79 , 'Preston ' , 'Groves ' , ' B ' , 'Angelina ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 179 , 453.95 , 43 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 200 , 592.16 , 137 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 139 , 441.16 , 97 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 124 , 'Penelope ' , 'Quadling ' , ' C ' , 'Augustine ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 209 , 203.86 , 244 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 124 , 552.02 , 191 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 212 , 'Annecorinne ' , 'Soles ' , ' B ' , 'Cedric ' ) ; qep_analysis_with_constraint_exclusion = \ insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 56 , 501.06 , 129 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 90 , 'Forest ' , 'Trim ' , ' B ' , 'Appoline ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 134 , 'Georgetta ' , 'Crossley ' , ' B ' , 'Barnabas ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 168 , 'Melicent ' , 'Cheston ' , ' B ' , 'Bradford ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 227 , 'Jeralee ' , 'Atwill ' , ' C ' , 'Christa ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 152 , 'Towny ' , 'Middell ' , ' B ' , 'Bert ' ) ; def load_database ( * * kwargs ) : def sql_parser ( postgresql : Connection ) : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 62 , 'Seline ' , 'McGray ' , ' B ' , 'Alphinias ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 70 , 'Carmela ' , 'Sedgeworth ' , ' C ' , 'Amos ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 148 , 'Lidia ' , 'Quinane ' , ' C ' , 'Benjamin ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 243 , 'Hannah ' , 'Mattheis ' , ' C ' , 'Clarinda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 241 , 296.03 , 169 ) ; SELECT ( 1 , 2 , 3 ) ; '' '' '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 69 , 266.3 , 39 ) ; ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 238 , 'Gregor ' , 'Crinion ' , ' B ' , 'Cindy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 117 , 23.13 , 46 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 85 , 'Brig ' , 'Triswell ' , ' C ' , 'Anselm ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 109 , 'Marquita ' , 'Impy ' , ' B ' , 'Aron ' ) ; CREATE TABLE { ORDERS_TABLE_NAME } ( insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 132 , 488.95 , 234 ) ; , type CHAR ( 1 ) NOT NULL insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 84 , 396.02 , 111 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 87 , 441.16 , 191 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 229 , 'Melessa ' , 'MacAleese ' , ' C ' , 'Christiana ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 231 , 51.77 , 118 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 19 , 'Daphne ' , 'Bullen ' , ' B ' , 'Adeline ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 134 , 296.72 , 222 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 133 , 499.73 , 235 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 204 , 'Cassy ' , 'Pearcehouse ' , ' C ' , 'Casper ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 17 , 302.31 , 225 ) ; f '' '' '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 195 , 'Dewey ' , 'Bottom ' , ' C ' , 'Carmelo ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 80 , 'Petey ' , 'Colloby ' , ' B ' , 'Ann ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 180 , 452.67 , 234 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 140 , 297.41 , 101 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 228 , 'Rudd ' , 'Ames ' , ' B ' , 'Christian ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 238 , 448.86 , 16 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 172 , 'Pammi ' , 'Codling ' , ' B ' , 'Breeanna ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 199 , 376.5 , 53 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 110 , 'Donall ' , 'Labrenz ' , ' B ' , 'Artelepsa ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 250 , 367.56 , 214 ) ; '' '' '' ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 111 , 'Torey ' , 'Sessuns ' , ' B ' , 'Artemus ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 25 , 'Neely ' , 'Merrydew ' , ' B ' , 'Agatha ' ) ; SQL_NOT_NULL_CONSTRAINT_VIOLATION = \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 244 , 'Katrine ' , 'Janiak ' , ' B ' , 'Clarissa ' ) ; def db_connection ( postgresql : Connection ) : warning_msg = checker.check ( ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 195 , 504.28 , 117 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 131 , 'Ive ' , 'Matches ' , ' B ' , 'Barbara ' ) ; WHERE sname > fname ; '' '' '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 161 , 'Barron ' , 'Dishmon ' , ' B ' , 'Bill ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 12 , 591.72 , 143 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 55 , 'Terrill ' , 'Syde ' , ' B ' , 'Allison ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 187 , 271.52 , 242 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 222 , 416.65 , 59 ) ; from psycopg import Connection insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 100 , 424.83 , 50 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 241 , 'Sigismund ' , 'Mowsdill ' , ' B ' , 'Clare ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 193 , 449.91 , 213 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 210 , 'Pamelina ' , 'Vittery ' , ' C ' , 'Cathy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 178 , 563.08 , 161 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 156 , 130.63 , 188 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 126 , 384.61 , 226 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 106 , 'Merrily ' , 'Coundley ' , ' C ' , 'Arminda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 196 , 259.0 , 244 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 192 , 'Dudley ' , 'Vesco ' , ' B ' , 'Carlotta ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 113 , 'Dania ' , 'Foxton ' , ' C ' , 'Arthusa ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 211 , 399.2 , 138 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 98 , 177.22 , 86 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 247 , 'Dulcie ' , 'Crutchley ' , ' B ' , 'Clement ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 164 , 'Abel ' , 'Bezants ' , ' C ' , 'Bob ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 154 , 291.52 , 54 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 35 , 389.81 , 218 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 164 , 193.39 , 169 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 21 , 'Nady ' , 'Lempertz ' , ' B ' , 'Adolphus ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 244 , 273.35 , 153 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 215 , 'Nollie ' , 'Jemmett ' , ' B ' , 'Charity ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 95 , 'Amandie ' , 'Botham ' , ' B ' , 'Araminta ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 27 , 'Callean ' , 'Werlock ' , ' C ' , 'Aileen ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 172 , 15.3 , 30 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 105 , 'Cary ' , 'Sells ' , ' C ' , 'Armilda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 13 , 503.52 , 216 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 136 , 'Aretha ' , 'Arias ' , ' C ' , 'Bart ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 3 , 'Christen ' , 'Culley ' , ' C ' , 'Abednego ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 135 , 'Janenna ' , 'McCamish ' , ' C ' , 'Barney ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 15 , 'Zachary ' , 'Faloon ' , ' C ' , 'Adela ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 102 , 158.53 , 220 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 71 , 175.29 , 115 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 93 , 'Sashenka ' , 'Fedorski ' , ' C ' , 'Arabella ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 198 , 120.47 , 95 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 152 , 291.54 , 10 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 106 , 236.57 , 4 ) ; with self._conn.cursor ( ) as cur : conn.commit ( ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 92 , 156.72 , 192 ) ; print ( warning_msg ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 76 , 281.92 , 183 ) ; SQL_CHECK_CONSTRAINT_VIOLATION = \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 107 , 'Celisse ' , 'Rubra ' , ' B ' , 'Arminta ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 34 , 'Lorens ' , 'Buzin ' , ' C ' , 'Aldo ' ) ; self.parsed_sql : exp.Expression = parsed_sql self._conn.commit ( ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 116 , 'Annmarie ' , 'Errichelli ' , ' B ' , 'Asaph ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 115 , 'Shirl ' , 'Pilpovic ' , ' C ' , 'Asahel ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 225 , 26.43 , 228 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 46 , 'Mechelle ' , 'Vinick ' , ' B ' , 'Algernon ' ) ; CHECK ( type IN ( ' C ' , ' B ' ) ) -- C = customer , B = business insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 38 , 'Web ' , 'Catterill ' , ' B ' , 'Alex ' ) ; warning_msg = `` Warning : Found impossible comparison due to column/table constraints [ pg4n : :ImpliedExpression ] '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 224 , 293.35 , 186 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 54 , 'Malchy ' , 'Hearty ' , ' B ' , 'Allisandra ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 217 , 'Lucy ' , 'Durtnell ' , ' C ' , 'Charlie ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 94 , 'Halimeda ' , 'Freak ' , ' B ' , 'Arabelle ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 9 , 519.43 , 175 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 230 , 'Cordell ' , 'Bineham ' , ' B ' , 'Christiano ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 75 , 'Erma ' , 'Cranstone ' , ' B ' , 'Andrew ' ) ; DROP TABLE IF EXISTS { CUSTOMERS_TABLE_NAME } ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 184 , 380.46 , 98 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 68 , 'Leisha ' , 'Darlington ' , ' C ' , 'Ambrose ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 219 , 'Adriane ' , 'Ccomini ' , ' B ' , 'Chauncey ' ) ; , sname VARCHAR ( 50 ) NOT NULL insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 59 , 141.8 , 118 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 236 , 'Garnette ' , 'Tabrett ' , ' C ' , 'Cicely ' ) ; , FOREIGN KEY ( customer_id ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 43 , 'Belle ' , 'Barsham ' , ' B ' , 'Alfonse ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 145 , 'Adena ' , 'Wenham ' , ' C ' , 'Belinda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 197 , 529.63 , 46 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 39 , 'Tabbie ' , 'Glison ' , ' B ' , 'Alexander ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 33 , 140.92 , 236 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 29 , 217.18 , 124 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 80 , 17.1 , 21 ) ; if not has_implied_expression : self.db_connection : Connection = db_connection insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 96 , 311.78 , 173 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 185 , 'Tanitansy ' , 'Headington ' , ' C ' , 'Calista ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 120 , 'Corinna ' , 'Pyburn ' , ' B ' , 'Audrey ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 33 , 'Amble ' , 'Jewes ' , ' B ' , 'Alberta ' ) ; , nickname VARCHAR ( 20 ) NOT NULL insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 165 , 'Angele ' , 'Wildbore ' , ' C ' , 'Bobby ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 108 , 'Janene ' , 'Motten ' , ' C ' , 'Arnold ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 107 , 23.63 , 179 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 168 , 137.02 , 109 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 6 , 'Daisey ' , 'Hamill ' , ' B ' , 'Abigail ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 167 , 'Ninnette ' , 'Steere ' , ' C ' , 'Brad ' ) ; has_onetime_filter_with_constraint_exclusion = \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 69 , 'Maryjo ' , 'Pink ' , ' C ' , 'Amelia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 50 , 'Anne-marie ' , 'Mounsie ' , ' B ' , 'Alison ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 151 , 'Prentiss ' , 'Filby ' , ' B ' , 'Berney ' ) ; return node.get ( `` One-Time Filter '' ) ! = None insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 231 , 'Calhoun ' , 'BoHlingolsen ' , ' C ' , 'Christina ' ) ; SELECT customer_id , fname , sname insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 49 , 'Theodosia ' , 'Rosson ' , ' B ' , 'Aline ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 220 , 367.15 , 163 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 99 , 354.37 , 66 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 51 , 244.27 , 119 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 158 , 'Anett ' , 'Hercules ' , ' B ' , 'Beverly ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 26 , 'Jenica ' , 'Martina ' , ' C ' , 'Agnes ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 175 , 161.61 , 58 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 72 , 539.87 , 62 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 203 , 545.33 , 116 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 21 , 471.12 , 179 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 138 , 223.81 , 183 ) ; qep_parser_with_constraint_exclusion = \ insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 40 , 33.89 , 23 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 101 , 'Hamilton ' , 'Pellew ' , ' B ' , 'Arizona ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 88 , 'Sansone ' , 'Copsey ' , ' C ' , 'Antonia ' ) ; from .sqlparser import ( cur.execute ( `` set constraint_exclusion = off ; '' ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 111 , 490.85 , 191 ) ; import sqlglot.expressions as exp insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 232 , 'Maritsa ' , 'Cowpland ' , ' C ' , 'Christine ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 163 , 61.42 , 69 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 247 , 123.55 , 179 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 60 , 'Sibyl ' , 'Thoms ' , ' C ' , 'Almira ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 236 , 485.18 , 167 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 83 , 451.45 , 203 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 193 , 'Brucie ' , 'Coning ' , ' C ' , 'Carlton ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 228 , 542.3 , 42 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 127 , 451.77 , 17 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 120 , 454.18 , 214 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 174 , 'Carolyn ' , 'Quinlan ' , ' C ' , 'Brian ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 199 , 'Matilda ' , 'Malenoir ' , ' C ' , 'Caroline ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 179 , 'Daphne ' , 'Kells ' , ' C ' , 'Broderick ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 9 , 'Lester ' , 'Markus ' , ' C ' , 'Abraham ' ) ; postgresql = factories.postgresql ( `` factory '' ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 143 , 239.98 , 109 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 53 , 592.15 , 207 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 7 , 'Lorin ' , 'Dollimore ' , ' C ' , 'Abijah ' ) ; , customer_id INT NOT NULL insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 55 , 391.93 , 128 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 1 , 'Josi ' , 'Grimsell ' , ' B ' , 'Aaron ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 175 , 'Davy ' , 'Blomefield ' , ' B ' , 'Brianna ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 118 , 'Hermy ' , 'Whieldon ' , ' B ' , 'Ashley ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 44 , 'Buffy ' , ' O '' Cridigan ' , ' B ' , 'Alfred ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 177 , 334.0 , 167 ) ; def check ( self ) - > Optional [ str ] : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 86 , 537.64 , 201 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 85 , 404.96 , 79 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 53 , 'Riva ' , 'Scawen ' , ' C ' , 'Allen ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 249 , 491.05 , 63 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 105 , 107.29 , 12 ) ; from typing import Optional insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 223 , 200.44 , 47 ) ; assert warning_msg == None insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 73 , 144.33 , 52 ) ; , PRIMARY KEY ( customer_id ) from .qepparser import ( insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 74 , 'Giffy ' , 'Cottee ' , ' C ' , 'Andrea ' ) ; , PRIMARY KEY ( order_id ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 207 , 'Elise ' , 'Kamenar ' , ' C ' , 'Caswell ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 155 , 274.14 , 151 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 215 , 515.79 , 96 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 22 , 193.12 , 6 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 150 , 'Agnesse ' , 'Liebmann ' , ' B ' , 'Bernard ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 104 , 'Timofei ' , 'Grene ' , ' B ' , 'Armena ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 160 , 144.6 , 82 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 8 , 'Gasparo ' , 'Bohlje ' , ' C ' , 'Abner ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 60 , 473.05 , 208 ) ; cur.execute ( `` set constraint_exclusion = on ; '' ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 58 , 'Lettie ' , 'Coffin ' , ' B ' , 'Almena ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 125 , 'Leo ' , 'Creaney ' , ' B ' , 'Augustus ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 190 , 401.19 , 88 ) ; `` `` '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 108 , 294.25 , 131 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 110 , 144.28 , 59 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 144 , 'Ange ' , 'Pasterfield ' , ' C ' , 'Bedelia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 138 , 'Ainsley ' , 'Wraighte ' , ' C ' , 'Barticus ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 147 , 180.39 , 2 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 58 , 10.24 , 74 ) ; has_onetime_filter_with_constraint_exclusion and \ qep_analysis_without_constraint_exclusion = \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 203 , 'Rory ' , 'Hallatt ' , ' C ' , 'Casey ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 216 , 'Elsbeth ' , 'MacGaughie ' , ' B ' , 'Charles ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 149 , 340.62 , 215 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 186 , 'Chloette ' , 'Ratt ' , ' B ' , 'Calpurnia ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 174 , 597.34 , 184 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 184 , 'Louise ' , 'Jansey ' , ' C ' , 'California ' ) ; def __init__ ( self , * args , conn=None , constraint_exclusion=True , * * kwargs ) : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 189 , 'Merle ' , 'Erridge ' , ' C ' , 'Camille ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 2 , 409.8 , 217 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 158 , 65.82 , 201 ) ; sql_statement = SQL_SIMPLE else : QEPNode , insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 198 , 'Kellby ' , 'Threlfall ' , ' C ' , 'Carolann ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 101 , 328.66 , 189 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 239 , 'Atalanta ' , 'Girdler ' , ' C ' , 'Claire ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 217 , 302.24 , 189 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 230 , 389.39 , 247 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 143 , 'Sasha ' , 'Eunson ' , ' C ' , 'Beck ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 235 , 230.72 , 168 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 95 , 367.31 , 48 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 36 , 225.6 , 136 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 208 , 'Legra ' , 'Drought ' , ' C ' , 'Catherine ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 100 , 'Gypsy ' , 'Bottrell ' , ' C ' , 'Aristotle ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 206 , 'Ardyth ' , 'Conningham ' , ' B ' , 'Cassidy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 94 , 406.59 , 129 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 194 , 'Corilla ' , 'Aldwinckle ' , ' C ' , 'Carmellia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 81 , 'Sharline ' , 'Rosenwald ' , ' B ' , 'Anna ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 6 , 132.85 , 206 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 235 , 'Justus ' , 'Barthrup ' , ' B ' , 'Christy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 135 , 574.1 , 222 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 205 , 'Orlan ' , 'Kynder ' , ' C ' , 'Cassandra ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 147 , 'Wilmer ' , 'MacWhan ' , ' B ' , 'Benedict ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 47 , 163.79 , 141 ) ; REFERENCES { CUSTOMERS_TABLE_NAME } ( customer_id ) def __init__ ( self , * args , conn=None , * * kwargs ) : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 52 , 81.47 , 212 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 205 , 508.59 , 59 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 5 , 582.52 , 172 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 211 , 'Jobi ' , 'Bails ' , ' B ' , 'Cecilia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 40 , 'Olva ' , 'Leborgne ' , ' C ' , 'Alexandra ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 114 , 'Fara ' , 'Arkil ' , ' B ' , 'Arzada ' ) ; self._conn.commit ( ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 149 , 'Erik ' , 'Cushe ' , ' B ' , 'Benjy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 64 , 534.3 , 108 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 66 , 'Sadella ' , 'Boxhall ' , ' B ' , 'Alzada ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 4 , 'Nancey ' , 'Fawlkes ' , ' C ' , 'Abel ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 125 , 170.66 , 131 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 38 , 366.31 , 59 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 72 , 'Nadiya ' , 'Gingles ' , ' B ' , 'Anderson ' ) ; QEPAnalysis , insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 35 , 'Lainey ' , 'Davidow ' , ' C ' , 'Aldrich ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 226 , 'Emelina ' , 'Ayliff ' , ' B ' , 'Chris ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 145 , 112.51 , 162 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 34 , 64.76 , 13 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 20 , 'Robbi ' , ' O '' Caherny ' , ' B ' , 'Adelphia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 36 , 'Bendite ' , 'Morfett ' , ' B ' , 'Aleksandr ' ) ; def __init__ ( self , parsed_sql : exp.Expression , sql_statement : str , insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 73 , 'Seymour ' , 'Maffioletti ' , ' B ' , 'Andre ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 16 , 'Augustin ' , 'Blaxall ' , ' C ' , 'Adelaide ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 155 , 'Murdock ' , 'Dix ' , ' C ' , 'Bess ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 207 , 205.25 , 199 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 173 , 297.4 , 85 ) ; load= [ load_database ] , insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 18 , 438.38 , 26 ) ; has_implied_expression = \ WHERE sname IS NULL ; '' '' '' from .. implied_expression_checker import ImpliedExpressionChecker insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 65 , 318.64 , 6 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 91 , 331.76 , 115 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 200 , 'Fanni ' , 'Iacopetti ' , ' C ' , 'Carolyn ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 67 , 'Zsazsa ' , 'Bellocht ' , ' C ' , 'Amanda ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 97 , 'Germain ' , 'Haly ' , ' B ' , 'Archilles ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 222 , 'Hazel ' , 'Rushforth ' , ' C ' , 'Chester ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 81 , 490.65 , 41 ) ; return warning_msg insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 218 , 'Raffarty ' , 'Sweeney ' , ' C ' , 'Charlotte ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 182 , 'Sasha ' , 'Stiffkins ' , ' C ' , 'Caldonia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 31 , 'Dario ' , 'Siehard ' , ' C ' , 'Alazama ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 112 , 'Nanci ' , 'Byrd ' , ' C ' , 'Arthur ' ) ; not has_onetime_filter_without_constraint_exclusion","['src/pg4n/implied_expression_checker.py', 'src/pg4n/qepparser.py', 'src/pg4n/test/test_implied_expression_checker.py']",2022-10-26 09:59:00+00:00,2022-11-08 08:09:35+00:00,2022-11-08 10:09:32+02:00
42,67a44d6dcf82358abcf699c347b79c06a6c74dbe,1.0401889994682278e-05,1,Pull request incoming,Improve CI/CD pipeline,Merge pull request # 51 from Project-C-SQL/feat/add-linter,"< /a > { version = `` > =1.11 , < 2 '' , markers = `` python_version < \ '' 3.11\ '' '' } , version = `` 0.7.0 '' { file = `` black-22.10.0-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl '' , hash = `` sha256:14ff67aec0a47c424bc99b71005202045dc09270da44a27848d534600ac64fc7 '' } , description = `` Style preserving TOML library '' colorama = [ `` colorama ( > =0.4.3 ) '' ] { file = `` wrapt-1.14.1-cp36-cp36m-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl '' , hash = `` sha256:21ac0156c4b089b330b7666db40feee30a5d52634cc4560e1905d6529a3897ff '' } , { file = `` astroid-2.12.12-py3-none-any.whl '' , hash = `` sha256:72702205200b2a638358369d90c222d74ebc376787af8fb2f7f2a86f7b5cc85f '' } , description = `` python code static checker '' e '/^ ( [ - ! * ] ) / ! s/^/ # / ' < < < `` $ lintres '' ) { file = `` wrapt-1.14.1-cp38-cp38-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl '' , hash = `` sha256 : ef3f72c9666bba2bab70d2a8b79f2c6d2c1a42a7f7e2b0ec83bb2f9e383950af '' } , path : ~/.local env : python-versions = `` * '' # - run : | # ` virtualenvs-in-project : true ` creates a ` .venv ` in test dir for easy caching { file = `` wrapt-1.14.1-cp39-cp39-win_amd64.whl '' , hash = `` sha256 : dee60e1de1898bde3b238f18340eec6148986da0455d8ba7848d50470a7a32fb '' } , { file = `` wrapt-1.14.1-cp37-cp37m-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl '' , hash = `` sha256 : d77c85fedff92cf788face9bfa3ebaa364448ebb1d765302e9af11bf449ca36d '' } , push : { file = `` wrapt-1.14.1-cp36-cp36m-win_amd64.whl '' , hash = `` sha256 : b014c23646a467558be7da3d6b9fa409b2c567d2110599b7cf9a0c5992b3b471 '' } , { file = `` wrapt-1.14.1-cp38-cp38-win_amd64.whl '' , hash = `` sha256 : d1967f46ea8f2db647c786e78d8cc7e4313dbd1b0aca360592d8027b8508e24d '' } , dmypy = [ `` psutil ( > =4.0 ) '' ] name = `` tomlkit '' services : colorama = { version = `` * '' , markers = `` platform_system == \ '' Windows\ '' '' } description = `` serialize all of python '' { file = `` tomlkit-0.11.6.tar.gz '' , hash = `` sha256:71b952e5721688937fb02cf9d354dbcf0785066149d2855e44531ebdd2b65d73 '' } , mccabe = `` > =0.6 , < 0.8 '' key : pydeps- $ { { hashFiles ( ' * * /poetry.lock ' ) } } { file = `` wrapt-1.14.1-cp39-cp39-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl '' , hash = `` sha256:40e7bc81c9e2b2734ea4bc1aceb8a8f0ceaac7c5299bc5d69e37c44d9081d43b '' } , { file = `` wrapt-1.14.1-cp310-cp310-macosx_10_9_x86_64.whl '' , hash = `` sha256:80bb5c256f1415f747011dc3604b59bc1f91c6e7150bd7db03b19170ee06b320 '' } , python-version : 3.10.7 { file = `` wrapt-1.14.1-cp38-cp38-manylinux_2_17_aarch64.manylinux2014_aarch64.whl '' , hash = `` sha256:642c2e7a804fcf18c222e1060df25fc210b9c58db7c91416fb055897fc27e8cc '' } , name = `` isort '' version = `` 2.5.2 '' optional = false { file = `` wrapt-1.14.1-cp27-cp27m-manylinux1_x86_64.whl '' , hash = `` sha256:5a9a0d155deafd9448baff28c08e150d9b24ff010e899311ddd63c45c2445e28 '' } , version = `` 2.12.12 '' isort = [ path : ~/.local { file = `` wrapt-1.14.1-cp37-cp37m-musllinux_1_1_x86_64.whl '' , hash = `` sha256:2b39d38039a1fdad98c87279b48bc5dce2c0ca0d73483b12cb72aa9609278e8a '' } , { file = `` black-22.10.0-cp310-cp310-win_amd64.whl '' , hash = `` sha256:819dc789f4498ecc91438a7de64427c73b45035e2e3680c92e18795a839ebb66 '' } , name = `` mypy-extensions '' branches : { file = `` wrapt-1.14.1-cp310-cp310-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl '' , hash = `` sha256:2fe803deacd09a233e4762a1adcea5db5d31e6be577a43352936179d14d90069 '' } , `` ` health-interval 10s pylint = [ version = `` 22.10.0 '' touch docs/build/.nojekyll git-config-name : github-actions version = `` 0.982 '' [ Linting ] ( # linting ) } { file = `` wrapt-1.14.1-cp27-cp27m-manylinux2010_i686.whl '' , hash = `` sha256 : ddaea91abf8b0d13443f6dac52e89051a5063c7d014710dcb4d4abb2ff811a59 '' } , lazy-object-proxy = [ health-cmd pg_isready { file = `` black-22.10.0-cp37-cp37m-win_amd64.whl '' , hash = `` sha256:9311e99228ae10023300ecac05be5a296f60d2fd10fff31cf5c1fa4ca4b1988d '' } , health-cmd pg_isready black src -- check & & run : poetry run pytest virtualenvs-create : true { file = `` wrapt-1.14.1-cp35-cp35m-manylinux2010_x86_64.whl '' , hash = `` sha256 : a85d2b46be66a71bedde836d9e41859879cc54a2a04fad1191eb50c2066f6e9d '' } , { file = `` pathspec-0.10.1.tar.gz '' , hash = `` sha256:7ace6161b621d31e7902eb6b5ae148d12cfd23f4a249b9ffb6b9fee12084323d '' } , id : cache-deps id : cache-deps 'navigation_depth ' : 3 , # black { file = `` wrapt-1.14.1-cp37-cp37m-macosx_10_9_x86_64.whl '' , hash = `` sha256:88bd7b6bd70a5b6803c1abf6bca012f7ed963e58c68d76ee20b9d751c74a3248 '' } , content-hash = `` be246bc88534ece065517f51ef31ec3cb98c4e31132da335493f7355474152d8 '' colorama = { version = `` > =0.4.5 '' , markers = `` sys_platform == \ '' win32\ '' '' } pathspec = `` > =0.9.0 '' run : poetry install -- no-interaction -- with ci { file = `` wrapt-1.14.1-cp38-cp38-macosx_10_9_x86_64.whl '' , hash = `` sha256:8c0ce1e99116d5ab21355d8ebe53d9460366704ea38ae4d9f6933188f327b456 '' } , 5432:5432 ] dill = [ [ Imports ] ( # imports ) { file = `` black-22.10.0-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl '' , hash = `` sha256:72ef3925f30e12a184889aac03d77d031056860ccae8a1e519f6cbb742736383 '' } , $ isortres poetry run sphinx-apidoc -q -f -o docs/api src/pg4n ' * /test * ' & & \ < svg height= '' 20 '' xmlns= '' http : //www.w3.org/2000/svg '' viewBox= '' 0 0 16 16 '' width= '' 20 '' > < path fill= '' rgb ( 149 , 157 , 165 ) '' d= '' M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z '' / > < /svg > using : `` composite '' copyright = '2022 , Heikkilä et al . ' 1 . If ` docs/api ` is not up-to-date or does n't exist , run : < br > ` poetry run sphinx-apidoc -f -o docs/api src/pg4n ' * /test * ' ` $ ( grep -cP '^- ( ? ! - ) ' < < < `` $ blackres '' ) \ black = [ tomli = { version = `` > =1.1.0 '' , markers = `` python_version < \ '' 3.11\ '' '' } image : postgres:14.5-alpine { file = `` black-22.10.0-cp311-cp311-win_amd64.whl '' , hash = `` sha256:21199526696b8f09c3997e2b4db8d0b108d801a348414264d2eb8eb2532e540d '' } , touch docs/build/.nojekyll $ ( grep -cP '^- ( ? ! - ) ' < < < `` $ isortres '' ) \ run : poetry install -- no-interaction -- with ci -- no-root services : health-retries 5 { file = `` mypy-0.982-cp38-cp38-musllinux_1_1_x86_64.whl '' , hash = `` sha256 : c6e564f035d25c99fd2b863e13049744d96bd1947e3d3d2f16f5828864506763 '' } , PGPORT : 5432 { file = `` lazy_object_proxy-1.8.0-pp39-pypy39_pp73-any.whl '' , hash = `` sha256 : ce58b2b3734c73e68f0e30e4e725264d4d6be95818ec0a0be4bb6bf9a7e79aa8 '' } , { file = `` wrapt-1.14.1-cp37-cp37m-musllinux_1_1_aarch64.whl '' , hash = `` sha256:7d2872609603cb35ca513d7404a94d6d608fc13211563571117046c9d2bcc3d7 '' } , { file = `` mypy-0.982-cp39-cp39-macosx_10_9_x86_64.whl '' , hash = `` sha256:75838c649290d83a2b83a88288c1eb60fe7a05b36d46cbea9d22efc790002146 '' } , isortres= $ ( isort src -- diff -- profile black ) { file = `` black-22.10.0-1fixedarch-cp37-cp37m-macosx_10_16_x86_64.whl '' , hash = `` sha256:197df8509263b0b8614e1df1756b1dd41be6738eed2ba9e9769f3880c2b9d7b6 '' } , { file = `` lazy_object_proxy-1.8.0-cp37-cp37m-macosx_10_9_x86_64.whl '' , hash = `` sha256:6850e4aeca6d0df35bb06e05c8b934ff7c533734eb51d0ceb2d63696f1e6030c '' } , { file = `` mccabe-0.7.0.tar.gz '' , hash = `` sha256:348e0240c33b60bbdf4e523192ef919f28cb2c3d7d5c7794f74009290f236325 '' } , name = `` platformdirs '' [ $ n ! = 0 ] & & echo $ n $ x blackres= $ ( black src -- diff -q ) wrapt = [ health-interval 10s { file = `` mypy-0.982-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl '' , hash = `` sha256 : eaa97b9ddd1dd9901a22a879491dbb951b5dec75c3b90032e2baa7336777363b '' } , graph = [ `` objgraph ( > =1.7.2 ) '' ] { file = `` wrapt-1.14.1-cp38-cp38-musllinux_1_1_aarch64.whl '' , hash = `` sha256:01c205616a89d09827986bc4e859bcabd64f5a0662a7fe95e0d359424e0e071b '' } , { file = `` wrapt-1.14.1-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl '' , hash = `` sha256:9cca3c2cdadb362116235fdbd411735de4328c61425b0aa9f872fd76d02c4e86 '' } , { file = `` pathspec-0.10.1-py3-none-any.whl '' , hash = `` sha256:46846318467efc4556ccfd27816e004270a9eeeeb4d062ce5e6fc7a87c573f93 '' } , python-versions = `` > =3.7.2 '' [ Running tests ] ( # running-tests ) # poetry run pylint src -- exit-zero { file = `` wrapt-1.14.1-cp39-cp39-musllinux_1_1_i686.whl '' , hash = `` sha256:6a9a25751acb379b466ff6be78a315e2b439d4c94c1e99cb7266d40a537995d3 '' } , python-versions = `` ! =3.0. * , ! =3.1. * , ! =3.2. * , ! =3.3. * , ! =3.4 . * , > =2.7 '' { file = `` lazy_object_proxy-1.8.0-pp37-pypy37_pp73-any.whl '' , hash = `` sha256 : ae032743794fba4d171b5b67310d69176287b5bf82a21f588282406a79498891 '' } , { file = `` black-22.10.0-cp310-cp310-macosx_11_0_arm64.whl '' , hash = `` sha256:2039230db3c6c639bd84efe3292ec7b06e9214a2992cd9beb293d639c6402edb '' } , lazy-object-proxy = `` > =1.4.0 '' # mypy = `` ^0.982 '' { file = `` lazy_object_proxy-1.8.0-cp310-cp310-macosx_10_9_x86_64.whl '' , hash = `` sha256:4fd031589121ad46e293629b39604031d354043bb5cdf83da4e93c2d7f3389fe '' } , { file = `` black-22.10.0-1fixedarch-cp311-cp311-macosx_11_0_x86_64.whl '' , hash = `` sha256:5d8f74030e67087b219b032aa33a919fae8806d49c867846bfacde57f43972ef '' } , echo `` ℹ Tool info : $ blackurl • $ pylinturl • $ mypyurl • $ isorturl '' { file = `` wrapt-1.14.1-cp310-cp310-musllinux_1_1_i686.whl '' , hash = `` sha256:11871514607b15cfeb87c547a49bca19fde402f32e2b1c24a632506c0a756656 '' } , { file = `` lazy_object_proxy-1.8.0-cp311-cp311-win32.whl '' , hash = `` sha256 : e20bfa6db17a39c706d24f82df8352488d2943a3b7ce7d4c22579cb89ca8896e '' } , dill = `` > =0.2 '' This README is meant for developers of the project , and not for end users . For end users , please see the documentation linked above . version = `` 0.10.1 '' uses : actions/setup-python @ v2 jobs : { file = `` mypy-0.982-cp38-cp38-macosx_11_0_arm64.whl '' , hash = `` sha256:6389af3e204975d6658de4fb8ac16f58c14e1bacc6142fee86d1b5b26aa52bda '' } , PGPASSWORD : postgres { file = `` pylint-2.15.5.tar.gz '' , hash = `` sha256:3b120505e5af1d06a5ad76b55d8660d44bf0f2fc3c59c2bdd94e39188ee3a4df '' } , { file = `` wrapt-1.14.1-cp38-cp38-musllinux_1_1_x86_64.whl '' , hash = `` sha256:2cf71233a0ed05ccdabe209c606fe0bac7379fdcf687f39b944420d2a09fdb57 '' } , runs-on : ubuntu-latest < /div > { file = `` black-22.10.0-1fixedarch-cp39-cp39-macosx_11_0_x86_64.whl '' , hash = `` sha256 : e41a86c6c650bcecc6633ee3180d80a025db041a8e2398dcc059b3afa8382cd4 '' } , description = `` A small Python module for determining appropriate platform-specific dirs , e.g . a \ '' user data dir\ '' . '' colors = [ `` colorama ( > =0.4.3 , < 0.5.0 ) '' ] 1 . If ` docs/api ` is not up-to-date or does n't exist , run : < br > ` poetry run sphinx-apidoc -f -o docs/api src/pg4n ' * /test_ * ' ` path : .venv > plugins = [ `` setuptools '' ] { file = `` pylint-2.15.5-py3-none-any.whl '' , hash = `` sha256 : c2108037eb074334d9e874dc3c783752cc03d0796c88c9a9af282d0f161a1004 '' } , ports : { file = `` wrapt-1.14.1-cp310-cp310-musllinux_1_1_aarch64.whl '' , hash = `` sha256:4fcc4649dc762cddacd193e6b55bc02edca674067f5f98166d7713b193932b7f '' } , description = `` The uncompromising code formatter . '' To get a grade that the CI/CD pipeline would give you , you can do ` poetry run scripts/ci-grade.sh ` to run all the checks . The output is possibly long , so pipe it to a file perusal filter such as ` less ` to scroll through it and search for things of concern , e.g. , ` summary ` to see scores . tomlkit = [ { file = `` lazy-object-proxy-1.8.0.tar.gz '' , hash = `` sha256 : c219a00245af0f6fa4e95901ed28044544f50152840c5b6a3e7b2568db34d156 '' } , { file = `` wrapt-1.14.1-cp35-cp35m-win_amd64.whl '' , hash = `` sha256 : b21bb4c09ffabfa0e85e3a6b623e19b80e7acd709b9f91452b8297ace2a8ab00 '' } , health-timeout 5s mypy = [ if : steps.cache-deps.outputs.cache-hit ! = 'true ' { file = `` lazy_object_proxy-1.8.0-cp39-cp39-win_amd64.whl '' , hash = `` sha256 : eac3a9a5ef13b332c059772fd40b4b1c3d45a3a2b05e33a361dee48e54a4dad0 '' } , version = `` 0.11.6 '' on : { file = `` wrapt-1.14.1-cp36-cp36m-musllinux_1_1_aarch64.whl '' , hash = `` sha256:9f3e6f9e05148ff90002b884fbc2a86bd303ae847e472f44ecc06c2cd2fcdb2d '' } , postgres : run : | # pylint POSTGRES_PASSWORD : postgres push_flow : { file = `` mypy-0.982-cp37-cp37m-musllinux_1_1_x86_64.whl '' , hash = `` sha256 : e7aeaa763c7ab86d5b66ff27f68493d672e44c8099af636d433a7f3fa5596d40 '' } , { % extends `` ! footer.html '' % } reports = [ `` lxml '' ] { file = `` wrapt-1.14.1-cp37-cp37m-win32.whl '' , hash = `` sha256:60db23fa423575eeb65ea430cee741acb7c26a1365d103f7b0f6ec412b893853 '' } , < img src= '' { { pathto ( '_static/github-mark.svg ' , 1 ) } } '' loading= '' lazy '' decoding= '' async '' alt= '' GitHub mark '' width= '' 20 '' height= '' 20 '' > on : push { file = `` mypy_extensions-0.4.3.tar.gz '' , hash = `` sha256:2d82818f5bb3e369420cb3c4060a7970edba416647068eb4c5343488a6c604a8 '' } , path : .venv repository-name : Project-C-SQL/Project-C-SQL.github.io content-hash = `` 414b5507791102a29568bebccebc8956b0259d914d547b98cbefa492fde7874f '' { file = `` wrapt-1.14.1-cp38-cp38-musllinux_1_1_i686.whl '' , hash = `` sha256:5a0f54ce2c092aaf439813735584b9537cad479575a09892b8352fea5e988dc0 '' } , # ! /usr/bin/env bash health-retries 5 description = `` An abstract syntax tree for Python with inference support . '' name : Comment PR GITHUB_TOKEN : $ { { secrets.BOT_SECRET } } [ Using docker ] ( # using-docker ) { file = `` wrapt-1.14.1-cp27-cp27m-manylinux2010_x86_64.whl '' , hash = `` sha256:36f582d0c6bc99d5f39cd3ac2a9062e57f3cf606ade29a0a0d6b323462f4dd87 '' } , mypyres= $ ( mypy -- non-interactive -- install-types -- ignore-missing-imports -- strict -- show-error-codes -- show-error-context src 2 > & 1 ) [ [ package ] ] { file = `` mypy-0.982-cp39-cp39-musllinux_1_1_x86_64.whl '' , hash = `` sha256 : a692a8e7d07abe5f4b2dd32d731812a0175626a90a223d4b58f10f458747dd8a '' } , ports : runmypy ( ) { testutils = [ `` gitpython ( > 3 ) '' ] html_theme_options = { ci-flow : run : | ` black ` for formatting always_document_param_types = False key : poetry-1.2.2-0 { file = `` black-22.10.0-cp39-cp39-macosx_11_0_arm64.whl '' , hash = `` sha256:974308c58d057a651d182208a484ce80a26dac0caef2895836a92dd6ebd725e0 '' } , mypy src -- show-error-codes -- show-error-context -- pretty & & version : 1.2.2 pylint = `` ^2.15.4 '' pathspec = [ { file = `` dill-0.3.6.tar.gz '' , hash = `` sha256 : e5db55f3687856d8fbdab002ed78544e1c4559a130302693d839dfe8f93f2373 '' } , poetry run sphinx-build -q -b html docs docs/build & & \ run : poetry install -- no-interaction -- with ci -- no-root [ tool.poetry.group.ci.dependencies ] { file = `` mypy-0.982-cp38-cp38-win_amd64.whl '' , hash = `` sha256 : cebca7fd333f90b61b3ef7f217ff75ce2e287482206ef4a8b18f32b49927b1a2 '' } , # mypy pylint src ' key : pydeps- $ { { hashFiles ( ' * * /poetry.lock ' ) } } requirements-deprecated-finder = [ `` pip-api '' , `` pipreqs '' ] astroid = [ For linting , you need the CI tools : ` poetry install -- with=ci ` . The tools used are : name = `` click '' { file = `` wrapt-1.14.1-cp310-cp310-macosx_11_0_arm64.whl '' , hash = `` sha256:07f7a7d0f388028b2df1d916e94bbb40624c59b48ecc6cbc232546706fac74c2 '' } , health-timeout 5s virtualenvs-in-project : true { file = `` black-22.10.0-cp38-cp38-macosx_11_0_arm64.whl '' , hash = `` sha256 : fba8a281e570adafb79f7755ac8721b6cf1bbf691186a287e990c7929c7692ff '' } , git-config-name : github-actions run : poetry install -- no-interaction -- with ci jobs : { file = `` wrapt-1.14.1-cp27-cp27mu-manylinux2010_i686.whl '' , hash = `` sha256 : ee2b1b1769f6707a8a445162ea16dddf74285c3964f605877a20e38545c3c462 '' } , < /summary > [ PostgreSQL for novices ] ( # postgresql-for-novices ) options : > { file = `` wrapt-1.14.1-cp37-cp37m-musllinux_1_1_i686.whl '' , hash = `` sha256 : ee6acae74a2b91865910eef5e7de37dc6895ad96fa23603d1d27ea69df545015 '' } , runpylint ( ) { { file = `` wrapt-1.14.1-cp35-cp35m-win32.whl '' , hash = `` sha256 : dbcda74c67263139358f4d188ae5faae95c30929281bc6866d00573783c422b7 '' } , { file = `` wrapt-1.14.1-cp35-cp35m-manylinux1_x86_64.whl '' , hash = `` sha256:6b1a564e6cb69922c7fe3a678b9f9a3c54e72b469875aa8018f18b4d1dd1adf3 '' } , [ Notes for developers ] ( # notes-for-developers ) isort = `` ^5.10.1 '' spelling = [ `` pyenchant ( > =3.2 , < 4.0 ) '' ] folder : docs/build { file = `` black-22.10.0-cp37-cp37m-manylinux_2_17_x86_64.manylinux2014_x86_64.whl '' , hash = `` sha256:1e464456d24e23d11fced2bc8c47ef66d471f845c7b7a42f3bd77bf3d1789650 '' } , $ ( grep -cP '^\+ ( ? ! \+ ) ' < < < `` $ isortres '' ) < /summary > [ `` $ lintscore '' = `` '' ] & & lintscore= '' OK '' uses : ./.github/actions/install main { file = `` mypy-0.982-cp39-cp39-macosx_11_0_arm64.whl '' , hash = `` sha256:91781eff1f3f2607519c8b0e8518aad8498af1419e8442d5d0afb108059881fc '' } , virtualenvs-create : true steps : poetry run sphinx-build -q -b html docs docs/build & & \ name = `` mccabe '' virtualenvs-in-project : true uvloop = [ `` uvloop ( > =0.15.2 ) '' ] { file = `` mypy-0.982-cp38-cp38-macosx_10_9_x86_64.whl '' , hash = `` sha256:26ae64555d480ad4b32a267d10cab7aec92ff44de35a7cd95b2b7cb8e64ebe3e '' } , # TODO : generate appropriately scoped access token so a bot can comment lint results typing-extensions = `` > =3.10 '' { file = `` click-8.1.3.tar.gz '' , hash = `` sha256:7682dc8afb30297001674575ea00d1814d808d6a36af415a82bd481d37ba7b8e '' } , uses : JamesIves/github-pages-deploy-action @ v4 click = `` > =8.0.0 '' jupyter = [ `` ipython ( > =7.8.0 ) '' , `` tokenize-rt ( > =3.2.0 ) '' ] { file = `` wrapt-1.14.1-cp310-cp310-musllinux_1_1_x86_64.whl '' , hash = `` sha256:8ad85f7f4e20964db4daadcab70b47ab05c7c1cf2a7c1e51087bfaa83831854c '' } , { file = `` wrapt-1.14.1-cp37-cp37m-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl '' , hash = `` sha256:8d649d616e5c6a678b26d15ece345354f7c2286acd6db868e65fcc5ff7c24a77 '' } , description = `` Module for decorators , wrappers and monkey patching . '' { file = `` lazy_object_proxy-1.8.0-cp39-cp39-win32.whl '' , hash = `` sha256:8f6ce2118a90efa7f62dd38c7dbfffd42f468b180287b748626293bf12ed468f '' } , POSTGRES_PASSWORD : postgres { file = `` wrapt-1.14.1-cp310-cp310-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_17_x86_64.manylinux2014_x86_64.whl '' , hash = `` sha256:257fd78c513e0fb5cdbe058c27a0624c9884e735bbd131935fd49e9fe719d310 '' } , shell : bash { file = `` wrapt-1.14.1-cp37-cp37m-win_amd64.whl '' , hash = `` sha256:709fe01086a55cf79d20f741f39325018f4df051ef39fe921b1ebe780a66184c '' } , { file = `` lazy_object_proxy-1.8.0-cp39-cp39-macosx_10_9_x86_64.whl '' , hash = `` sha256:71d9ae8a82203511a6f60ca5a1b9f8ad201cac0fc75038b2dc5fa519589c9288 '' } , { file = `` click-8.1.3-py3-none-any.whl '' , hash = `` sha256 : bb4d8133cb15a609f44e8213d9b391b0809795062913b383c62be0ee95b1db48 '' } , repository-name : Project-C-SQL/Project-C-SQL.github.io name : `` Install Project '' runs : { file = `` lazy_object_proxy-1.8.0-cp38-cp38-macosx_10_9_x86_64.whl '' , hash = `` sha256:0c1c7c0433154bb7c54185714c6929acc0ba04ee1b167314a779b9025517eada '' } , ` pylint ` for linting Running all linters : name = `` black '' { file = `` wrapt-1.14.1-cp39-cp39-macosx_10_9_x86_64.whl '' , hash = `` sha256:3232822c7d98d23895ccc443bbdf57c7412c5a65996c30442ebe6ed3df335383 '' } , description = `` Composable command line interface toolkit '' always_document_param_types = False { file = `` wrapt-1.14.1-cp27-cp27m-macosx_10_9_x86_64.whl '' , hash = `` sha256:1b376b3f4896e7930f1f772ac4b064ac12598d1c38d04907e696cc4d794b43d3 '' } , with : description = `` Utility library for gitignore style pattern matching of file paths . '' { file = `` lazy_object_proxy-1.8.0-cp311-cp311-macosx_10_9_x86_64.whl '' , hash = `` sha256:4e2d9f764f1befd8bdc97673261b8bb888764dfdbd7a4d8f55e4fbcabb8c3fb7 '' } , mypy = `` ^0.982 '' uses : actions/checkout @ v2 $ ( grep -cP '^\+ ( ? ! \+ ) ' < < < `` $ blackres '' ) < /summary > category = `` dev '' { file = `` wrapt-1.14.1-cp36-cp36m-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl '' , hash = `` sha256:5b02d65b9ccf0ef6c34cba6cf5bf2aab1bb2f49c6090bafeecc9cd81ad4ea1c1 '' } , runblack ( ) { < div class= '' footer '' style= '' float : right '' > { file = `` wrapt-1.14.1-cp38-cp38-win32.whl '' , hash = `` sha256 : aa31fdcc33fef9eb2552cbcbfee7773d5a6792c137b359e82879c101e98584c5 '' } , path : grade.txt on : pull_request uses : actions/cache @ v2 # isort docs = [ `` furo ( > =2021.7.5b38 ) '' , `` proselint ( > =0.10.2 ) '' , `` sphinx ( > =4 ) '' , `` sphinx-autodoc-typehints ( > =1.12 ) '' ] platformdirs = [ poetry run scripts/ci-grade.sh > grade.txt click = [ { file = `` black-22.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl '' , hash = `` sha256:915ace4ff03fdfff953962fa672d44be269deb2eaf88499a0f8805221bc68c87 '' } , isort = `` > =4.2.5 , < 6 '' { file = `` lazy_object_proxy-1.8.0-cp310-cp310-win32.whl '' , hash = `` sha256 : b70d6e7a332eb0217e7872a73926ad4fdc14f846e85ad6749ad111084e76df25 '' } , { file = `` wrapt-1.14.1-cp39-cp39-musllinux_1_1_x86_64.whl '' , hash = `` sha256:34aa51c45f28ba7f12accd624225e2b1e5a3a45206aa191f6f9aac931d9d56fe '' } , runisort ( ) { { file = `` wrapt-1.14.1-cp36-cp36m-musllinux_1_1_x86_64.whl '' , hash = `` sha256 : d79d7d5dc8a32b7093e81e97dad755127ff77bcc899e845f41bf71747af0c569 '' } , description = `` McCabe checker , plugin for flake8 '' { file = `` mypy-0.982-cp39-cp39-macosx_10_9_universal2.whl '' , hash = `` sha256 : a705a93670c8b74769496280d2fe6cd59961506c64f329bb179970ff1d24f9f8 '' } , description = `` A Python utility / library to sort Python imports . '' { file = `` mypy-0.982-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl '' , hash = `` sha256:86ebe67adf4d021b28c3f547da6aa2cce660b57f0432617af2cca932d4d378a6 '' } , { file = `` mypy-0.982-cp37-cp37m-macosx_10_9_x86_64.whl '' , hash = `` sha256:58f27ebafe726a8e5ccb58d896451dd9a662a511a3188ff6a8a6a919142ecc20 '' } , with : name = `` wrapt '' version = `` 8.1.3 '' python-versions = `` > =3.6.1 , < 4.0 '' echo `` < details > < summary > isort : \ ` isort ` for sorting imports { file = `` platformdirs-2.5.2-py3-none-any.whl '' , hash = `` sha256:027d8e83a2d7de06bbac4e5ef7e023c02b863d7ea5d079477e722bb41ab25788 '' } , { version = `` > =1.14 , < 2 '' , markers = `` python_version > = \ '' 3.11\ '' '' } , { file = `` mypy-0.982-cp37-cp37m-win_amd64.whl '' , hash = `` sha256:724d36be56444f569c20a629d1d4ee0cb0ad666078d59bb84f8f887952511ca1 '' } , git-config-email : < > poetry run ' 'collapse_navigation ' : False , version : 1.2.2 { file = `` wrapt-1.14.1-cp310-cp310-win_amd64.whl '' , hash = `` sha256:6d323e1554b3d22cfc03cd3243b5bb815a51f5249fdcbb86fda4bf62bab9e164 '' } , name = `` mypy '' { file = `` black-22.10.0-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl '' , hash = `` sha256 : b8b49776299fece66bffaafe357d929ca9451450f5466e997a7285ab0fe28e3b '' } , name = `` pylint '' token : $ { { secrets.BOT_SECRET } } For linting , you need the CI tools : ` poetry install -with ci ` . token : $ { { secrets.BOT_SECRET } } { file = `` mccabe-0.7.0-py2.py3-none-any.whl '' , hash = `` sha256:6c2d30ab6be0e4a46919781807b4f0d834ebdd6c6e3dca0bda5a15f863427b6e '' } , version = `` 5.10.1 '' { file = `` wrapt-1.14.1-cp39-cp39-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl '' , hash = `` sha256 : d52a25136894c63de15a35bc0bdc5adb4b0e173b9c0d07a2be9d3ca64a332735 '' } , folder : docs/build { file = `` black-22.10.0-cp38-cp38-win_amd64.whl '' , hash = `` sha256:444ebfb4e441254e87bad00c661fe32df9969b2bf224373a448d8aca2132b395 '' } , options : > env : { file = `` astroid-2.12.12.tar.gz '' , hash = `` sha256:1c00a14f5a3ed0339d38d2e2e5b74ea2591df5861c0936bb292b84ccf3a78d83 '' } , { file = `` wrapt-1.14.1.tar.gz '' , hash = `` sha256:380a85cf89e0e69b7cfbe2ea9f765f004ff419f34194018a6827ac0e3edfed4d '' } , run : poetry run pytest runs-on : ubuntu-latest # print format infos { file = `` mypy-0.982-cp38-cp38-macosx_10_9_universal2.whl '' , hash = `` sha256:14d53cdd4cf93765aa747a7399f0961a365bcddf7855d9cef6306fa41de01c24 '' } , pipfile-deprecated-finder = [ `` pipreqs '' , `` requirementslib '' ] description = `` A fast and thorough lazy object proxy . '' mypyurl= '' [ mypy ] ( https : //mypy.readthedocs.io/en/stable/error_codes.html # error-codes ) '' pr_flow : PGPORT : 5432 # PostgreSQL for novices [ Poetry ] ( # poetry ) { file = `` wrapt-1.14.1-cp38-cp38-macosx_11_0_arm64.whl '' , hash = `` sha256 : e3fb1677c720409d5f671e39bac6c9e0e422584e5f518bfd50aa4cbbea02433f '' } , # poetry run isort `` src '' / * * / * .py -m 3 -- trailing-comma -c & & \ { file = `` wrapt-1.14.1-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl '' , hash = `` sha256:02b41b633c6261feff8ddd8d11c711df6842aba629fdd3da10249a53211a72c4 '' } , PGHOST : localhost platformdirs = `` > =2 '' { { super } } { file = `` tomlkit-0.11.6-py3-none-any.whl '' , hash = `` sha256:07de26b0d8cfc18f871aec595fda24d95b08fef89d147caa861939f37230bf4b '' } , { file = `` lazy_object_proxy-1.8.0-pp38-pypy38_pp73-any.whl '' , hash = `` sha256:7e1561626c49cb394268edd00501b289053a652ed762c58e1081224c8d881cec '' } , lintres= $ ( pylint src -- exit-zero -sn ) You 'll need to tell pytest the password : ` PGPASSWORD=postgres poetry run pytest ` . done ) $ ( sed -r -e '/^src\// ! d ' -e 's/^ [ ^ ] + error/- & / ' -e 's/^ [ ^- ] / # & / ' < < < `` $ mypyres '' ) { file = `` isort-5.10.1-py3-none-any.whl '' , hash = `` sha256:6f62d78e2f89b4500b080fe3a81690850cd254227f27f75c3a0c491a1f351ba7 '' } , { file = `` wrapt-1.14.1-cp39-cp39-macosx_11_0_arm64.whl '' , hash = `` sha256:988635d122aaf2bdcef9e795435662bcd65b02f4f4c1ae37fbee7401c440b3a7 '' } , # ` virtualenvs-in-project : true ` creates a ` .venv ` in test dir for easy caching mypy-extensions = `` > =0.4.3 '' { file = `` black-22.10.0.tar.gz '' , hash = `` sha256 : f513588da599943e0cde4e32cc9879e825d58720d6557062d1098c5ad80080e1 '' } , tomlkit = `` > =0.10.1 '' echo `` < details > < summary > pylint : `` $ lintscore '' < /summary > { file = `` mypy-0.982-cp310-cp310-macosx_11_0_arm64.whl '' , hash = `` sha256 : f793e3dd95e166b66d50e7b63e69e58e88643d80a3dcc3bcd81368e0478b089c '' } , { file = `` lazy_object_proxy-1.8.0-cp38-cp38-win_amd64.whl '' , hash = `` sha256 : afcaa24e48bb23b3be31e329deb3f1858f1f1df86aea3d70cb5c8578bfe5261c '' } , { file = `` mypy-0.982-cp310-cp310-musllinux_1_1_x86_64.whl '' , hash = `` sha256:175f292f649a3af7082fe36620369ffc4661a71005aa9f8297ea473df5772046 '' } , # TODO : generate appropriately scoped access token so a bot can comment lint results echo `` < details > < summary > mypy : $ ( sed -nr 's/^Found ( .+ ) /\1/p ' < < < `` $ mypyres '' ) \ # black = `` ^22.10.0 '' { file = `` lazy_object_proxy-1.8.0-cp311-cp311-win_amd64.whl '' , hash = `` sha256:14010b49a2f56ec4943b6cf925f597b534ee2fe1f0738c84b3bce0c1a11ff10d '' } , < a href= '' https : //github.com/Project-C-SQL/postgresql-for-novices '' > echo `` < details > < summary > black : \ [ Building documents ] ( # building-documents ) n= $ ( echo `` $ lintres '' | grep -cP '^\S+\s+ ' $ x ) version = `` 1.8.0 '' { file = `` black-22.10.0-cp311-cp311-macosx_11_0_arm64.whl '' , hash = `` sha256:5b9b29da4f564ba8787c119f37d174f2b69cdfdf9015b7d8c5c16121ddc054ae '' } , with : { file = `` lazy_object_proxy-1.8.0-cp37-cp37m-win_amd64.whl '' , hash = `` sha256:6f593f26c470a379cf7f5bc6db6b5f1722353e7bf937b8d0d0b3fba911998858 '' } , # # # # Using docker image : postgres:14.5-alpine git-config-email : < > { file = `` mypy-0.982-py3-none-any.whl '' , hash = `` sha256:1021c241e8b6e1ca5a47e4d52601274ac078a89845cfde66c6d5f769819ffa1d '' } , # run them in parallel 5432:5432 # pylint = `` ^2.15.4 '' * [ Psql wrapper interface ] ( ./interfaces.md # psqlwrapper ) python-versions = `` > =3.6 '' # \ ` \ ` \ ` diff # postgresql-for-novices key : poetry-1.2.2-0 # poetry run black src -- check & & \ description = `` Optional static typing for Python '' [ package.extras ] lintscore= $ ( for x in I R C W E F ; do < ! -- TODO : generate appropriately scoped access token so a bot can comment lint results { file = `` mypy-0.982-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl '' , hash = `` sha256:7b35ce03a289480d6544aac85fa3674f493f323d80ea7226410ed065cd46f206 '' } , name = `` pathspec '' { file = `` mypy-0.982-cp310-cp310-macosx_10_9_x86_64.whl '' , hash = `` sha256:41fd1cf9bc0e1c19b9af13a6580ccb66c381a5ee2cf63ee5ebab747a4badeba3 '' } , copyright = '2022 , Heikkilä et al ' { file = `` mypy-0.982-cp37-cp37m-manylinux_2_17_x86_64.manylinux2014_x86_64.whl '' , hash = `` sha256 : d6af646bd46f10d53834a8e8983e130e47d8ab2d4b7a97363e35b24e1d588947 '' } , uses : actions/cache @ v2 run : | { file = `` black-22.10.0-1fixedarch-cp38-cp38-macosx_10_16_x86_64.whl '' , hash = `` sha256:2644b5d63633702bc2c5f3754b1b475378fbbfb481f62319388235d0cd104c2d '' } , # isort = `` ^5.10.1 '' PGPASSWORD : postgres name = `` dill '' $ blackres { file = `` lazy_object_proxy-1.8.0-cp37-cp37m-win32.whl '' , hash = `` sha256:5b51d6f3bfeb289dfd4e95de2ecd464cd51982fe6f00e2be1d0bf94864d58acd '' } , { file = `` black-22.10.0-cp39-cp39-win_amd64.whl '' , hash = `` sha256:432247333090c8c5366e69627ccb363bc58514ae3e63f7fc75c54b1ea80fa7de '' } , poetry run sphinx-apidoc -q -f -o docs/api src/pg4n ' * /test_ * ' & & \ steps : python2 = [ `` typed-ast ( > =1.4.0 , < 2 ) '' ] { file = `` isort-5.10.1.tar.gz '' , hash = `` sha256 : e8443a5e7a020e9d7f97f1d7d9cd17c88bcb3bc7e218bf9cf5095fe550be2951 '' } , d = [ `` aiohttp ( > =3.7.4 ) '' ] name = `` lazy-object-proxy '' { file = `` wrapt-1.14.1-cp36-cp36m-manylinux_2_17_aarch64.manylinux2014_aarch64.whl '' , hash = `` sha256:9736af4641846491aedb3c3f56b9bc5568d92b0692303b5a305301a95dfd38b1 '' } , on : push [ 📄 Documentation ] ( https : //project-c-sql.github.io/ ) \ ` \ ` \ ` uses : snok/install-poetry @ v1 black = `` ^22.10.0 '' { file = `` wrapt-1.14.1-cp38-cp38-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl '' , hash = `` sha256:7b7c050ae976e286906dd3f26009e117eb000fb2cf3533398c5ad9ccc86867b1 '' } , * [ Psql wrapper interface ] ( psql-wrapper ) myst_heading_anchors = 2 { file = `` wrapt-1.14.1-cp36-cp36m-macosx_10_9_x86_64.whl '' , hash = `` sha256:9e0fd32e0148dd5dea6af5fee42beb949098564cc23211a88d799e434255a1f4 '' } , { file = `` dill-0.3.6-py3-none-any.whl '' , hash = `` sha256 : a07ffd2351b8c678dfc4a856a3005f8067aea51d6ba6c700796a4d9e280f39f0 '' } , # `` -0 '' allows invalidating the cache for upgrading Poetry { % block extrafooter % } pylinturl= '' [ pylint ] ( https : //pylint.pycqa.org/en/latest/user_guide/usage/output.html # source-code-analysis-section ) '' version = `` 0.4.3 '' python-versions = `` > =3.7 '' [ package.dependencies ] # [ tool.poetry.group.ci.dependencies ] isort `` src '' / * * / * .py -m 3 -- trailing-comma -c & & astroid = `` > =2.12.12 , < =2.14.0-dev0 '' { file = `` platformdirs-2.5.2.tar.gz '' , hash = `` sha256:58c8abb07dcb441e6ee4b11d8df0ac856038f944ab98b7be6b27b2a3c7feef19 '' } , { file = `` mypy-0.982-cp310-cp310-macosx_10_9_universal2.whl '' , hash = `` sha256:5085e6f442003fa915aeb0a46d4da58128da69325d8213b4b35cc7054090aed5 '' } , { file = `` mypy-0.982-cp39-cp39-win_amd64.whl '' , hash = `` sha256 : eb7a068e503be3543c4bd329c994103874fa543c1727ba5288393c21d912d795 '' } , if : github.ref == 'refs/heads/main ' { % endblock % } < /details > '' postgres : { file = `` wrapt-1.14.1-cp27-cp27mu-manylinux1_i686.whl '' , hash = `` sha256:7ef58fb89674095bfc57c4069e95d7a31cfdc0939e2a579882ac7d55aadfd2a1 '' } , # poetry run mypy src -- show-error-codes -- show-error-context -- pretty & & \ { file = `` mypy-0.982-cp310-cp310-win_amd64.whl '' , hash = `` sha256:8ee8c2472e96beb1045e9081de8e92f295b89ac10c4109afdf3a23ad6e644f3e '' } , { file = `` wrapt-1.14.1-cp36-cp36m-musllinux_1_1_i686.whl '' , hash = `` sha256:6e743de5e9c3d1b7185870f480587b75b1cb604832e380d64f9504a0535912d1 '' } , tomli = { version = `` > =1.1.0 '' , markers = `` python_full_version < \ '' 3.11.0a7\ '' '' } e '/\.py : [ :0-9 ] +\s+W/s/^/ ! / ' \ platformdirs = `` > =2.2.0 '' cat < ( runblack ) < ( runpylint ) < ( runmypy ) < ( runisort ) steps : # `` -0 '' allows invalidating the cache for upgrading Poetry blackurl= '' [ black ] ( https : //black.readthedocs.io/en/stable/usage_and_configuration/the_basics.html # diffs ) '' version = `` 0.3.6 '' 'style_external_links ' : True , version = `` 2.15.5 '' mypy-extensions = [ { file = `` black-22.10.0-py3-none-any.whl '' , hash = `` sha256 : c957b2b4ea88587b46cf49d1dc17681c1e672864fd7af32fc1e9664d572b3458 '' } , { file = `` wrapt-1.14.1-cp37-cp37m-manylinux_2_17_aarch64.manylinux2014_aarch64.whl '' , hash = `` sha256 : b5901a312f4d14c59918c221323068fad0540e34324925c8475263841dbdfe68 '' } , { file = `` wrapt-1.14.1-cp39-cp39-win32.whl '' , hash = `` sha256 : dee0ce50c6a2dd9056c20db781e9c1cfd33e77d2d569f5d1d9321c641bb903d5 '' } , if : steps.cache-deps.outputs.cache-hit ! = 'true ' shell : bash { file = `` mypy_extensions-0.4.3-py2.py3-none-any.whl '' , hash = `` sha256:090fedd75945a69ae91ce1303b5824f428daf5a028d2f6ab8a299250a846f15d '' } , PGHOST : localhost { file = `` wrapt-1.14.1-cp39-cp39-musllinux_1_1_aarch64.whl '' , hash = `` sha256 : b9b7a708dd92306328117d8c4b62e2194d00c365f18eff11a9b53c6f923b01e3 '' } , version = `` 1.14.1 '' { file = `` lazy_object_proxy-1.8.0-cp310-cp310-win_amd64.whl '' , hash = `` sha256 : eb329f8d8145379bf5dbe722182410fe8863d186e51bf034d2075eb8d85ee25b '' } , { file = `` wrapt-1.14.1-cp310-cp310-win32.whl '' , hash = `` sha256 : a9a52172be0b5aae932bef82a79ec0a0ce87288c7d132946d645eba03f0ad8a8 '' } , PGUSER : postgres { file = `` wrapt-1.14.1-cp36-cp36m-win32.whl '' , hash = `` sha256:81b19725065dcb43df02b37e03278c011a09e49757287dca60c5aecdd5a0b8ed '' } , { file = `` lazy_object_proxy-1.8.0-cp38-cp38-win32.whl '' , hash = `` sha256 : d176f392dbbdaacccf15919c77f526edf11a34aece58b55ab58539807b85436f '' } , { file = `` wrapt-1.14.1-cp35-cp35m-manylinux1_i686.whl '' , hash = `` sha256:43ca3bbbe97af00f49efb06e352eae40434ca9d915906f77def219b88e85d907 '' } , { file = `` wrapt-1.14.1-cp27-cp27m-manylinux1_i686.whl '' , hash = `` sha256:903500616422a40a98a5a3c4ff4ed9d0066f3b4c951fa286018ecdf0750194ef '' } , isorturl= '' [ isort ] ( https : //pycqa.github.io/isort/ ) '' mccabe = [ PGUSER : postgres ` mypy ` for static type checking { file = `` wrapt-1.14.1-cp35-cp35m-manylinux2010_i686.whl '' , hash = `` sha256:00b6d4ea20a906c0ca56d84f93065b398ab74b927a7a3dbd470f6fc503f95dc3 '' } , name = `` astroid '' { file = `` wrapt-1.14.1-cp27-cp27mu-manylinux2010_x86_64.whl '' , hash = `` sha256:833b58d5d0b7e5b9832869f039203389ac7cbf01765639c7309fd50ef619e0b1 '' } , html_static_path = [ '_static ' ] $ ( sed -E -e '/\.py : [ :0-9 ] +\s+ [ CEF ] /s/^/- / ' \ test = [ `` appdirs ( ==1.4.4 ) '' , `` pytest ( > =6 ) '' , `` pytest-cov ( > =2.7 ) '' , `` pytest-mock ( > =3.6 ) '' ] [ Documentation ] ( https : //project-c-sql.github.io/ ) { file = `` mypy-0.982.tar.gz '' , hash = `` sha256:85f7a343542dc8b1ed0a888cdd34dca56462654ef23aa673907305b260b3d746 '' } , { file = `` black-22.10.0-1fixedarch-cp310-cp310-macosx_11_0_x86_64.whl '' , hash = `` sha256:5cc42ca67989e9c3cf859e84c2bf014f6633db63d1cbdf8fdb666dcd9e77e3fa '' } , python-version : 3.10.7 { file = `` wrapt-1.14.1-cp27-cp27mu-manylinux1_x86_64.whl '' , hash = `` sha256 : e2f83e18fe2f4c9e7db597e988f72712c0c3676d337d8b101f6758107c42425b '' } , description = `` Experimental type system extensions for programs checked with the mypy typechecker . ''","['.github/actions/install/action.yml', '.github/workflows/ci-flow.yml', '.github/workflows/pr_flow.yml', '.github/workflows/pytest.yml', '.github/workflows/sphinx.yml', 'README.md', 'docs/_static/github-mark.svg', 'docs/_templates/footer.html', 'docs/conf.py', 'docs/program-architecture.md', 'poetry.lock', 'pyproject.toml', 'scripts/ci-grade.sh']",2022-10-26 10:02:30+00:00,2022-11-06 12:04:39+00:00,2022-11-06 14:04:38+02:00
49,cd7168bd9791c3c51875f85850371cec52a72e57,1.3988762475491969e-05,1,"Wrapper has 2 significant bugs left : - parse multiline queries properly ( ` db= > SELECT db- > db- > * FROM orders ; ` ) - separate queries properly ( ` db= > SELECT * FROM orders ; db= > INSERT INTO queries VALUES ( 6,6,6 ) ; ` should not parse as ` SELECT * FROM orders ; db= > INSERT INTO queries VALUES ( 6,6,6 ) ; ` ) due to lazily sticking to SELECT as the delimiter .","Multiline queries , detect separate queries",Merge pull request # 80 from Project-C-SQL/fix/wrapper,"from pyparsing import CaselessLiteral , Char , Literal , MatchFirst , \ str ( self.supported_psql_versions ) + `` . '' # in live scenarios most of the time , but I can not reproduce it with this ZeroOrMore ( Char ( `` \n '' ) | Char ( `` \r '' ) ) + self.match_whole_rev_sql_stmt pexpect.spawn ( `` psql `` + bytes.decode ( self.psql_args ) `` psql ( 14.5 ) \nType \ '' help\ '' for help.\n\npgdb= # SELECT * FROM orders ; \npgdb= # INSERT INTO orders VALUES ( 6 , 6 , 6 ) ; \npgdb= # SELECT * FROM\n orders WHERE order_total_eur = 100 ; `` match_error : ParserElement = \ Literal ( `` psql ( PostgreSQL ) `` ) + Combine ( Word ( nums ) + ' . ' + Word ( nums ) ) self.db_name : bytes = db_name_parameter psql.ofilter ( b'\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) # If it is SELECT , remove multiline delimiters and then statement is # magic strings related seemingly solely to ctrl-R use are b ' 207.60 | 9\x1b [ m\r\n 21 | 471.12 | 179\x1b [ m\r\n : \x1b [ K ' ) Literal ( `` ERROR : '' ) Literal ( `` > = '' ) | Literal ( `` # = '' ) case_query_2_prompt = \ match_prompt + match_sql_stmt + match_sql_stmt_end psql.ofilter ( b '' '\r ( reverse-i-search ) ` ' : `` ) # assert p.parse_last_found_stmt ( case_select_then_insert ) == \ psql.ofilter ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C1 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 1\x1b [ 27m00 ; \x08\x08\x08\x08\x08\x08 '' ) ParseException , ParseResults , ParserElement , StringEnd , Word , ZeroOrMore , \ `` SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; '' # BUG ( ? ) : Assumes only single statement query psql.ofilter ( b'\r ( reverse-i-search ) ` \ ' : ' ) # TODO/BUG : removing \n 's is a tough problem , see : .replace ( db_name + `` - > '' , `` '' ) \ try : match_sql_stmt : ParserElement = \ tok_stmt_end # case_query_3_prompt = b ' order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004hpgdb= # ' version_info = \ case_multiple_queries_and_whitespaces = \ # psql.ofilter ( return_press_1 ) match_sql_stmt_start : ParserElement = \ parse_sql_stmt : ParserElement = \ .replace ( db_name + `` - # '' , `` '' ) return reversed_flattened_res stmt_res = match_version_stmt.parse_string ( psql ) # `` '' # print ( psql.pyte_screen.display ) b'\x1b [ ? 2004l\r order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\r\nTest\r\n\r\n\x1b [ ? 2004htest_db= # ' self.psql_args : bytes = psql_args if stmt_res : # TODO : For some reason Literal ( `` > = '' ) does not provide a match , # Literal ( `` ERROR : '' ) psql.ofilter ( b'\x08order_total_eur = 0 AND order_total_eur = 1\x1b [ 1P00 ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) psql.ofilter ( b'\r\n ' ) # case_select_then_insert = `` psql ( 14.5 ) \nType \ '' help\ '' for help.\n\npgdb= # SELECT * FROM orders ; \npgdb= # INSERT INTO orders VALUES ( 6 , 6 , 6 ) ; '' psql.ofilter ( b'orders ' ) except ParseException as e : ( CaselessLiteral ( `` > - '' ) | CaselessLiteral ( `` # - '' ) ) + \ # ctrl-R to previous query with three key presses searching ( 1 .. 0 .. 0 ) . Press return . ( CaselessLiteral ( `` > = '' ) | CaselessLiteral ( `` # = '' ) ) + \ # should parse as \n - > `` '' if self.debug : match_rev_any_sql_stmt : ParserElement = \ def parse_psql_version ( self , psql : str ) - > str : c = pexpect.spawn ( `` psql `` + bytes.decode ( self.psql_args ) , match_select_stmt : ParserElement = \ from pyparsing import \ tok_rev_prompt : ParserElement = \ case_multiline_query = \ psql.ofilter ( b'\x1b [ ? 2004htest_db- # ' ) if len ( res_list ) == 4 : # includes \x1b [ ? 2004l # complicated case : user has ctrl-R 'd , copy-pasted command or something , # If parsing was successful , pick interesting parts . version_info.expect ( pexpect.EOF ) result : str = `` '' ( CaselessLiteral ( `` = > '' ) | CaselessLiteral ( `` = # '' ) ) # reverse string for parsing efficiency db_name : str = `` '' Word ( prompt_chars ) + Char ( '\n ' ) psql.ofilter ( b'\x08order_total_eur = 0 AND order_total_eur = 10\x1b [ C\x1b [ 1P ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) # fresh prompt : psql.ofilter ( b'SELECT ' ) # extra whitespace : psql.ofilter ( b ' * ' ) f.close ( ) return `` '' # `` pgdb= > SELECT if is_select : # Something weird going this test case . Pyte understands this case right match_last_stmt : ParserElement = \ tok_prompt : ParserElement = \ results = [ stmt_res_list [ length - 2 ] , psql.ofilter ( b'\x08\x08 ' ) ZeroOrMore ( White ( ) ) + tok_stmt_end + ... + \ # b ' order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\r\nTest\r\n\r\n\x1b [ ? 2004hpgdb= # ' psql.ofilter ( b'\r\x1b [ C ' ) assert p.parse_last_found_stmt ( case_select_then_insert ) == \ ZeroOrMore ( Char ( `` \n '' ) | Char ( `` \r '' ) | White ( ) ) + \ from functools import reduce ( StringEnd ( ) | ( Literal ( `` ? [ \x1b '' ) + \ # then reverse the matched string . psql.ofilter ( b '' \x08\x08\x08= ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m=\x1b [ 27m 100 ; \x08\x08\x08\x08\x08\x08 '' ) match_rev_sql_stmt_start : ParserElement = \ b'\r\x1b [ 16Ppgdb= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_tot\x08\r\n\x1b [ ? 2004l\r ' # saved stream of characters . Literal ( `` > = '' ) | Literal ( `` # = '' ) # parser combinations # `` pgdb= > SELECT * FROM orders WHERE order_tot # should parse as \n - > `` `` to avoid `` SELECT * FROM .. '' . psql.ofilter ( b'\r\x1b [ K\x1b > \x1b [ r\x1b [ ? 1049l ' ) supported_psql_versions : list [ str ] = [ `` 14.5 '' ] version_ok : bool = version in self.supported_psql_versions : returns : version string ( e.g `` 14.5 '' ) ( CaselessLiteral ( `` - > '' ) | CaselessLiteral ( `` - # '' ) ) psql.ofilter ( b'FROM ' ) ParseResults , ParserElement , StringEnd , White , Word , ZeroOrMore , \ # psql.ofilter ( case_query_3 ) print ( version_msg ) b'\r\nTest\r\n\r\n\x1b [ ? 2004htest_db= # ' psql.ofilter ( b'\x1b [ ? 2004l\r\x1b [ ? 1049h\x1b=\r order_id | order_total_eur | customer_id \x1b [ m\r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\x1b [ m\r\n 1 | 535.36 | 111\x1b [ m\r\n 2 | 409.80 | 217\x1b [ m\r\n 3 | 189.43 | 19\x1b [ m\r\n 4 | 144.14 | 157\x1b [ m\r\n 5 | 582.52 | 172\x1b [ m\r\n 6 | 132.85 | 206\x1b [ m\r\n 7 | 183.92 | 236\x1b [ m\r\n 8 | 424.80 | 244\x1b [ m\r\n 9 | 519.43 | 175\x1b [ m\r\n 10 | 414.55 | 234\x1b [ m\r\n 11 | 88.19 | 50\x1b [ m\r\n 12 | 591.72 | 143\x1b [ m\r\n 13 | 503.52 | 216\x1b [ m\r\n 14 | 586.06 | 181\x1b [ m\r\n 15 | 47.79 | 248\x1b [ m\r\n 16 | 330.92 | 130\x1b [ m\r\n 17 | 302.31 | 225\x1b [ m\r\n 18 | 438.38 | 26\x1b [ m\r\n 19 | 107.53 | 94\x1b [ m\r\n 20 | ' Word ( stmt_chars ) case_query_with_newline = \ # Arrow-up to previous query , alt-B until 'orders WHERE ' and remove the `` sql ( 14.5 ) \nType \ '' help\ '' for help.\n\npgdb= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n '' b ' order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004hpgdb= # ' case_select_then_insert = `` psql ( 14.5 ) \nType \ '' help\ '' for help.\n\npgdb= # SELECT * FROM orders ; \npgdb= # INSERT INTO orders VALUES ( 6 , 6 , 6 ) ; '' # TODO : strip `` - > '' / '' - # '' from string to allow multiline queries `` `` '' Parse for psql version and return version number . MatchFirst ( [ tok_prompt ] ) `` -- version '' ) # fresh prompt in this case : # BUG : Will match until previous SELECT query , if newest is e.g INSERT assert psql.ofilter ( case_query_2_prompt ) == \ results = [ stmt_res_list [ length - 3 ] , psql.ofilter ( b'SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; ' ) # in live scenarios most of the time , but I can not reproduce it with this assert p.parse_last_found_stmt ( case_empirical_1 ) == \ assert psql.ofilter ( b'\x1b [ ? 2004l\r order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004htest_db= # ' ) == \ self.tok_rev_prompt_end + \ stmt_res_list [ length - 3 ] , assert p.parse_last_found_stmt ( case_query_with_newline ) == \ # match_error : ParserElement = \ if len ( res_list ) == 4 : # results include \x1b [ ? 2004l match_prompt : ParserElement = \ stmt_res_list [ length - 4 ] ] # reverse order `` SELECT * FROM orders ; '' # case_query_3 = \ psql.ofilter ( case_query_2 ) `` sql ( 14.5 ) \nType \ '' help\ '' for help.\n\npgdb= # SELECT * FROM orders WHERE order\n_total_eur = 100 ; \n\n\n '' def check_psql_version ( self ) - > str : # ready for analysis . tok_prompt_linebreak : ParserElement = \ f.write ( str ( e.explain ( ) ) + `` \n '' ) # magic strings related to solely to ctrl-R use are assert p.parse_last_found_stmt ( case_multiline_query ) == \ # Fix it by matching rev_stmt_start also against rev_prompt version : str = self.parser.parse_psql_version ( version_info_str ) tok_rev_prompt_end : ParserElement = \ assert psql.pg4n_message == `` Test '' from shutil import get_terminal_size assert psql.ofilter ( b'\x1b [ ? 2004htest_db= # ' ) == \ `` SELECT * FROM orders WHERE order_total_eur = 100 ; '' match_select_stmt.parse_string ( no_newlines_res ) is not [ ] # complicated case : user has ctrl-R 'd , copypasted command or something . demultilined_res = no_newlines_res\ tok_stmt_end + ... + match_rev_sql_stmt_start # Broken case found in empirical testing # TODO : allow multiple statements # reverse back , concatenate , and remove \n 's # Match statement that might have \r\n or whitespace at the end . identbodychars identbodychars , nums elif len ( res_list ) == 2 : # parsing stops right after database name CaselessLiteral ( `` SELECT `` ) # All interesting stmts are 'select ' # saved stream of characters . Most likely the control streams depend def __init__ ( self , db_name_parameter : bytes , elif len ( res_list ) == 2 : # stops right after database name if version_ok : ( Literal ( `` > = '' ) | Literal ( `` # = '' ) ) + \ assert psql.ofilter ( case_query_2_prompt ) == \ version_msg = self.check_psql_version ( ) psql.ofilter ( b '' \r\n\x1b [ ? 2004l\r '' ) psql.ofilter ( b ' ; ' ) case_empirical_1 = \ # Arrow-up to previous query , alt-B until 'orders WHERE ' and remove the CaselessLiteral , Char , Combine , Literal , ParseException , \ psql.ofilter ( b'\x1b [ ? 2004l\r\x1b [ ? 2004htest_db- # ' ) # Is the statement a SELECT statement ? def __init__ ( self , psql_args : bytes , # TODO : test case for multiline - > queries `` `` '' # replacing \n 's with `` '' maybe has less edge cases . # parser tokens : return result f = open ( `` psqlparser.log '' , `` a '' ) # b'SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; ' return demultilined_res psql.ofilter ( b'\r\n\r\r\n ' ) case_query_2_prompt = b '' order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004htest_db= # `` # psql.ofilter ( b'\x08\x08 ' ) match_whole_rev_sql_stmt : ParserElement = \ Char ( '\n ' ) + Word ( prompt_chars ) + \ ( StringEnd ( ) | ( Literal ( `` ? [ \x1b '' ) psql.ofilter ( b '' \x08\x08\x08t ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_to\x1b [ 7mt\x1b [ 27mal_eur = 100 ; \x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08 '' ) else : match_version_stmt : ParserElement = \ # al_eur = 100 ; '' `` SELECT * FROM orders WHERE order_total_eur = 100 ; '' # Parse prompt text at the end , so multiline queries can be cleaned tok_rev_prompt_end b ' order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n ' + b'\r\n ' + b'Test ' + b'\r\n\r\n ' + b'\x1b [ ? 2004hpgdb= # ' psql.ofilter ( b'\r\n\x1b [ ? 2004l\r ' ) is_select : bool = False `` `` psql.ofilter ( b '' \x1b [ A\rtest_db= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; \x1b [ K\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\r\n\r '' ) psql.ofilter ( b'\x08\x08\x08\x08 ' ) # on terminal size , and can not be just copy-pasted from live tests . psql.ofilter ( b'\x08\x08\x08\x08\x08\x08 ' ) stmt_res = match_last_stmt.parse_string ( psql_rev ) b '' order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\r\nTest\r\n\r\n\x1b [ ? 2004htest_db= # `` no_newlines_res = reversed_flattened_res.replace ( '\n ' , `` ) # Something weird going these test case . Pyte understands this case right psql.ofilter ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 10\x1b [ 27m0 ; \x08\x08\x08\x08\x08\x08 '' ) assert p.parse_last_found_stmt ( case_multiple_queries_and_whitespaces ) == \ psql.ofilter ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 100\x1b [ 27m ; \x08\x08\x08\x08\x08\x08 '' ) # psql.ofilter ( b'\x08\x08\x08\x08 ' ) stmt_res : ParseResults = None stmt_res = match_rev_last_stmt.parse_string ( psql_rev ) # assert psql.ofilter ( case_query_3_prompt ) == \ tok_rev_prompt_linebreak : ParserElement = \ psql = new_psqlwrapper ( ) b '' \x1b [ A\rtest_db= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; \x1b [ K\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\r\n\r '' self.tok_rev_prompt_end version_info_str : str = bytes.decode ( version_info.before ) match_sql_stmt_end : ParserElement = \ stmt_res_list [ length - 4 ] ] `` psql ( 14.5 ) \nType \ '' help\ '' for help.\n\npgdb= # SELECT * FROM\npgdb- # orders ; '' self.match_rev_any_sql_stmt + Word ( self.prompt_chars ) : param psql : psql -- version output # reverse given string , match reversed tokens , pick first match , is_select = \ # TODO ( ? ) : We may have to match for errors # ctrl-R to previous query . Query includes a return press near end . return `` Pg4n has only been tested on psql versions `` + \ result = stmt_res.as_list ( ) [ 1 ] # multiline query # but works fine without the whitespace .. # * FROM orders WHERE order_total_eur = 100 ; # psql.ofilter ( b'\x08\x1b [ 1P ' ) # properly . # extra 2 whitespaces : ZeroOrMore ( White ( ) ) + CaselessLiteral ( `` SELECT '' ) if version_msg ! = `` '' : CaselessLiteral ( `` TCELES '' ) + ( CaselessLiteral ( `` > = '' ) | CaselessLiteral ( `` # = '' ) ) c = pexpect.spawn ( `` psql `` + bytes.decode ( self.db_name ) , match_rev_last_stmt : ParserElement = \ # psql.ofilter ( b'\x08\x08\x08\x08\x08\x08 ' ) db_name = stmt_res_list [ length - 1 ] [ : :-1 ]","['src/pg4n/psqlparser.py', 'src/pg4n/psqlwrapper.py', 'src/pg4n/test/test_psqlparser.py', 'src/pg4n/test/test_psqlwrapper.py']",2022-11-04 15:31:55+00:00,2022-11-21 14:23:46+00:00,2022-11-21 16:23:44+02:00
52,dbbd4ef6012e41811e4d34b77b6e621abbb89329,1.0556689630902838e-05,1,To be discussed in sprint planning,Adding automatic formatter to development pipeline,Merge pull request # 103 from Project-C-SQL/feat/githooks,"`` Actual Loops '' : int , multiline_prompt_ends : list [ str ] = \ from .. sqlparser import Column , SqlParser ... # has already been parsed as prompt_chars language = 'en ' self.pg_host project = 'PostgreSQL for novices ' psql._intercept ( case_empirical_1 = 'sql ( 14.5 ) \nType `` help '' for help.\n\npgdb= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n ' SQL_NESTED_WHERE_SUSPICIOUS = \ `` - ! > '' , `` Actual Startup Time '' : float , ) .get ( ) b'\r\nTest\r\n\r\n\x1b [ ? 2004htest_db= # ' Word ( nums ) analysis_result : Optional [ str ] = None b'\x08\r\n ' psql._intercept ( b ' ; ' ) `` host= '' + self.pg_host cmp_column_name = SqlParser.get_column_name_from_column_expression ( `` Plan Rows '' : int , conninfo_res = match_psql_conninfo.parse_string ( conninfo_str ) .as_list ( ) Opt ( Literal ( `` * '' ) | Literal ( `` ! '' ) | Literal ( `` ? `` ) , `` '' ) qep = TypedDict ( `` QEP '' , { project = `` PostgreSQL for novices '' case_psql_start = \ has_onetime_filter_with_constraint_exclusion and \ def find ( self , pr : Callable [ [ node ] , bool ] , recursive=False ) - > list [ node ] : b '' \x1b [ ? 2004l\r\x1b [ ? 1049h\x1b=\r order_id | order_total_eur | customer_id \x1b [ m\r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\x1b [ m\r\n 1 | 535.36 | 111\x1b [ m\r\n 2 | 409.80 | 217\x1b [ m\r\n 3 | 189.43 | 19\x1b [ m\r\n 4 | 144.14 | 157\x1b [ m\r\n 5 | 582.52 | 172\x1b [ m\r\n 6 | 132.85 | 206\x1b [ m\r\n 7 | 183.92 | 236\x1b [ m\r\n 8 | 424.80 | 244\x1b [ m\r\n 9 | 519.43 | 175\x1b [ m\r\n 10 | 414.55 | 234\x1b [ m\r\n 11 | 88.19 | 50\x1b [ m\r\n 12 | 591.72 | 143\x1b [ m\r\n 13 | 503.52 | 216\x1b [ m\r\n 14 | 586.06 | 181\x1b [ m\r\n 15 | 47.79 | 248\x1b [ m\r\n 16 | 330.92 | 130\x1b [ m\r\n 17 | 302.31 | 225\x1b [ m\r\n 18 | 438.38 | 26\x1b [ m\r\n 19 | 107.53 | 94\x1b [ m\r\n 20 | `` has_sort_node = len ( tok_pre_port : ParserElement = Literal ( ' '' at port `` ' ) def _check_and_act_on_repl_output ( self , latest_output : bytes ) - > bytes : if not self._are_from_compatible_domains ( cmp_columns [ 0 ] , SQL_NOT_NULL_CONSTRAINT_VIOLATION = \ unreversed_flattened_res : str = reduce ( lambda x , y : x + y [ : :-1 ] , results , `` '' ) psql._intercept ( b'\x08\x08\x08\x08\x08\x08 ' ) optional = false insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 250 , 367.56 , 214 ) ; '' '' '' ) from .semanticrouter import SemanticRouter `` psql `` + reduce ( lambda x , y : x + y , sys.argv [ 1 : ] , `` '' ) qep_analysis : QEPAnalysis = QEPParser ( conn=conn ) .parse ( sql_query ) Word ( nums ) psql._intercept ( b '' \x08\x08 '' ) PsqlParser ( ) , 'collapse_navigation ' : False , conninfo_res = \ name = `` poetry-githooks '' SqlParser.get_column_name_from_column_expression ( import pexpect has_onetime_filter_without_constraint_exclusion = ( f '' '' '' identbodychars , nums `` SELECT * FROM orders WHERE order_total_eur = 100 ; '' `` password= '' + self.pg_pass tok_stmt_end : ParserElement = Char ( ' ; ' ) import pytest self.tok_host from pyte import Stream , Screen multiline_prompt_ends : list [ str ] = [ [ Githooks ] ( # githooks ) has_onetime_filter_with_constraint_exclusion = ( sanitized_sql : exp.Expression = sql_parser.parse_one ( sql_query ) `` collapse_navigation '' : False , parser : PsqlParser , bytes.decode ( prompt , `` utf-8 '' ) f.write ( import sqlglot.expressions as exp sql_query : str psql._intercept ( b '' \r\x1b [ K\x1b > \x1b [ r\x1b [ ? 1049l '' ) b'\r\n ' html_theme = 'sphinx_rtd_theme ' case_multiline_query = ( split_prompt [ 0 ] + `` \r\n '' total_start_offset = \ case_select_then_insert = `` psql ( 14.5 ) \nType \ '' help\ '' for help.\n\npgdb= # SELECT * FROM orders ; \npgdb= # INSERT INTO orders VALUES ( 6 , 6 , 6 ) ; '' tok_user : ParserElement = \ psql._intercept ( b '' \x1b [ A\rtest_db= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; \x1b [ K\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\r\n\r '' ) `` Actual Rows '' : int , `` Parent Relationship '' : str , `` Triggers '' : list [ str ] , tok_end : ParserElement = Literal ( ' '' . ' ) `` SELECT * FROM orders ; '' match_rev_magical_returns.parse_string ( psql_rev ) Literal ( `` You are connected to database \ '' '' ) ) - > bytes : from .. psqlparser import PsqlParser potential_future_screen_output_sink.feed ( `` ' ! > '' , tok_pre_database : ParserElement = \ click = `` > =8.0.3 , < 9.0.0 '' psql._intercept ( b '' \r\x1b [ C '' ) tok_pre_host : ParserElement = Literal ( ' '' on host `` ' ) | Literal ( ' '' via socket in `` ' ) `` explain ( format json , analyze , verbose ) `` + stmt.strip ( ) .rstrip ( `` ; '' ) + `` ; '' if self.parser.output_has_new_prompt ( SQL_OUTER_ORDER_WITH_INNER_ORDER = \ from .sqlparser import Column elif ( ( a.type.digits is None and b.type.digits is not None ) or psql._intercept ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 100\x1b [ 27m ; \x08\x08\x08\x08\x08\x08 '' ) b '' \x08\x08\x08= ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m=\x1b [ 27m 100 ; \x08\x08\x08\x08\x08\x08 '' `` Actual Total Time '' : float , def _detect_suspicious_cmps ( self , select_statement : exp.Select , `` - * # '' , `` * * # '' , `` \ ' * # '' , `` \ '' * # '' , `` $ * # '' , `` ( * # '' , `` $ * > '' , `` ( ? # '' , assert p.parse_last_stmt ( case_select_then_insert ) == \ columns : list [ Column ] ) : `` SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; '' potential_future_contents : str = `` \n '' .join ( ) : columns : list [ Column ] ) : return_press_2 = \ ) `` `` '' `` ' ? # '' , `` SELECT '' import copy b '' \x08order_total_eur = 0 AND order_total_eur = 1\x1b [ 1P00 ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C '' tok_end : ParserElement = \ `` Parent Relationship '' : str , b'\x1b [ ? 2004hpgdb= # ' `` Index Name '' : str , unreversed_flattened_res : str = \ g.write ( str ( new_output ) + `` \n '' ) `` .txt '' : `` markdown '' , stmt.strip ( ) .rstrip ( ' ; ' ) + `` ; '' QEPParser ( conn=self.db_connection , constraint_exclusion=True ) psql._intercept ( b '' \r\n\r\r\n '' ) potential_future_screen_output_sink = \ SQL_OUTER_ORDER_WITH_INNER_ORDER = f '' '' '' if self.parser.output_has_magical_return ( columns : list [ Column ] = \ from .sqlparser import Column , SqlParser case_query_2 = b '' \x1b [ A\rtest_db= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; \x1b [ K\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\r\n\r '' from pytest_postgresql import factories self import psycopg psql_args : str psql = PsqlWrapper ( `` '' , ) - > str : PsqlParser ( ) whole_statement.find ( containing_where ) a.type.digits is not None and b.type.digits is None `` sphinx.ext.todo '' , return_press_2 = b '' \r\n\x1b [ ? 2004l\r '' not has_onetime_filter_without_constraint_exclusion `` Actual Total Time '' : float , assert p.parse_last_stmt ( case_multiline_query ) == \ from .. qepparser import QEPParser no_newlines_res = unreversed_flattened_res.replace ( '\n ' , ' ' ) `` * > '' , SQL_INT_VARCHAR_VALID = \ `` psql ( 14.5 ) \nType \ '' help\ '' for help.\n\npgdb= # SELECT * FROM\npgdb- # orders ; '' psql._intercept ( b'\x08\x08 ' ) `` ' * > '' , enumerate ( self.suspicious_cmp_contexts ) : case_psql_start = b'psql ( 14.5 ) \r\nType `` help '' for help.\r\n\r\n\x1b [ ? 2004hpgdb= # ' `` Relation Name '' : str , if not self._are_from_compatible_domains ( cmp_columns [ 0 ] , cmp_columns [ 1 ] ) : SQL_NESTED_WHERE_SUSPICIOUS = f '' '' '' tok_database : ParserElement = Word ( identbodychars ) checker = ImpliedExpressionChecker ( case_multiple_queries_and_whitespaces = 'psql ( 14.5 ) \nType `` help '' for help.\n\npgdb= # SELECT * FROM orders ; \npgdb= # INSERT INTO orders VALUES ( 6 , 6 , 6 ) ; \npgdb= # SELECT * FROM\n orders WHERE order_total_eur = 100 ; ' PsqlParser ( ) ) qep_parser_without_constraint_exclusion = \ import sys SQL_WITHOUT_OUTER_ORDER = \ 'style_external_links ' : True , QEPParser , f.write ( `` \n '' .join ( line.rstrip ( ) for line in self.pyte_screen.display ) ) CaselessLiteral ( `` SELECT '' ) SQL_SIMPLE = \ whole_statement [ : total_start_offset ] + \ lambda x : `` '' , `` Plans '' : List [ `` node '' ] , '.md ' : 'markdown ' , whole_statement [ : total_start_offset ] sql_parser : SqlParser = SqlParser ( conn ) assert ( case_trivial = \ tok_pre_port : ParserElement = \ psql._intercept ( b '' '\r ( reverse-i-search ) ` ' : `` ) ParserElement , `` \x1b [ ? 2004hpgdb= # `` , g.write ( str ( new_output ) + '\n ' ) 'myst_parser ' , b '' 207.60 | 9\x1b [ m\r\n 21 | 471.12 | 179\x1b [ m\r\n : \x1b [ K '' VT100_UNDERLINE + \ return_press_3 = b '' \x08\r\n '' import psycopg sanitized_sql : exp.Expression = \ `` ' > '' , VT100_UNDERLINE `` `` print_msg + `` \r\n\r\n '' case_trivial = `` \x1b [ ? 2004hpgdb= > `` cmp_columns [ 1 ] ) : match_version_stmt : ParserElement = Literal ( `` psql ( PostgreSQL ) `` ) + Combine ( self.tok_database potential_future_screen = deepcopy ( self.pyte_screen ) psql._intercept ( b '' FROM '' ) `` user= '' split_prompt [ 1 ] , ) `` Plan Rows '' : int , sanitized_sql , sql_parser underlined_query = ( conn=self.db_connection , constraint_exclusion=True `` One-Time Filter '' : str , psql._intercept ( b '' \r\n '' ) conn psql._intercept ( b'\x08order_total_eur = 0 AND order_total_eur = 1\x1b [ 1P00 ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) '.txt ' : 'markdown ' , `` Alias '' : str , tok_pre_database : ParserElement = Literal ( 'You are connected to database `` ' ) def _check_and_act_on_repl_output ( unreversed_flattened_res : str = reduce ( html_static_path = [ `` _static '' ] nums results = [ stmt_res_list [ 3 ] , dimensions= ( self.rows , self.cols ) , `` ( * # '' , SqlParser , stmt_res_list [ length - 3 ] , containing_where_start_offset + cmp_start_offset sanitized_sql , sql_query , conn poetry-githooks = `` ^2.0.0 '' qep_analysis_without_constraint_exclusion = ( SQL_CHECK_CONSTRAINT_VIOLATION = \ case_query_2 = \ SQL_INT_VARCHAR_VALID = f '' '' '' whole_statement [ total_end_offset : len ( whole_statement ) ] SQL_NESTED_WHERE_VALID = \ ... has_onetime_filter_with_constraint_exclusion `` ' # '' , `` .rst '' : `` restructuredtext '' , `` Actual Loops '' : int , # # # # Githooks } , `` - ! # '' , stmt_res_list [ length - 4 ] self.tok_pre_database + self.tok_database ' '' ? # ' , stmt_res_list [ 1 ] ] { file = `` poetry_githooks-2.0.0-py3-none-any.whl '' , hash = `` sha256:3eb0d2371ab10f7da3fc3f555446b5ee168b6de25fa0c9f22bcd6ce9cebed5cf '' } , QEPParser ( conn=conn ) .parse ( sql_query ) '' , assert p.parse_last_stmt ( case_trivial ) == `` SELECT * FROM orders ; '' b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C '' sql_parser.parse_one ( sql_query ) psql._intercept ( b '' * '' ) content-hash = `` 4b0b96510694d91c9e450261d0e6ad6e5c8fd5406801b3ba7190c6451be463e5 '' psql._intercept ( b'\x1b [ ? 2004l\r\x1b [ ? 2004htest_db- # ' ) res_list [ 2 ] [ : :-1 ] + res_list [ 1 ] [ : :-1 ] + res_list [ 0 ] [ : :-1 ] , author = 'Heikkilä et al . ' type_start_matcher = re.compile ( r '' ^ ( [ a-zA-Z ] + ) . * $ '' ) bytes.decode ( prompt , `` utf-8 '' ) self.tok_rev_prompt_end Word ( nums ) ParserElement , `` sql ( 14.5 ) \nType \ '' help\ '' for help.\n\npgdb= # SELECT * FROM orders WHERE\norder_total_eur = 100 ; \n\n\n '' [ tool.githooks ] whole_statement [ total_end_offset : len ( whole_statement ) ] ] Literal ( `` \ '' via socket in \ '' '' ) ( Literal ( `` = '' ) | Literal ( `` ^ '' ) ) `` Filter '' : str , ) `` ` bash assert p.parse_last_stmt ( case_multiline_query ) == `` SELECT * FROM orders ; '' b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 100\x1b [ 27m ; \x08\x08\x08\x08\x08\x08 '' return self.find ( pr ) + list ( `` Startup Cost '' : float , `` ( ! # '' , 'sphinx_autodoc_typehints ' , `` * # '' , p.parse_last_stmt ( case_query_with_newline ) `` \x1b [ ? 2004hpgdb= > `` == b '' \x1b [ ? 2004l\r order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\r\nTest\r\n\r\n\x1b [ ? 2004htest_db= # `` QEPParser ( conn=self.db_connection , constraint_exclusion=False ) psql._intercept ( b'\r\n ' ) b.type.precision is None ) ) : import pytest VT100_RESET ) .check ( ) from shutil import get_terminal_size assert p.parse_last_stmt ( case_select_then_insert ) == `` '' SQL_MULTIPLE_INNER_ORDERS = \ SQL_NESTED_WHERE_VALID = f '' '' '' return self.find ( pr ) + \ self.warning_msg += '\n ' `` Execution Time '' : float , SqlParser ( conn ) assert psql._intercept ( b'\x1b [ ? 2004l\r order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004htest_db= # ' ) == \ whole_statement [ total_start_offset : total_end_offset ] + \ tok_host : ParserElement = Word ( identbodychars + `` / . '' ) node = TypedDict ( `` Plan '' , { SQL_VARCHAR_SUSPICIOUS = f '' '' '' stmt = ( VT100_RESET + \ analysis_result = CmpDomainChecker ( sanitized_sql , columns ) .check ( ) 'sphinx.ext.todo ' , psql._intercept ( b ' * ' ) `` Startup Cost '' : float , self.tok_pre_host reduce ( sql_parser : SqlParser = \ b '' \x1b [ ? 2004l\r order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004htest_db= # `` == `` SELECT * FROM orders WHERE order_total_eur = 100 ; '' SQL_NESTED_SUBQUERY_INNER_ORDER = \ qep = TypedDict ( from .qepparser import QEPAnalysis , QEPParser This project uses ` poetry-githooks ` to run automatic formatting on each commit . To set this up , run : `` Scan Direction '' : str , `` Node Type '' : str , self.pg_pass `` $ ? > '' , b'SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; ' potential_future_contents : str = '\n'.join ( `` Scan Direction '' : str , p.parse_last_stmt ( case_empirical_1 ) sanitized_sql , qep_analysis `` ( # '' , SQL_OUTER_ORDER_WITHOUT_INNER_ORDER = f '' '' '' `` style_external_links '' : True , `` dbname= '' + self.pg_name psql._intercept ( b'orders ' ) qep_analysis_without_constraint_exclusion = \ `` psql ( 14.5 ) \nType \ '' help\ '' for help.\n\npgdb= # SELECT * FROM orders ; '' from .qepparser import ( b'\r\n ' + b'Test ' + b'\r\n\r\n ' + b'\x1b [ ? 2004hpgdb= # ' config_values : Optional [ ConfigValues ] == `` SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; '' screen : str = `` \n '' .join ( line.rstrip ( ) for line in self.pyte_screen.display ) return_press_1 = \ assert p.parse_new_prompt_and_rest ( case_mixed_results ) == \ no_newlines_res = unreversed_flattened_res.replace ( `` \n '' , `` `` ) has_onetime_filter_without_constraint_exclusion = \ def run_analysis ( psql._intercept ( b'\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) `` - * > '' , b'\x1b [ ? 2004l\r order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\r\nTest\r\n\r\n\x1b [ ? 2004htest_db= # ' match_select_stmt : ParserElement = ZeroOrMore ( White ( ) ) + CaselessLiteral ( nums , `` sphinx.ext.autodoc '' , case_multiple_queries_and_whitespaces = \ qep_analysis self.qep_analysis.root.rfindval ( `` Node Type '' , `` Sort '' ) ) > 0 '.rst ' : 'restructuredtext ' , `` host= '' `` Relation Name '' : str , `` Total Runtime '' : float , qep_analysis_with_constraint_exclusion = ( self.tok_pre_port + self.tok_port from pyte import Screen , Stream `` psql `` `` utf-8 '' ( Literal ( ' # ' ) | Literal ( ' > ' ) ) self.pg_name ) .get ( ) self.tok_pre_user + self.tok_user containing_where_start_offset = \ | ( # or continue \x1b [ ? .. list ( chain.from_iterable ( x.find ( pr , True ) for x in iter ( self ) ) ) psql._intercept ( b'SELECT ' ) conn=self.db_connection , constraint_exclusion=False [ `` \x1b [ ? 2004l\r order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n '' , `` \x1b [ ? 2004hpgdb= # `` ] `` - > '' , psql._intercept ( b '' \x1b [ ? 2004htest_db- # `` ) tok_pre_user : ParserElement = \ `` $ > '' , case_trivial = 'psql ( 14.5 ) \nType `` help '' for help.\n\npgdb= # SELECT * FROM orders ; ' and not has_onetime_filter_without_constraint_exclusion from pytest_postgresql import factories filter ( lambda x : isinstance ( x , exp.Binary ) , predicates ) self.warning_msg += `` \n '' Literal ( `` ? [ \x1b '' ) # in this case control code parameter db_connection : Connection ) : psql._intercept ( b '' \x1b [ ? 2004htest_db= # `` ) `` Planning Time '' : float , { `` Total Cost '' : float , ] from .errfmt import ErrorFormatter `` `` '' ) stmt = `` explain ( format json , analyze , verbose ) `` + \ `` ` pre-commit = `` black . & & isort -- profile black . '' columns tok_pre_host : ParserElement = \ SQL_OUTER_ORDER_WITHOUT_INNER_ORDER = \ ( a.type.precision is not None and self.pg_name , `` * * # '' , `` `` '' Alias for __call__ '' '' '' `` user= '' + self.pg_user self.tok_end results = [ `` - * # '' , `` - ! > '' , `` * ! > '' , `` \ ' ! > '' , `` \ '' ! > '' , `` $ ! > '' , `` ( ! > '' , This needs to be re-run each time the ` [ tool.githooks ] ` section is modified in the ` pyproject.toml ` file . SQL_NOT_NULL_CONSTRAINT_VIOLATION = f '' '' '' psql._intercept ( b '' \r\n\x1b [ ? 2004l\r '' ) case_select_then_insert = 'psql ( 14.5 ) \nType `` help '' for help.\n\npgdb= # SELECT * FROM orders ; \npgdb= # INSERT INTO orders VALUES ( 6 , 6 , 6 ) ; ' cur.execute ( `` Total Runtime '' : float , from pyparsing import Literal , ParseException , ParserElement , Word , identbodychars , nums results = [ `` '' , res_list [ 1 ] [ : :-1 ] + res_list [ 0 ] [ : :-1 ] ] deepcopy ( self.pyte_screen ) ) : match_select_stmt : ParserElement = ( lambda x , y : x + y [ : :-1 ] , results , `` '' `` $ * # '' , ) : SQL_WITHOUT_OUTER_ORDER = f '' '' '' def start ( self ) - > None : [ `` - # '' , `` * # '' , `` \ ' # '' , `` \ '' # '' , `` $ # '' , `` ( # '' , `` port= '' + self.pg_port b'\r\n\x1b [ ? 2004l\r ' qep_analysis_with_constraint_exclusion = \ `` psql ( 14.5 ) \nType \ '' help\ '' for help.\n\npgdb= # SELECT * FROM orders ; \npgdb= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; '' sql_query , psql._intercept ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 10\x1b [ 27m0 ; \x08\x08\x08\x08\x08\x08 '' ) def __init__ ( self , psql_args : str ) : def __init__ ( self , parsed_sql : exp.Expression , sql_statement : str , SQL_NO_IMPLIED_EXPRESSION = f '' '' '' Opt ( White ( ) ) reduce ( lambda x , y : x + y [ : :-1 ] , results , `` '' ) output : bytes match_select_stmt.parse_string ( no_newlines_res ) is not [ ] b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C1 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 1\x1b [ 27m00 ; \x08\x08\x08\x08\x08\x08 '' ( StringEnd ( ) # output may stop at end of db name , return_press_1 = b '' \r\n '' poetry run githooks setup ) `` \r\x1b [ 16Ppgdb= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_tot\x08\r\n\x1b [ ? 2004l\r '' `` - * > '' , `` * * > '' , `` \ ' * > '' , `` \ '' * > '' , `` $ * > '' , `` ( * > '' , cur.execute ( `` '' '' ' '' * # ' , `` navigation_depth '' : 3 , checker = ImpliedExpressionChecker ( parsed_sql , sql_statement , db_connection ) containing_where_start_offset = whole_statement.find ( containing_where ) has_implied_expression = \ def run_analysis ( self , sql_query : str ) - > str : SQL_MULTI_VARCHAR_SUSPICIOUS = f '' '' '' ) : b '' SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; '' tok_marker_caret dbname=getenv ( `` PGDBNAME '' , `` test_database '' ) ) Literal ( `` psql ( PostgreSQL ) `` ) def _detect_suspicious_cmp ( self , cmp : exp.Predicate , columns : list [ Column ] ) : has_implied_expression = ( == `` SELECT * FROM orders WHERE order_total_eur = 100 ; '' ' '' * > ' , `` ( ? > '' , from .config_values import ConfigValues def get ( psql._intercept ( b'FROM ' ) '' 'Alias for __call__ '' ' psql._intercept ( b'\x1b [ ? 2004l\r\x1b [ ? 1049h\x1b=\r order_id | order_total_eur | customer_id \x1b [ m\r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\x1b [ m\r\n 1 | 535.36 | 111\x1b [ m\r\n 2 | 409.80 | 217\x1b [ m\r\n 3 | 189.43 | 19\x1b [ m\r\n 4 | 144.14 | 157\x1b [ m\r\n 5 | 582.52 | 172\x1b [ m\r\n 6 | 132.85 | 206\x1b [ m\r\n 7 | 183.92 | 236\x1b [ m\r\n 8 | 424.80 | 244\x1b [ m\r\n 9 | 519.43 | 175\x1b [ m\r\n 10 | 414.55 | 234\x1b [ m\r\n 11 | 88.19 | 50\x1b [ m\r\n 12 | 591.72 | 143\x1b [ m\r\n 13 | 503.52 | 216\x1b [ m\r\n 14 | 586.06 | 181\x1b [ m\r\n 15 | 47.79 | 248\x1b [ m\r\n 16 | 330.92 | 130\x1b [ m\r\n 17 | 302.31 | 225\x1b [ m\r\n 18 | 438.38 | 26\x1b [ m\r\n 19 | 107.53 | 94\x1b [ m\r\n 20 | ' `` sql ( 14.5 ) \nType \ '' help\ '' for help.\n\npgdb= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n '' ) pexpect_conninfo = pexpect.spawn ( 'psql -c `` \\conninfo '' ' + psql_args ) `` One-Time Filter '' : str , [ Linters and formatters ] ( # linters-and-formatters ) psql._intercept ( case_query_2_prompt ) ] def find ( self , pr : Callable [ [ node ] , bool ] , ) `` * ! # '' , elif ( ( a.type.precision is None and tok_database : ParserElement = \ column_expression `` $ ! # '' , psql._intercept ( '\n'.join ( line.rstrip ( ) for line in self.pyte_screen.display ) assert p.parse_new_prompt_and_rest ( case_trivial ) == [ `` '' , `` \x1b [ ? 2004hpgdb= > `` ] tok_pre_user : ParserElement = Literal ( ' '' as user `` ' ) from psycopg import Connection 'sphinx.ext.autodoc ' , `` * ? > '' , `` ( ! > '' , `` $ # '' , == b '' \r\nTest\r\n\r\n\x1b [ ? 2004htest_db= # `` SQL_NO_IMPLIED_EXPRESSION = \ def _detect_suspicious_cmp ( self , cmp : exp.Predicate , `` * ! > '' , assert psql._intercept ( b'\x1b [ ? 2004htest_db= # ' ) == \ fresh_prompt_1 = \ SQL_MULTI_CMP_VALID = \ psql._intercept ( b '' SELECT '' ) `` $ ? # '' , parser : PsqlParser StringEnd ( ) psql._intercept ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C1 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 1\x1b [ 27m00 ; \x08\x08\x08\x08\x08\x08 '' ) import pexpect case_mixed_results = `` \x1b [ ? 2004l\r order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004hpgdb= # `` b'psql ( 14.5 ) \r\nType `` help '' for help.\r\n\r\n\x1b [ ? 2004hpgdb= # ' assert p.parse_last_stmt ( case_multiple_queries_and_whitespaces ) == \ ' '' ? > ' , psql._intercept ( b'\r\x1b [ K\x1b > \x1b [ r\x1b [ ? 1049l ' ) == b '' order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\r\nTest\r\n\r\n\x1b [ ? 2004htest_db= # `` magical_return_res = \ # # # Linting ' . ' `` Alias '' : str , self.tok_end import copy split_prompt [ 0 ] + `` \r\n '' + print_msg + `` \r\n\r\n '' + split_prompt [ 1 ] , `` utf-8 '' case_multiline_query = \ analysis_result : Optional [ str ] = \ b '' \x08order_total_eur = 0 AND order_total_eur = 10\x1b [ C\x1b [ 1P ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C '' templates_path = [ '_templates ' ] parsed_sql , sql_statement , db_connection ) assert p.parse_last_stmt ( case_trivial ) == \ match_version_stmt : ParserElement = ( cmp_column_name = \ case_long_return = `` \r\x1b [ 16Ppgdb= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_tot\x08\r\n\x1b [ ? 2004l\r '' `` Plan '' : node , match_psql_conninfo.parse_string ( conninfo_str ) .as_list ( ) `` Node Type '' : str , from .qepparser import QEPAnalysis , QEPParser SQL_MULTIPLE_INNER_ORDERS = f '' '' '' copyright = '2022 , Heikkilä et al ' case_query_with_newline = \ sql_parser.get_query_columns ( sanitized_sql ) from typing import Optional , Type , Any sql_parser Combine ( has_sort_node = len ( self.qep_analysis.root.rfindval ( `` Node Type '' , `` Sort '' ) ) > 0 self.pg_port `` Planning Time '' : float , `` Plan Width '' : int , tok_stmt_end [ Linting ] ( # linting ) magical_return_res = match_rev_magical_returns.parse_string ( psql_rev ) self.pg_name b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 10\x1b [ 27m0 ; \x08\x08\x08\x08\x08\x08 '' case_query_1 = ( 'navigation_depth ' : 3 , Column , psql._intercept ( b'\x1b [ ? 2004htest_db- # ' ) `` sphinx_autodoc_typehints '' , self config_values : Optional [ ConfigValues ] , column_expression ) results = [ ) - > None : `` ' * # '' , potential_future_screen_output_sink.feed ( bytes.decode ( latest_output ) ) [ [ package ] ] case_empirical_1 = \ self.pg_user columns : list [ Column ] = sql_parser.get_query_columns ( sanitized_sql ) bytes.decode ( latest_output ) def __init__ ( `` QEP '' , self.tok_port type_start_matcher = re.compile ( r'^ ( [ a-zA-Z ] + ) . * $ ' ) ) : from .qepparser import QEPAnalysis , QEPNode , QEPParser `` Plan Width '' : int , assert p.parse_last_stmt ( case_select_then_select ) == \ SQL_CHECK_CONSTRAINT_VIOLATION = f '' '' '' # # # Linters and formatters psql._intercept ( b'\x08\x08\x08\x08 ' ) syntax_error = \ QEPNode , `` psql ( 14.5 ) \nType \ '' help\ '' for help.\n\npgdb= # SELECT * FROM orders ; \npgdb= # INSERT INTO orders VALUES ( 6 , 6 , 6 ) ; \npgdb= # SELECT * FROM\n orders WHERE order_total_eur = 100 ; `` def _intercept ( self , output : bytes ) - > bytes : `` ( * > '' , psql._intercept ( b'\r\n\x1b [ ? 2004l\r ' ) QEPAnalysis , self , parsed_sql : exp.Expression , sql_statement : str , db_connection : Connection potential_future_screen_output_sink = Stream ( potential_future_screen ) case_mixed_results = \ dimensions= ( self.rows , self.cols ) b '' SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; '' None assert p.parse_last_stmt ( case_query_with_newline ) == \ psql._intercept ( b'\x08order_total_eur = 0 AND order_total_eur = 10\x1b [ C\x1b [ 1P ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) == `` SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; '' description = `` Simple git hooks with poetry '' `` - # '' , b '' order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\r\nTest\r\n\r\n\x1b [ ? 2004htest_db= # `` tok_stmt_end : ParserElement = Char ( `` ; '' ) potential_future_screen = \ `` Actual Rows '' : int , `` ' ? > '' , `` Index Name '' : str , `` password= '' psql._intercept ( b'\r\n\r\r\n ' ) self.parser.parse_syntax_error ( potential_future_contents ) psql._intercept ( b '' orders '' ) ' '' # ' , ) ... # has already been parsed as prompt_chars toml = `` > =0.10.2 , < 0.11.0 '' [ `` '' , `` \x1b [ ? 2004hpgdb= > `` ] exclude_patterns = [ `` build '' , `` Thumbs.db '' , `` .DS_Store '' ] fresh_prompt_1 = b '' \x1b [ ? 2004hpgdb= # `` elif ( a.type.precision is None and b.type.precision is not None ) or ( `` * ? # '' , version = `` 2.0.0 '' from .. qepparser import QEPParser from os import getenv for i , suspicious_cmp_context in enumerate ( self.suspicious_cmp_contexts ) : b ' 207.60 | 9\x1b [ m\r\n 21 | 471.12 | 179\x1b [ m\r\n : \x1b [ K ' ) `` Index Cond '' : str , `` sphinx.ext.viewcode '' , import sqlglot.expressions as exp from .config_reader import ConfigReader from shutil import get_terminal_size whole_statement [ total_start_offset : total_end_offset ] 'psql ( 14.5 ) \nType `` help '' for help.\n\npgdb= # SELECT * FROM\npgdb- # orders ; ' `` ( > '' , Literal ( `` ? [ \x1b '' ) # in this case control code parameter SQL_NESTED_SUBQUERY_INNER_ORDER = f '' '' '' content-hash = `` bda80eb1b1c7745b639f9a3f54a4078af57c5368d7e25dd2f5ae38751c10e3fd '' `` Plan '' , self.tok_rev_prompt_end | ( # or continue \x1b [ ? .. One can skip pre-commit hooks by running ` git commit ` with the ` -- no-verify ` flag . is_select = match_select_stmt.parse_string ( no_newlines_res ) is not [ ] } ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 250 , 367.56 , 214 ) ; '' '' '' from .sqlparser import ( category = `` dev '' from .. sqlparser import SqlParser lambda x : `` Test '' , psql._intercept ( b'SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; ' ) psql._intercept ( b'\r\x1b [ C ' ) total_start_offset = containing_where_start_offset + cmp_start_offset SQL_MULTI_CMP_VALID = f '' '' '' def start ( `` ' ! # '' , ... `` SELECT * FROM orders ; '' `` Index Cond '' : str , import sys from .config_reader import ConfigReader case_long_return = \ html_theme = `` sphinx_rtd_theme '' self.tok_pre_database return_press_3 = \ ZeroOrMore ( White ( ) ) results = [ stmt_res_list [ 3 ] , stmt_res_list [ 2 ] , stmt_res_list [ 1 ] ] bytes.decode ( output , `` utf-8 '' ) `` Actual Startup Time '' : float , p.parse_last_stmt ( case_select_then_select ) `` Filter '' : str , `` Execution Time '' : float , psql._intercept ( b '' \x08\x08\x08\x08 '' ) qep_analysis : QEPAnalysis = \ tok_host : ParserElement = \ from .. sqlparser import Column recursive=False ) - > list [ node ] : elif ( a.type.digits is None and b.type.digits is not None ) or ( Word ( nums ) + `` . '' + Word ( nums ) `` SELECT * FROM orders WHERE order_total_eur = 100 ; '' 'sphinx.ext.viewcode ' , `` - ? # '' , StringEnd ( ) # output may stop at end of db name , ' '' ! # ' , p.parse_last_stmt ( case_multiple_queries_and_whitespaces ) from .errfmt import ErrorFormatter screen : str = \ `` SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; '' qep_parser_with_constraint_exclusion = \ pexpect_conninfo = pexpect.spawn ( `` psql -c \ '' \\conninfo\ '' `` + psql_args ) tok_rev_error syntax_error = self.parser.parse_syntax_error ( potential_future_contents ) `` Plan '' : node , from .config_values import ConfigValues `` - > '' , `` * > '' , `` \ ' > '' , `` \ '' > '' , `` $ > '' , `` ( > '' , author = `` Heikkilä et al . '' { file = `` poetry-githooks-2.0.0.tar.gz '' , hash = `` sha256 : aa5a09159b479987d0426d6bd27df92d7252a901522436b42e5d74812d63eb2d '' } , from pyparsing import Literal , Word , ParseException , ParserElement , \ `` * * > '' , def __init__ ( qep_parser_with_constraint_exclusion = QEPParser ( if self.parser.output_has_magical_return ( bytes.decode ( output , `` utf-8 '' ) ) : assert psql._intercept ( fresh_prompt_1 ) == \ `` `` '' def _intercept ( assert p.parse_new_prompt_and_rest ( case_trivial ) == \ self.tok_pre_port psql._intercept ( b '' ; '' ) underlined_query = \ res_list [ 1 ] [ : :-1 ] + res_list [ 0 ] [ : :-1 ] psql._intercept ( b '' \x08\x08\x08= ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m=\x1b [ 27m 100 ; \x08\x08\x08\x08\x08\x08 '' ) results = [ stmt_res_list [ length - 3 ] , stmt_res_list [ length - 4 ] ] language = `` en '' copyright = `` 2022 , Heikkilä et al '' stmt_res_list [ 2 ] , from .. implied_expression_checker import ImpliedExpressionChecker Literal ( `` \ '' as user \ '' '' ) `` - ? > '' , dbname=getenv ( `` PGDBNAME '' , `` test_database '' ) , self , psql = PsqlWrapper ( `` '' , lambda x : `` Test '' , lambda x : `` '' , PsqlParser ( ) ) StringEnd ( ) poetry-githooks = [ ' '' ! > ' , from .sqlparser import SqlParser psql._intercept ( b '' \x1b [ ? 2004l\r\x1b [ ? 2004htest_db- # `` ) a.type.precision is not None and b.type.precision is None res_list [ 2 ] [ : :-1 ] + res_list [ 1 ] [ : :-1 ] + res_list [ 0 ] [ : :-1 ] self , select_statement : exp.Select , columns : list [ Column ] Opt ( Literal ( ' * ' ) | Literal ( ' ! ' ) | Literal ( ' ? ' ) , `` '' ) from .semanticrouter import SemanticRouter html_static_path = [ '_static ' ] from os import getenv from .. psqlparser import PsqlParser for i , suspicious_cmp_context in \ templates_path = [ `` _templates '' ] SQL_MULTI_VARCHAR_SUSPICIOUS = \ psql._intercept ( fresh_prompt_1 ) == b '' \r\n '' + b '' Test '' + b '' \r\n\r\n '' + b '' \x1b [ ? 2004hpgdb= # `` ) Literal ( `` \ '' on host \ '' '' ) | \ b.type.precision is not None ) or case_select_then_select = \ `` Total Cost '' : float , ) case_query_1 = \ node = TypedDict ( tok_user : ParserElement = Word ( identbodychars ) tok_port : ParserElement = \ def get ( self ) - > Optional [ Tuple [ str , str , str , str , str ] ] : `` \x1b [ ? 2004l\r order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004hpgdb= # `` ' '' > ' , `` Triggers '' : list [ str ] , filter ( lambda x : isinstance ( x , exp.Binary ) , predicates ) ) ] assert psql._intercept ( case_query_2_prompt ) == \ def _detect_suspicious_cmps ( from psycopg import Connection `` - ? > '' , `` * ? > '' , `` \ ' ? > '' , `` \ '' ? > '' , `` $ ? > '' , `` ( ? > '' ] if self.parser.output_has_new_prompt ( bytes.decode ( latest_output ) ) : `` - ! # '' , `` * ! # '' , `` \ ' ! # '' , `` \ '' ! # '' , `` $ ! # '' , `` ( ! # '' , Literal ( `` \ '' at port \ '' '' ) [ package.dependencies ] ( Literal ( '= ' ) | Literal ( '^ ' ) ) tok_port : ParserElement = Word ( nums ) assert p.parse_new_prompt_and_rest ( case_mixed_results ) == [ ( `` - ? # '' , `` * ? # '' , `` \ ' ? # '' , `` \ '' ? # '' , `` $ ? # '' , `` ( ? # '' , ... + tok_marker_caret + ... + tok_rev_error latest_output : bytes from .sqlparser import SqlParser , Column qep_parser_without_constraint_exclusion = QEPParser ( self.tok_rev_prompt_end Word ( identbodychars ) Stream ( potential_future_screen ) self.tok_pre_host + self.tok_host `` .md '' : `` markdown '' , Opt ( White ( ) ) self.tok_pre_user case_query_with_newline = 'sql ( 14.5 ) \nType `` help '' for help.\n\npgdb= # SELECT * FROM orders WHERE\norder_total_eur = 100 ; \n\n\n ' case_select_then_select = 'psql ( 14.5 ) \nType `` help '' for help.\n\npgdb= # SELECT * FROM orders ; \npgdb= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; ' exclude_patterns = [ 'build ' , 'Thumbs.db ' , '.DS_Store ' ] Word ( identbodychars + `` / . '' ) ) `` Plans '' : List [ `` node '' ] , SQL_SIMPLE = f '' '' '' ( Literal ( `` # '' ) | Literal ( `` > '' ) ) `` port= '' from typing import Any , Optional , Type `` dbname= '' ) - > Optional [ Tuple [ str , str , str , str , str ] ] : `` myst_parser '' , ZeroOrMore ( White ( ) ) + tok_stmt_end + ... + self.tok_rev_prompt_end has_onetime_filter_with_constraint_exclusion = \ psql._intercept ( b '' '\r ( reverse-i-search ) ` ' : `` ) `` $ ! > '' , Literal ( `` \ '' . '' ) python-versions = `` > =3.6.2 , < 4.0 '' `` \x1b [ ? 2004l\r order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n '' , from .. implied_expression_checker import ImpliedExpressionChecker analysis_result = CmpDomainChecker ( assert p.parse_last_stmt ( case_empirical_1 ) == \ psql._intercept ( b '' \x08\x08\x08\x08\x08\x08 '' ) SQL_VARCHAR_SUSPICIOUS = \ is_select = \ chain.from_iterable ( x.find ( pr , True ) for x in iter ( self ) ) lambda x , y : x + y , sys.argv [ 1 : ] , `` '' sanitized_sql , self.tok_user ( a.type.digits is not None and b.type.digits is None ) ) :","['README.md', 'docs/conf.py', 'poetry.lock', 'pyproject.toml', 'src/pg4n/cmp_domain_checker.py', 'src/pg4n/eq_wildcard_checker.py', 'src/pg4n/implied_expression_checker.py', 'src/pg4n/main.py', 'src/pg4n/psqlconninfo.py', 'src/pg4n/psqlparser.py', 'src/pg4n/psqlwrapper.py', 'src/pg4n/qepparser.py', 'src/pg4n/semanticrouter.py', 'src/pg4n/strange_having_checker.py', 'src/pg4n/subquery_order_by_checker.py', 'src/pg4n/subquery_select_checker.py', 'src/pg4n/sum_distinct_checker.py', 'src/pg4n/test/test_cmp_domain_checker.py', 'src/pg4n/test/test_config_parser.py', 'src/pg4n/test/test_implied_expression_checker.py', 'src/pg4n/test/test_psqlparser.py', 'src/pg4n/test/test_psqlwrapper.py', 'src/pg4n/test/test_qepparser.py', 'src/pg4n/test/test_subquery_order_by_checker.py', 'src/pg4n/test/test_subquery_select_checker.py']",2022-11-06 11:25:40+00:00,2022-12-22 10:07:51+00:00,2022-12-22 12:07:50+02:00
54,33120fdaf85b81b29fda0b164e51a4d43a477810,2.103286169585772e-05,1,"Upon push to ` main ` branch < sup > 1 < /sup > , we should - enact sensible versioning < sup > 2 < /sup > - only deploy versions that pass tests - have automatic formation of changelog - upload to PyPI , TestPyPI , or equivalent < sup > 3 < /sup > - have uploaded a version that an end user can install with a clean installation of Python 3.10+ , e.g . by running ` pip install pg4n ` or equivalent < sup > 4 < /sup > - as per good programming practices , ` pg4n -h ` or ` pg4n -- help ` should give info required to get pg4n running < sup > 1 < /sup > Alternative strategy : push only releases/tags ? < sup > 2 < /sup > Consider if a short git hash suffices , ` < major > . < minor > . < patch > ` might not be too feasible to enact automatically . < sup > 3 < /sup > Idea : upload GitHub releases to PyPI , and merges to ` main ` to TestPyPI ? This way we can test the end user installation experience in advance through TestPyPI . < sup > 4 < /sup > ~~Also look into whether we can bundle a PostgreSQL instance alongside pg4n.~~ Nay by customer . -- - In case more dev hours can be expended : distribute man pages ? https : //github.com/pypa/packaging-problems/issues/72",Incorporate automatic deployment into the CI/CD pipeline,Merge pull request # 85 from Project-C-SQL/feat/cd-publish,"publish : # ! /usr/bin/env bash You can bump the version number automatically with ` poetry version patch ` , ` poetry version minor ` , etc . See ` poetry version -h ` . echo -e `` \nPublishing to version ref ' $ ( poetry version -- short ) ' ... \n\n '' poetry publish -- no-interaction -- build -u $ PYPI_USER -p $ PYPI_PASS needs : pytest env : shell : bash poetry version $ ( poetry version -- short ) . $ GITHUB_RUN_NUMBER # Publish to PyPI runs-on : ubuntu-latest else PYPI_USER : __token__ with : version = `` 0.1.1 '' # ( requires a testpypi setup ) steps : # # # # Versioning if [ `` $ GITHUB_REF '' = `` refs/heads/main '' ] ; then version = `` 0.1.2 '' name : Wait For Other Pipelines GITHUB_TOKEN : $ { { secrets.GITHUB_TOKEN } } # based on : See version history [ here ] ( https : //pypi.org/project/pg4n/ # history ) . # in case collisions etc . occur run : | # https : //github.com/python-poetry/poetry/issues/3670 # issuecomment-776462445 fi # or use -- repository testpypi ? [ Versioning ] ( # versioning ) scripts/cd-publish.sh PYPI_PASS : $ { { secrets.PYPI_TOKEN } } uses : ./.github/actions/install # Run PyTest poetry version $ ( poetry version -- short ) -dev. $ GITHUB_RUN_NUMBER step-name : `` Wait For Other Pipelines '' runs-on : ubuntu-22.04","['.github/workflows/ci-cd.yml', '.github/workflows/grade.yml', '.github/workflows/pytest.yml', '.github/workflows/sphinx.yml', 'README.md', 'pyproject.toml', 'scripts/cd-publish.sh']",2022-11-07 12:32:45+00:00,2022-11-22 15:15:02+00:00,2022-11-22 17:15:00+02:00
55,4fa9eda88b8e6a94c4e6662a86f87da7bc41d060,1.1776913197536489e-05,1,,Detect subquery that does n't use its select columns ( e29 per Brass ),Merge pull request # 59 from Project-C-SQL/feat/implied-expression,"insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 221 , 487.39 , 227 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 13 , 'Marion ' , 'Penelli ' , ' B ' , 'Adaline ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 14 , 586.06 , 181 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 153 , 350.78 , 247 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 5 , 'Callida ' , 'Tomasello ' , ' B ' , 'Abiel ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 50 , 306.71 , 235 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 10 , 414.55 , 234 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 246 , 510.74 , 188 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 78 , 569.4 , 99 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 93 , 452.63 , 115 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 218 , 389.51 , 177 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 166 , 95.01 , 189 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 97 , 313.39 , 241 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 119 , 579.12 , 43 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 176 , 'Marylou ' , 'Guilloton ' , ' C ' , 'Bridget ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 23 , 'Jeanette ' , 'Fincher ' , ' B ' , 'Adriane ' ) ; return postgresql insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 132 , 'Olympe ' , 'Faber ' , ' B ' , 'Barbery ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 233 , 87.21 , 179 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 196 , 'Louisa ' , 'Matasov ' , ' B ' , 'Carmon ' ) ; return None insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 42 , 561.85 , 222 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 78 , 'Matilde ' , 'Froome ' , ' B ' , 'Angelica ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 159 , 281.36 , 198 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 20 , 207.6 , 9 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 216 , 388.15 , 142 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 4 , 144.14 , 157 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 192 , 206.39 , 151 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 24 , 538.88 , 38 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 77 , 'Maegan ' , 'Wheldon ' , ' C ' , 'Angela ' ) ; import pytest insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 82 , 106.39 , 237 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 29 , 'Dawna ' , 'Knipe ' , ' C ' , 'Alanson ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 242 , 356.69 , 244 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 210 , 332.45 , 47 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 63 , 'Gratia ' , 'Moss ' , ' B ' , 'Althea ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 187 , 'Donall ' , 'Casolla ' , ' B ' , 'Calvin ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 32 , 'Aubrie ' , 'Lockitt ' , ' C ' , 'Albert ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 176 , 22.8 , 175 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 245 , 327.9 , 212 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 169 , 'Elsbeth ' , 'Nucciotti ' , ' B ' , 'Bradley ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 37 , 'Talbot ' , 'Keddey ' , ' B ' , 'Aleva ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 237 , 293.23 , 140 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 229 , 89.34 , 147 ) ; len ( qep_analysis_without_constraint_exclusion.root.rfind ( finder ) ) > 0 import copy insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 56 , 'Kaitlin ' , 'Payle ' , ' B ' , 'Allyson ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 44 , 537.56 , 2 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 204 , 212.04 , 203 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 188 , 'Ferguson ' , 'Mackriell ' , ' B ' , 'Cameron ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 122 , 'Myrlene ' , 'Worcs ' , ' B ' , 'Augusta ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 183 , 'Harvey ' , 'Skinn ' , ' B ' , 'Caleb ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 226 , 212.04 , 28 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 201 , 411.07 , 202 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 46 , 362.72 , 240 ) ; SQL_SIMPLE = \ order_id INT insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 242 , 'Brenden ' , 'Simmons ' , ' B ' , 'Clarence ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 52 , 'Gerrilee ' , 'Ackland ' , ' B ' , 'Allan ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 119 , 'Gregg ' , 'Lazenbury ' , ' B ' , 'Aubrey ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 171 , 'Fredrick ' , 'Matuszynski ' , ' C ' , 'Breanna ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 137 , 'Lucilia ' , 'Bentick ' , ' C ' , 'Bartholomew ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 11 , 88.19 , 50 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 162 , 'Jessee ' , 'List ' , ' B ' , 'Billy ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 14 , 'Davon ' , 'Burris ' , ' C ' , 'Addison ' ) ; , order_total_eur DECIMAL ( 6,2 ) NOT NULL insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 32 , 331.93 , 144 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 83 , 'Wolf ' , 'Brenton ' , ' B ' , 'Annette ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 246 , 'Albert ' , 'Heimann ' , ' B ' , 'Cleatus ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 189 , 164.91 , 68 ) ; sql_statement = SQL_CHECK_CONSTRAINT_VIOLATION insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 240 , 384.87 , 107 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 144 , 504.73 , 154 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 127 , 'Rhoda ' , 'Kurton ' , ' C ' , 'Avarilla ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 28 , 'Nanice ' , 'MacMaster ' , ' B ' , 'Alan ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 151 , 221.16 , 212 ) ; sql_statement = SQL_NOT_NULL_CONSTRAINT_VIOLATION insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 148 , 203.36 , 180 ) ; QEPParser ( conn=self.db_connection , constraint_exclusion=False ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 169 , 552.88 , 241 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 57 , 'Vita ' , 'Dunnett ' , ' B ' , 'Allyssa ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 214 , 'Chalmers ' , 'Britton ' , ' C ' , 'Celinda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 70 , 596.2 , 221 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 12 , 'Tiffi ' , 'Riolfo ' , ' C ' , 'Ada ' ) ; WHERE type = ' A ' ; '' '' '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 173 , 'Kristopher ' , 'Mackelworth ' , ' B ' , 'Brenda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 7 , 183.92 , 236 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 219 , 594.84 , 121 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 130 , 'Rora ' , 'Adcock ' , ' C ' , 'Babs ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 162 , 168.92 , 27 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 89 , 556.68 , 74 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 183 , 546.08 , 88 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 118 , 23.96 , 195 ) ; if constraint_exclusion : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 18 , 'Odie ' , 'Rowling ' , ' C ' , 'Adele ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 30 , 'Colin ' , 'Jansie ' , ' C ' , 'Alastair ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 177 , 'Genvieve ' , 'Marthen ' , ' B ' , 'Brittany ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 150 , 439.75 , 18 ) ; import psycopg insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 102 , 'Ricca ' , 'Rupprecht ' , ' B ' , 'Arlene ' ) ; `` One-Time Filter '' : str , insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 227 , 189.25 , 230 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 206 , 226.62 , 228 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 186 , 561.85 , 156 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 1 , 535.36 , 111 ) ; FROM { CUSTOMERS_TABLE_NAME } insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 212 , 179.55 , 180 ) ; parsed_sql , sql_statement , db_connection ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 103 , 14.83 , 183 ) ; def test_check ( sql_parser : SqlParser , db_connection : Connection ) : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 171 , 175.72 , 249 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 128 , 'Jere ' , 'Cometti ' , ' B ' , 'Azariah ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 137 , 417.16 , 215 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 10 , 'Sonnie ' , 'Kelling ' , ' B ' , 'Abram ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 140 , 'Suki ' , 'Flinn ' , ' B ' , 'Bea ' ) ; SELECT * insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 104 , 97.04 , 11 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 115 , 351.68 , 153 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 30 , 435.57 , 105 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 208 , 344.91 , 150 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 239 , 327.06 , 34 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 91 , 'Bobby ' , 'Fortesquieu ' , ' B ' , 'Aquilla ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 121 , 'Clywd ' , 'Stokey ' , ' B ' , 'August ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 28 , 87.44 , 1 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 8 , 424.8 , 244 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 109 , 170.82 , 206 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 181 , 150.37 , 69 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 64 , 'Dyan ' , 'Crosbie ' , ' B ' , 'Alverta ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 194 , 328.76 , 41 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 121 , 132.25 , 50 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 123 , 'Lyon ' , 'Nolleau ' , ' C ' , 'Augustina ' ) ; cur.execute ( `` set constraint_exclusion = on ; '' ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 248 , 321.97 , 195 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 201 , 'Arv ' , 'Spawforth ' , ' B ' , 'Carrie ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 221 , 'Cassondra ' , 'Mattingson ' , ' B ' , 'Chesley ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 96 , 'Tiertza ' , 'Bunford ' , ' C ' , 'Archibald ' ) ; ORDERS_TABLE_NAME = `` implied_expression_test_table_orders '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 202 , 'Sonja ' , 'Pentycross ' , ' B ' , 'Carthaette ' ) ; has_onetime_filter_without_constraint_exclusion = \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 234 , 'Cayla ' , 'Statter ' , ' B ' , 'Christopher ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 146 , 'Dunstan ' , 'Cressey ' , ' B ' , 'Bella ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 240 , 'Britte ' , 'Muge ' , ' B ' , 'Clara ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 156 , 'Allistir ' , 'Frary ' , ' C ' , 'Beth ' ) ; qep_parser_with_constraint_exclusion.parse ( self.sql_statement ) SQL_NO_IMPLIED_EXPRESSION = \ insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 88 , 210.95 , 158 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 117 , 'Marysa ' , 'Wadman ' , ' C ' , 'Asenath ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 133 , 'Clementia ' , 'Fergusson ' , ' B ' , 'Barbie ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 237 , 'Jeramie ' , 'Gallehock ' , ' C ' , 'Cinderella ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 161 , 184.39 , 94 ) ; len ( qep_analysis_with_constraint_exclusion.root.rfind ( finder ) ) > 0 insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 130 , 575.58 , 235 ) ; SqlParser , insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 178 , 'Rogers ' , 'Plose ' , ' B ' , 'Brittney ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 42 , 'Pyotr ' , 'Feldhorn ' , ' C ' , 'Alexis ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 209 , 'Dulcea ' , 'Akister ' , ' C ' , 'Cathleen ' ) ; CREATE TABLE { CUSTOMERS_TABLE_NAME } ( insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 66 , 454.41 , 11 ) ; assert warning_msg ! = None insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 23 , 236.48 , 51 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 41 , 158.78 , 145 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 43 , 133.73 , 196 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 59 , 'Lin ' , 'Race ' , ' B ' , 'Almina ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 182 , 478.47 , 70 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 54 , 591.44 , 145 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 79 , 94.87 , 194 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 128 , 415.86 , 243 ) ; QEPParser , insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 160 , 'Patti ' , 'Louis ' , ' C ' , 'Biddie ' ) ; def finder ( node : QEPNode ) - > bool : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 166 , 'Angelo ' , 'Vanstone ' , ' C ' , 'Boetius ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 98 , 'Elfreda ' , 'Tome ' , ' C ' , 'Ariadne ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 136 , 411.87 , 10 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 157 , 477.53 , 205 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 15 , 47.79 , 248 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 77 , 335.23 , 149 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 57 , 349.14 , 58 ) ; sql_statement = SQL_NO_IMPLIED_EXPRESSION insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 87 , 'Nanette ' , 'McElwee ' , ' B ' , 'Antoinette ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 48 , 'Marve ' , 'Eykel ' , ' C ' , 'Alicia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 61 , 'Blisse ' , 'Dillway ' , ' C ' , 'Alonzo ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 167 , 547.07 , 197 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 45 , 'Seymour ' , 'Mayer ' , ' B ' , 'Alfreda ' ) ; qep_parser_without_constraint_exclusion.parse ( self.sql_statement ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 112 , 38.97 , 239 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 223 , 'Annice ' , 'Haynes ' , ' B ' , 'Chet ' ) ; QEPParser ( conn=self.db_connection , constraint_exclusion=True ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 24 , 'Jacinthe ' , 'Kleeman ' , ' B ' , 'Adrienne ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 62 , 418.98 , 60 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 27 , 137.86 , 21 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 170 , 539.11 , 92 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 67 , 550.21 , 63 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 181 , 'Daria ' , 'Wistance ' , ' C ' , 'Caitlyn ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 26 , 590.52 , 50 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 170 , 'Bard ' , 'Shaw ' , ' C ' , 'Brady ' ) ; self.sql_statement : str = sql_statement ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 45 , 46.05 , 177 ) ; conn : Connection = psycopg.connect ( * * kwargs ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 49 , 376.9 , 89 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 19 , 107.53 , 94 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 92 , 'Raven ' , 'Eilles ' , ' C ' , 'Ara ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 139 , 'Kelsi ' , 'Suddell ' , ' C ' , 'Bazaleel ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 141 , 'Jacinta ' , 'Villiers ' , ' B ' , 'Beatrice ' ) ; class ImpliedExpressionChecker : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 234 , 254.56 , 98 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 48 , 199.52 , 234 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 68 , 73.27 , 189 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 245 , 'Holly ' , 'Roy ' , ' C ' , 'Claudia ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 232 , 330.85 , 204 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 99 , 'Phineas ' , 'Yuryaev ' , ' B ' , 'Arielle ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 114 , 339.9 , 108 ) ; assert checker ! = None insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 142 , 509.25 , 190 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 213 , 'Rubin ' , 'Lunney ' , ' B ' , 'Celeste ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 41 , 'Reilly ' , 'Kennler ' , ' B ' , 'Alexandria ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 76 , 'Ardys ' , 'Currm ' , ' B ' , 'Andriane ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 202 , 99.52 , 171 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 159 , 'Carilyn ' , 'Vinecombe ' , ' B ' , 'Bezaleel ' ) ; DROP TABLE IF EXISTS { ORDERS_TABLE_NAME } ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 75 , 238.65 , 203 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 39 , 42.62 , 95 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 129 , 'Ashla ' , 'De-Ville ' , ' C ' , 'Bab ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 82 , 'Abey ' , 'Darridon ' , ' C ' , 'Anne ' ) ; Returns warning_msg if implied expression is detected , otherwise None . insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 248 , 'Norby ' , 'Biernacki ' , ' C ' , 'Clementine ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 22 , 'Grazia ' , 'Syne ' , ' C ' , 'Adrian ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 153 , 'Alfy ' , 'McCahill ' , ' B ' , 'Bertha ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 214 , 520.52 , 98 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 63 , 542.48 , 52 ) ; customer_id INT insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 17 , 'Carlyle ' , 'Zimek ' , ' B ' , 'Adelbert ' ) ; return SqlParser ( db_connection=postgresql ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 165 , 84.61 , 1 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 142 , 'Elfrieda ' , 'Cleary ' , ' C ' , 'Becca ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 154 , 'Conney ' , 'Riteley ' , ' C ' , 'Bertram ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 180 , 'Leonelle ' , 'Chiommienti ' , ' B ' , 'Caitlin ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 61 , 343.91 , 223 ) ; f '' '' '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 224 , 'Dayle ' , 'Eirwin ' , ' B ' , 'Chick ' ) ; with conn.cursor ( ) as cur : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 190 , 'Kara ' , 'Backs ' , ' B ' , 'Campbell ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 220 , 'Kylen ' , 'Bewicke ' , ' B ' , 'Cheryl ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 113 , 305.06 , 123 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 2 , 'Tomlin ' , 'Nozzolinii ' , ' B ' , 'Abbigail ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 31 , 394.48 , 62 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 141 , 183.27 , 44 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 89 , 'Nickie ' , 'Bloss ' , ' C ' , 'Antonio ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 243 , 209.34 , 31 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 157 , 'Noach ' , 'MacRitchie ' , ' C ' , 'Bethena ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 191 , 'Frankie ' , 'Canny ' , ' B ' , 'Candace ' ) ; from pytest_postgresql import factories Column , , fname VARCHAR ( 50 ) NOT NULL insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 11 , 'Amby ' , 'Ligoe ' , ' C ' , 'Absalom ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 185 , 505.7 , 49 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 250 , 'Langston ' , 'Prosser ' , ' C ' , 'Clifford ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 126 , 'Lilllie ' , 'Annis ' , ' C ' , 'Aurelia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 51 , 'Kennan ' , 'Burstowe ' , ' B ' , 'Alixandra ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 3 , 189.43 , 19 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 163 , 'Gerhardt ' , 'Simcock ' , ' B ' , 'Blanche ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 188 , 495.68 , 39 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 123 , 370.87 , 115 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 74 , 63.02 , 117 ) ; factory = factories.postgresql_proc ( insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 191 , 183.55 , 142 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 116 , 292.86 , 97 ) ; db_connection : Connection ) : checker = ImpliedExpressionChecker ( parsed_sql = sql_parser.parse_one ( sql_statement ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 71 , 'Cynthie ' , 'Rouby ' , ' B ' , 'Anastasia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 47 , 'Tracey ' , 'Sauvan ' , ' B ' , 'Alice ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 129 , 426.3 , 136 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 131 , 255.66 , 127 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 233 , 'Tibold ' , 'Sleigh ' , ' C ' , 'Christoph ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 249 , 'Rhoda ' , 'Leheude ' , ' C ' , 'Cliff ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 146 , 184.13 , 22 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 16 , 330.92 , 130 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 65 , 'Glenna ' , 'Alastair ' , ' C ' , 'Alyssa ' ) ; cur.execute ( insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 225 , 'Egbert ' , 'Vasyunin ' , ' B ' , 'Chloe ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 197 , 'Missie ' , 'Fealty ' , ' C ' , 'Carol ' ) ; from .. sqlparser import SqlParser insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 25 , 83.54 , 79 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 84 , 'Birk ' , 'Malling ' , ' C ' , 'Annie ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 122 , 406.1 , 80 ) ; qep_parser_without_constraint_exclusion = \ with self._conn.cursor ( ) as cur : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 213 , 329.78 , 105 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 86 , 'Lauren ' , 'Tolworth ' , ' B ' , 'Anthony ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 90 , 169.25 , 30 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 103 , 'Ede ' , 'Golden of Ireland ' , ' C ' , 'Armanda ' ) ; CUSTOMERS_TABLE_NAME = `` implied_expression_orderby_test_table_customers '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 37 , 322.11 , 41 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 79 , 'Preston ' , 'Groves ' , ' B ' , 'Angelina ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 179 , 453.95 , 43 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 200 , 592.16 , 137 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 139 , 441.16 , 97 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 124 , 'Penelope ' , 'Quadling ' , ' C ' , 'Augustine ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 209 , 203.86 , 244 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 124 , 552.02 , 191 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 212 , 'Annecorinne ' , 'Soles ' , ' B ' , 'Cedric ' ) ; qep_analysis_with_constraint_exclusion = \ insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 56 , 501.06 , 129 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 90 , 'Forest ' , 'Trim ' , ' B ' , 'Appoline ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 134 , 'Georgetta ' , 'Crossley ' , ' B ' , 'Barnabas ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 168 , 'Melicent ' , 'Cheston ' , ' B ' , 'Bradford ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 227 , 'Jeralee ' , 'Atwill ' , ' C ' , 'Christa ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 152 , 'Towny ' , 'Middell ' , ' B ' , 'Bert ' ) ; def load_database ( * * kwargs ) : def sql_parser ( postgresql : Connection ) : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 62 , 'Seline ' , 'McGray ' , ' B ' , 'Alphinias ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 70 , 'Carmela ' , 'Sedgeworth ' , ' C ' , 'Amos ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 148 , 'Lidia ' , 'Quinane ' , ' C ' , 'Benjamin ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 243 , 'Hannah ' , 'Mattheis ' , ' C ' , 'Clarinda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 241 , 296.03 , 169 ) ; SELECT ( 1 , 2 , 3 ) ; '' '' '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 69 , 266.3 , 39 ) ; ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 238 , 'Gregor ' , 'Crinion ' , ' B ' , 'Cindy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 117 , 23.13 , 46 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 85 , 'Brig ' , 'Triswell ' , ' C ' , 'Anselm ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 109 , 'Marquita ' , 'Impy ' , ' B ' , 'Aron ' ) ; CREATE TABLE { ORDERS_TABLE_NAME } ( insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 132 , 488.95 , 234 ) ; , type CHAR ( 1 ) NOT NULL insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 84 , 396.02 , 111 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 87 , 441.16 , 191 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 229 , 'Melessa ' , 'MacAleese ' , ' C ' , 'Christiana ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 231 , 51.77 , 118 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 19 , 'Daphne ' , 'Bullen ' , ' B ' , 'Adeline ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 134 , 296.72 , 222 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 133 , 499.73 , 235 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 204 , 'Cassy ' , 'Pearcehouse ' , ' C ' , 'Casper ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 17 , 302.31 , 225 ) ; f '' '' '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 195 , 'Dewey ' , 'Bottom ' , ' C ' , 'Carmelo ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 80 , 'Petey ' , 'Colloby ' , ' B ' , 'Ann ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 180 , 452.67 , 234 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 140 , 297.41 , 101 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 228 , 'Rudd ' , 'Ames ' , ' B ' , 'Christian ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 238 , 448.86 , 16 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 172 , 'Pammi ' , 'Codling ' , ' B ' , 'Breeanna ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 199 , 376.5 , 53 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 110 , 'Donall ' , 'Labrenz ' , ' B ' , 'Artelepsa ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 250 , 367.56 , 214 ) ; '' '' '' ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 111 , 'Torey ' , 'Sessuns ' , ' B ' , 'Artemus ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 25 , 'Neely ' , 'Merrydew ' , ' B ' , 'Agatha ' ) ; SQL_NOT_NULL_CONSTRAINT_VIOLATION = \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 244 , 'Katrine ' , 'Janiak ' , ' B ' , 'Clarissa ' ) ; def db_connection ( postgresql : Connection ) : warning_msg = checker.check ( ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 195 , 504.28 , 117 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 131 , 'Ive ' , 'Matches ' , ' B ' , 'Barbara ' ) ; WHERE sname > fname ; '' '' '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 161 , 'Barron ' , 'Dishmon ' , ' B ' , 'Bill ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 12 , 591.72 , 143 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 55 , 'Terrill ' , 'Syde ' , ' B ' , 'Allison ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 187 , 271.52 , 242 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 222 , 416.65 , 59 ) ; from psycopg import Connection insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 100 , 424.83 , 50 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 241 , 'Sigismund ' , 'Mowsdill ' , ' B ' , 'Clare ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 193 , 449.91 , 213 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 210 , 'Pamelina ' , 'Vittery ' , ' C ' , 'Cathy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 178 , 563.08 , 161 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 156 , 130.63 , 188 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 126 , 384.61 , 226 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 106 , 'Merrily ' , 'Coundley ' , ' C ' , 'Arminda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 196 , 259.0 , 244 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 192 , 'Dudley ' , 'Vesco ' , ' B ' , 'Carlotta ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 113 , 'Dania ' , 'Foxton ' , ' C ' , 'Arthusa ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 211 , 399.2 , 138 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 98 , 177.22 , 86 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 247 , 'Dulcie ' , 'Crutchley ' , ' B ' , 'Clement ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 164 , 'Abel ' , 'Bezants ' , ' C ' , 'Bob ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 154 , 291.52 , 54 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 35 , 389.81 , 218 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 164 , 193.39 , 169 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 21 , 'Nady ' , 'Lempertz ' , ' B ' , 'Adolphus ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 244 , 273.35 , 153 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 215 , 'Nollie ' , 'Jemmett ' , ' B ' , 'Charity ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 95 , 'Amandie ' , 'Botham ' , ' B ' , 'Araminta ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 27 , 'Callean ' , 'Werlock ' , ' C ' , 'Aileen ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 172 , 15.3 , 30 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 105 , 'Cary ' , 'Sells ' , ' C ' , 'Armilda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 13 , 503.52 , 216 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 136 , 'Aretha ' , 'Arias ' , ' C ' , 'Bart ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 3 , 'Christen ' , 'Culley ' , ' C ' , 'Abednego ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 135 , 'Janenna ' , 'McCamish ' , ' C ' , 'Barney ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 15 , 'Zachary ' , 'Faloon ' , ' C ' , 'Adela ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 102 , 158.53 , 220 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 71 , 175.29 , 115 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 93 , 'Sashenka ' , 'Fedorski ' , ' C ' , 'Arabella ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 198 , 120.47 , 95 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 152 , 291.54 , 10 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 106 , 236.57 , 4 ) ; with self._conn.cursor ( ) as cur : conn.commit ( ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 92 , 156.72 , 192 ) ; print ( warning_msg ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 76 , 281.92 , 183 ) ; SQL_CHECK_CONSTRAINT_VIOLATION = \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 107 , 'Celisse ' , 'Rubra ' , ' B ' , 'Arminta ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 34 , 'Lorens ' , 'Buzin ' , ' C ' , 'Aldo ' ) ; self.parsed_sql : exp.Expression = parsed_sql self._conn.commit ( ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 116 , 'Annmarie ' , 'Errichelli ' , ' B ' , 'Asaph ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 115 , 'Shirl ' , 'Pilpovic ' , ' C ' , 'Asahel ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 225 , 26.43 , 228 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 46 , 'Mechelle ' , 'Vinick ' , ' B ' , 'Algernon ' ) ; CHECK ( type IN ( ' C ' , ' B ' ) ) -- C = customer , B = business insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 38 , 'Web ' , 'Catterill ' , ' B ' , 'Alex ' ) ; warning_msg = `` Warning : Found impossible comparison due to column/table constraints [ pg4n : :ImpliedExpression ] '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 224 , 293.35 , 186 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 54 , 'Malchy ' , 'Hearty ' , ' B ' , 'Allisandra ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 217 , 'Lucy ' , 'Durtnell ' , ' C ' , 'Charlie ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 94 , 'Halimeda ' , 'Freak ' , ' B ' , 'Arabelle ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 9 , 519.43 , 175 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 230 , 'Cordell ' , 'Bineham ' , ' B ' , 'Christiano ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 75 , 'Erma ' , 'Cranstone ' , ' B ' , 'Andrew ' ) ; DROP TABLE IF EXISTS { CUSTOMERS_TABLE_NAME } ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 184 , 380.46 , 98 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 68 , 'Leisha ' , 'Darlington ' , ' C ' , 'Ambrose ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 219 , 'Adriane ' , 'Ccomini ' , ' B ' , 'Chauncey ' ) ; , sname VARCHAR ( 50 ) NOT NULL insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 59 , 141.8 , 118 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 236 , 'Garnette ' , 'Tabrett ' , ' C ' , 'Cicely ' ) ; , FOREIGN KEY ( customer_id ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 43 , 'Belle ' , 'Barsham ' , ' B ' , 'Alfonse ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 145 , 'Adena ' , 'Wenham ' , ' C ' , 'Belinda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 197 , 529.63 , 46 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 39 , 'Tabbie ' , 'Glison ' , ' B ' , 'Alexander ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 33 , 140.92 , 236 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 29 , 217.18 , 124 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 80 , 17.1 , 21 ) ; if not has_implied_expression : self.db_connection : Connection = db_connection insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 96 , 311.78 , 173 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 185 , 'Tanitansy ' , 'Headington ' , ' C ' , 'Calista ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 120 , 'Corinna ' , 'Pyburn ' , ' B ' , 'Audrey ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 33 , 'Amble ' , 'Jewes ' , ' B ' , 'Alberta ' ) ; , nickname VARCHAR ( 20 ) NOT NULL insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 165 , 'Angele ' , 'Wildbore ' , ' C ' , 'Bobby ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 108 , 'Janene ' , 'Motten ' , ' C ' , 'Arnold ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 107 , 23.63 , 179 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 168 , 137.02 , 109 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 6 , 'Daisey ' , 'Hamill ' , ' B ' , 'Abigail ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 167 , 'Ninnette ' , 'Steere ' , ' C ' , 'Brad ' ) ; has_onetime_filter_with_constraint_exclusion = \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 69 , 'Maryjo ' , 'Pink ' , ' C ' , 'Amelia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 50 , 'Anne-marie ' , 'Mounsie ' , ' B ' , 'Alison ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 151 , 'Prentiss ' , 'Filby ' , ' B ' , 'Berney ' ) ; return node.get ( `` One-Time Filter '' ) ! = None insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 231 , 'Calhoun ' , 'BoHlingolsen ' , ' C ' , 'Christina ' ) ; SELECT customer_id , fname , sname insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 49 , 'Theodosia ' , 'Rosson ' , ' B ' , 'Aline ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 220 , 367.15 , 163 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 99 , 354.37 , 66 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 51 , 244.27 , 119 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 158 , 'Anett ' , 'Hercules ' , ' B ' , 'Beverly ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 26 , 'Jenica ' , 'Martina ' , ' C ' , 'Agnes ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 175 , 161.61 , 58 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 72 , 539.87 , 62 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 203 , 545.33 , 116 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 21 , 471.12 , 179 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 138 , 223.81 , 183 ) ; qep_parser_with_constraint_exclusion = \ insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 40 , 33.89 , 23 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 101 , 'Hamilton ' , 'Pellew ' , ' B ' , 'Arizona ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 88 , 'Sansone ' , 'Copsey ' , ' C ' , 'Antonia ' ) ; from .sqlparser import ( cur.execute ( `` set constraint_exclusion = off ; '' ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 111 , 490.85 , 191 ) ; import sqlglot.expressions as exp insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 232 , 'Maritsa ' , 'Cowpland ' , ' C ' , 'Christine ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 163 , 61.42 , 69 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 247 , 123.55 , 179 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 60 , 'Sibyl ' , 'Thoms ' , ' C ' , 'Almira ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 236 , 485.18 , 167 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 83 , 451.45 , 203 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 193 , 'Brucie ' , 'Coning ' , ' C ' , 'Carlton ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 228 , 542.3 , 42 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 127 , 451.77 , 17 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 120 , 454.18 , 214 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 174 , 'Carolyn ' , 'Quinlan ' , ' C ' , 'Brian ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 199 , 'Matilda ' , 'Malenoir ' , ' C ' , 'Caroline ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 179 , 'Daphne ' , 'Kells ' , ' C ' , 'Broderick ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 9 , 'Lester ' , 'Markus ' , ' C ' , 'Abraham ' ) ; postgresql = factories.postgresql ( `` factory '' ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 143 , 239.98 , 109 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 53 , 592.15 , 207 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 7 , 'Lorin ' , 'Dollimore ' , ' C ' , 'Abijah ' ) ; , customer_id INT NOT NULL insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 55 , 391.93 , 128 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 1 , 'Josi ' , 'Grimsell ' , ' B ' , 'Aaron ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 175 , 'Davy ' , 'Blomefield ' , ' B ' , 'Brianna ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 118 , 'Hermy ' , 'Whieldon ' , ' B ' , 'Ashley ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 44 , 'Buffy ' , ' O '' Cridigan ' , ' B ' , 'Alfred ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 177 , 334.0 , 167 ) ; def check ( self ) - > Optional [ str ] : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 86 , 537.64 , 201 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 85 , 404.96 , 79 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 53 , 'Riva ' , 'Scawen ' , ' C ' , 'Allen ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 249 , 491.05 , 63 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 105 , 107.29 , 12 ) ; from typing import Optional insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 223 , 200.44 , 47 ) ; assert warning_msg == None insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 73 , 144.33 , 52 ) ; , PRIMARY KEY ( customer_id ) from .qepparser import ( insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 74 , 'Giffy ' , 'Cottee ' , ' C ' , 'Andrea ' ) ; , PRIMARY KEY ( order_id ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 207 , 'Elise ' , 'Kamenar ' , ' C ' , 'Caswell ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 155 , 274.14 , 151 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 215 , 515.79 , 96 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 22 , 193.12 , 6 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 150 , 'Agnesse ' , 'Liebmann ' , ' B ' , 'Bernard ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 104 , 'Timofei ' , 'Grene ' , ' B ' , 'Armena ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 160 , 144.6 , 82 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 8 , 'Gasparo ' , 'Bohlje ' , ' C ' , 'Abner ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 60 , 473.05 , 208 ) ; cur.execute ( `` set constraint_exclusion = on ; '' ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 58 , 'Lettie ' , 'Coffin ' , ' B ' , 'Almena ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 125 , 'Leo ' , 'Creaney ' , ' B ' , 'Augustus ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 190 , 401.19 , 88 ) ; `` `` '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 108 , 294.25 , 131 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 110 , 144.28 , 59 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 144 , 'Ange ' , 'Pasterfield ' , ' C ' , 'Bedelia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 138 , 'Ainsley ' , 'Wraighte ' , ' C ' , 'Barticus ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 147 , 180.39 , 2 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 58 , 10.24 , 74 ) ; has_onetime_filter_with_constraint_exclusion and \ qep_analysis_without_constraint_exclusion = \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 203 , 'Rory ' , 'Hallatt ' , ' C ' , 'Casey ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 216 , 'Elsbeth ' , 'MacGaughie ' , ' B ' , 'Charles ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 149 , 340.62 , 215 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 186 , 'Chloette ' , 'Ratt ' , ' B ' , 'Calpurnia ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 174 , 597.34 , 184 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 184 , 'Louise ' , 'Jansey ' , ' C ' , 'California ' ) ; def __init__ ( self , * args , conn=None , constraint_exclusion=True , * * kwargs ) : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 189 , 'Merle ' , 'Erridge ' , ' C ' , 'Camille ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 2 , 409.8 , 217 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 158 , 65.82 , 201 ) ; sql_statement = SQL_SIMPLE else : QEPNode , insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 198 , 'Kellby ' , 'Threlfall ' , ' C ' , 'Carolann ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 101 , 328.66 , 189 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 239 , 'Atalanta ' , 'Girdler ' , ' C ' , 'Claire ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 217 , 302.24 , 189 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 230 , 389.39 , 247 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 143 , 'Sasha ' , 'Eunson ' , ' C ' , 'Beck ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 235 , 230.72 , 168 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 95 , 367.31 , 48 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 36 , 225.6 , 136 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 208 , 'Legra ' , 'Drought ' , ' C ' , 'Catherine ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 100 , 'Gypsy ' , 'Bottrell ' , ' C ' , 'Aristotle ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 206 , 'Ardyth ' , 'Conningham ' , ' B ' , 'Cassidy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 94 , 406.59 , 129 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 194 , 'Corilla ' , 'Aldwinckle ' , ' C ' , 'Carmellia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 81 , 'Sharline ' , 'Rosenwald ' , ' B ' , 'Anna ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 6 , 132.85 , 206 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 235 , 'Justus ' , 'Barthrup ' , ' B ' , 'Christy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 135 , 574.1 , 222 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 205 , 'Orlan ' , 'Kynder ' , ' C ' , 'Cassandra ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 147 , 'Wilmer ' , 'MacWhan ' , ' B ' , 'Benedict ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 47 , 163.79 , 141 ) ; REFERENCES { CUSTOMERS_TABLE_NAME } ( customer_id ) def __init__ ( self , * args , conn=None , * * kwargs ) : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 52 , 81.47 , 212 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 205 , 508.59 , 59 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 5 , 582.52 , 172 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 211 , 'Jobi ' , 'Bails ' , ' B ' , 'Cecilia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 40 , 'Olva ' , 'Leborgne ' , ' C ' , 'Alexandra ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 114 , 'Fara ' , 'Arkil ' , ' B ' , 'Arzada ' ) ; self._conn.commit ( ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 149 , 'Erik ' , 'Cushe ' , ' B ' , 'Benjy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 64 , 534.3 , 108 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 66 , 'Sadella ' , 'Boxhall ' , ' B ' , 'Alzada ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 4 , 'Nancey ' , 'Fawlkes ' , ' C ' , 'Abel ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 125 , 170.66 , 131 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 38 , 366.31 , 59 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 72 , 'Nadiya ' , 'Gingles ' , ' B ' , 'Anderson ' ) ; QEPAnalysis , insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 35 , 'Lainey ' , 'Davidow ' , ' C ' , 'Aldrich ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 226 , 'Emelina ' , 'Ayliff ' , ' B ' , 'Chris ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 145 , 112.51 , 162 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 34 , 64.76 , 13 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 20 , 'Robbi ' , ' O '' Caherny ' , ' B ' , 'Adelphia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 36 , 'Bendite ' , 'Morfett ' , ' B ' , 'Aleksandr ' ) ; def __init__ ( self , parsed_sql : exp.Expression , sql_statement : str , insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 73 , 'Seymour ' , 'Maffioletti ' , ' B ' , 'Andre ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 16 , 'Augustin ' , 'Blaxall ' , ' C ' , 'Adelaide ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 155 , 'Murdock ' , 'Dix ' , ' C ' , 'Bess ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 207 , 205.25 , 199 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 173 , 297.4 , 85 ) ; load= [ load_database ] , insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 18 , 438.38 , 26 ) ; has_implied_expression = \ WHERE sname IS NULL ; '' '' '' from .. implied_expression_checker import ImpliedExpressionChecker insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 65 , 318.64 , 6 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 91 , 331.76 , 115 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 200 , 'Fanni ' , 'Iacopetti ' , ' C ' , 'Carolyn ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 67 , 'Zsazsa ' , 'Bellocht ' , ' C ' , 'Amanda ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 97 , 'Germain ' , 'Haly ' , ' B ' , 'Archilles ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 222 , 'Hazel ' , 'Rushforth ' , ' C ' , 'Chester ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 81 , 490.65 , 41 ) ; return warning_msg insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 218 , 'Raffarty ' , 'Sweeney ' , ' C ' , 'Charlotte ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 182 , 'Sasha ' , 'Stiffkins ' , ' C ' , 'Caldonia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 31 , 'Dario ' , 'Siehard ' , ' C ' , 'Alazama ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 112 , 'Nanci ' , 'Byrd ' , ' C ' , 'Arthur ' ) ; not has_onetime_filter_without_constraint_exclusion","['src/pg4n/implied_expression_checker.py', 'src/pg4n/qepparser.py', 'src/pg4n/test/test_implied_expression_checker.py']",2022-11-07 18:54:47+00:00,2022-11-08 08:07:17+00:00,2022-11-08 10:09:32+02:00
56,4fa9eda88b8e6a94c4e6662a86f87da7bc41d060,1.1750191333703697e-05,1,,Detect subquery condition that can be moved to the `` parent '' query ( e30 per Brass ),Merge pull request # 59 from Project-C-SQL/feat/implied-expression,"insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 221 , 487.39 , 227 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 13 , 'Marion ' , 'Penelli ' , ' B ' , 'Adaline ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 14 , 586.06 , 181 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 153 , 350.78 , 247 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 5 , 'Callida ' , 'Tomasello ' , ' B ' , 'Abiel ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 50 , 306.71 , 235 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 10 , 414.55 , 234 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 246 , 510.74 , 188 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 78 , 569.4 , 99 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 93 , 452.63 , 115 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 218 , 389.51 , 177 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 166 , 95.01 , 189 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 97 , 313.39 , 241 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 119 , 579.12 , 43 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 176 , 'Marylou ' , 'Guilloton ' , ' C ' , 'Bridget ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 23 , 'Jeanette ' , 'Fincher ' , ' B ' , 'Adriane ' ) ; return postgresql insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 132 , 'Olympe ' , 'Faber ' , ' B ' , 'Barbery ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 233 , 87.21 , 179 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 196 , 'Louisa ' , 'Matasov ' , ' B ' , 'Carmon ' ) ; return None insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 42 , 561.85 , 222 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 78 , 'Matilde ' , 'Froome ' , ' B ' , 'Angelica ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 159 , 281.36 , 198 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 20 , 207.6 , 9 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 216 , 388.15 , 142 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 4 , 144.14 , 157 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 192 , 206.39 , 151 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 24 , 538.88 , 38 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 77 , 'Maegan ' , 'Wheldon ' , ' C ' , 'Angela ' ) ; import pytest insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 82 , 106.39 , 237 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 29 , 'Dawna ' , 'Knipe ' , ' C ' , 'Alanson ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 242 , 356.69 , 244 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 210 , 332.45 , 47 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 63 , 'Gratia ' , 'Moss ' , ' B ' , 'Althea ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 187 , 'Donall ' , 'Casolla ' , ' B ' , 'Calvin ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 32 , 'Aubrie ' , 'Lockitt ' , ' C ' , 'Albert ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 176 , 22.8 , 175 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 245 , 327.9 , 212 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 169 , 'Elsbeth ' , 'Nucciotti ' , ' B ' , 'Bradley ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 37 , 'Talbot ' , 'Keddey ' , ' B ' , 'Aleva ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 237 , 293.23 , 140 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 229 , 89.34 , 147 ) ; len ( qep_analysis_without_constraint_exclusion.root.rfind ( finder ) ) > 0 import copy insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 56 , 'Kaitlin ' , 'Payle ' , ' B ' , 'Allyson ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 44 , 537.56 , 2 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 204 , 212.04 , 203 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 188 , 'Ferguson ' , 'Mackriell ' , ' B ' , 'Cameron ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 122 , 'Myrlene ' , 'Worcs ' , ' B ' , 'Augusta ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 183 , 'Harvey ' , 'Skinn ' , ' B ' , 'Caleb ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 226 , 212.04 , 28 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 201 , 411.07 , 202 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 46 , 362.72 , 240 ) ; SQL_SIMPLE = \ order_id INT insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 242 , 'Brenden ' , 'Simmons ' , ' B ' , 'Clarence ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 52 , 'Gerrilee ' , 'Ackland ' , ' B ' , 'Allan ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 119 , 'Gregg ' , 'Lazenbury ' , ' B ' , 'Aubrey ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 171 , 'Fredrick ' , 'Matuszynski ' , ' C ' , 'Breanna ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 137 , 'Lucilia ' , 'Bentick ' , ' C ' , 'Bartholomew ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 11 , 88.19 , 50 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 162 , 'Jessee ' , 'List ' , ' B ' , 'Billy ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 14 , 'Davon ' , 'Burris ' , ' C ' , 'Addison ' ) ; , order_total_eur DECIMAL ( 6,2 ) NOT NULL insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 32 , 331.93 , 144 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 83 , 'Wolf ' , 'Brenton ' , ' B ' , 'Annette ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 246 , 'Albert ' , 'Heimann ' , ' B ' , 'Cleatus ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 189 , 164.91 , 68 ) ; sql_statement = SQL_CHECK_CONSTRAINT_VIOLATION insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 240 , 384.87 , 107 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 144 , 504.73 , 154 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 127 , 'Rhoda ' , 'Kurton ' , ' C ' , 'Avarilla ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 28 , 'Nanice ' , 'MacMaster ' , ' B ' , 'Alan ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 151 , 221.16 , 212 ) ; sql_statement = SQL_NOT_NULL_CONSTRAINT_VIOLATION insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 148 , 203.36 , 180 ) ; QEPParser ( conn=self.db_connection , constraint_exclusion=False ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 169 , 552.88 , 241 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 57 , 'Vita ' , 'Dunnett ' , ' B ' , 'Allyssa ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 214 , 'Chalmers ' , 'Britton ' , ' C ' , 'Celinda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 70 , 596.2 , 221 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 12 , 'Tiffi ' , 'Riolfo ' , ' C ' , 'Ada ' ) ; WHERE type = ' A ' ; '' '' '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 173 , 'Kristopher ' , 'Mackelworth ' , ' B ' , 'Brenda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 7 , 183.92 , 236 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 219 , 594.84 , 121 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 130 , 'Rora ' , 'Adcock ' , ' C ' , 'Babs ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 162 , 168.92 , 27 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 89 , 556.68 , 74 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 183 , 546.08 , 88 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 118 , 23.96 , 195 ) ; if constraint_exclusion : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 18 , 'Odie ' , 'Rowling ' , ' C ' , 'Adele ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 30 , 'Colin ' , 'Jansie ' , ' C ' , 'Alastair ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 177 , 'Genvieve ' , 'Marthen ' , ' B ' , 'Brittany ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 150 , 439.75 , 18 ) ; import psycopg insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 102 , 'Ricca ' , 'Rupprecht ' , ' B ' , 'Arlene ' ) ; `` One-Time Filter '' : str , insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 227 , 189.25 , 230 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 206 , 226.62 , 228 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 186 , 561.85 , 156 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 1 , 535.36 , 111 ) ; FROM { CUSTOMERS_TABLE_NAME } insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 212 , 179.55 , 180 ) ; parsed_sql , sql_statement , db_connection ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 103 , 14.83 , 183 ) ; def test_check ( sql_parser : SqlParser , db_connection : Connection ) : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 171 , 175.72 , 249 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 128 , 'Jere ' , 'Cometti ' , ' B ' , 'Azariah ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 137 , 417.16 , 215 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 10 , 'Sonnie ' , 'Kelling ' , ' B ' , 'Abram ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 140 , 'Suki ' , 'Flinn ' , ' B ' , 'Bea ' ) ; SELECT * insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 104 , 97.04 , 11 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 115 , 351.68 , 153 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 30 , 435.57 , 105 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 208 , 344.91 , 150 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 239 , 327.06 , 34 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 91 , 'Bobby ' , 'Fortesquieu ' , ' B ' , 'Aquilla ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 121 , 'Clywd ' , 'Stokey ' , ' B ' , 'August ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 28 , 87.44 , 1 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 8 , 424.8 , 244 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 109 , 170.82 , 206 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 181 , 150.37 , 69 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 64 , 'Dyan ' , 'Crosbie ' , ' B ' , 'Alverta ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 194 , 328.76 , 41 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 121 , 132.25 , 50 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 123 , 'Lyon ' , 'Nolleau ' , ' C ' , 'Augustina ' ) ; cur.execute ( `` set constraint_exclusion = on ; '' ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 248 , 321.97 , 195 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 201 , 'Arv ' , 'Spawforth ' , ' B ' , 'Carrie ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 221 , 'Cassondra ' , 'Mattingson ' , ' B ' , 'Chesley ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 96 , 'Tiertza ' , 'Bunford ' , ' C ' , 'Archibald ' ) ; ORDERS_TABLE_NAME = `` implied_expression_test_table_orders '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 202 , 'Sonja ' , 'Pentycross ' , ' B ' , 'Carthaette ' ) ; has_onetime_filter_without_constraint_exclusion = \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 234 , 'Cayla ' , 'Statter ' , ' B ' , 'Christopher ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 146 , 'Dunstan ' , 'Cressey ' , ' B ' , 'Bella ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 240 , 'Britte ' , 'Muge ' , ' B ' , 'Clara ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 156 , 'Allistir ' , 'Frary ' , ' C ' , 'Beth ' ) ; qep_parser_with_constraint_exclusion.parse ( self.sql_statement ) SQL_NO_IMPLIED_EXPRESSION = \ insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 88 , 210.95 , 158 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 117 , 'Marysa ' , 'Wadman ' , ' C ' , 'Asenath ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 133 , 'Clementia ' , 'Fergusson ' , ' B ' , 'Barbie ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 237 , 'Jeramie ' , 'Gallehock ' , ' C ' , 'Cinderella ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 161 , 184.39 , 94 ) ; len ( qep_analysis_with_constraint_exclusion.root.rfind ( finder ) ) > 0 insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 130 , 575.58 , 235 ) ; SqlParser , insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 178 , 'Rogers ' , 'Plose ' , ' B ' , 'Brittney ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 42 , 'Pyotr ' , 'Feldhorn ' , ' C ' , 'Alexis ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 209 , 'Dulcea ' , 'Akister ' , ' C ' , 'Cathleen ' ) ; CREATE TABLE { CUSTOMERS_TABLE_NAME } ( insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 66 , 454.41 , 11 ) ; assert warning_msg ! = None insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 23 , 236.48 , 51 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 41 , 158.78 , 145 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 43 , 133.73 , 196 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 59 , 'Lin ' , 'Race ' , ' B ' , 'Almina ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 182 , 478.47 , 70 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 54 , 591.44 , 145 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 79 , 94.87 , 194 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 128 , 415.86 , 243 ) ; QEPParser , insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 160 , 'Patti ' , 'Louis ' , ' C ' , 'Biddie ' ) ; def finder ( node : QEPNode ) - > bool : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 166 , 'Angelo ' , 'Vanstone ' , ' C ' , 'Boetius ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 98 , 'Elfreda ' , 'Tome ' , ' C ' , 'Ariadne ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 136 , 411.87 , 10 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 157 , 477.53 , 205 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 15 , 47.79 , 248 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 77 , 335.23 , 149 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 57 , 349.14 , 58 ) ; sql_statement = SQL_NO_IMPLIED_EXPRESSION insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 87 , 'Nanette ' , 'McElwee ' , ' B ' , 'Antoinette ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 48 , 'Marve ' , 'Eykel ' , ' C ' , 'Alicia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 61 , 'Blisse ' , 'Dillway ' , ' C ' , 'Alonzo ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 167 , 547.07 , 197 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 45 , 'Seymour ' , 'Mayer ' , ' B ' , 'Alfreda ' ) ; qep_parser_without_constraint_exclusion.parse ( self.sql_statement ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 112 , 38.97 , 239 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 223 , 'Annice ' , 'Haynes ' , ' B ' , 'Chet ' ) ; QEPParser ( conn=self.db_connection , constraint_exclusion=True ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 24 , 'Jacinthe ' , 'Kleeman ' , ' B ' , 'Adrienne ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 62 , 418.98 , 60 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 27 , 137.86 , 21 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 170 , 539.11 , 92 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 67 , 550.21 , 63 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 181 , 'Daria ' , 'Wistance ' , ' C ' , 'Caitlyn ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 26 , 590.52 , 50 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 170 , 'Bard ' , 'Shaw ' , ' C ' , 'Brady ' ) ; self.sql_statement : str = sql_statement ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 45 , 46.05 , 177 ) ; conn : Connection = psycopg.connect ( * * kwargs ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 49 , 376.9 , 89 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 19 , 107.53 , 94 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 92 , 'Raven ' , 'Eilles ' , ' C ' , 'Ara ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 139 , 'Kelsi ' , 'Suddell ' , ' C ' , 'Bazaleel ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 141 , 'Jacinta ' , 'Villiers ' , ' B ' , 'Beatrice ' ) ; class ImpliedExpressionChecker : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 234 , 254.56 , 98 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 48 , 199.52 , 234 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 68 , 73.27 , 189 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 245 , 'Holly ' , 'Roy ' , ' C ' , 'Claudia ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 232 , 330.85 , 204 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 99 , 'Phineas ' , 'Yuryaev ' , ' B ' , 'Arielle ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 114 , 339.9 , 108 ) ; assert checker ! = None insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 142 , 509.25 , 190 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 213 , 'Rubin ' , 'Lunney ' , ' B ' , 'Celeste ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 41 , 'Reilly ' , 'Kennler ' , ' B ' , 'Alexandria ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 76 , 'Ardys ' , 'Currm ' , ' B ' , 'Andriane ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 202 , 99.52 , 171 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 159 , 'Carilyn ' , 'Vinecombe ' , ' B ' , 'Bezaleel ' ) ; DROP TABLE IF EXISTS { ORDERS_TABLE_NAME } ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 75 , 238.65 , 203 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 39 , 42.62 , 95 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 129 , 'Ashla ' , 'De-Ville ' , ' C ' , 'Bab ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 82 , 'Abey ' , 'Darridon ' , ' C ' , 'Anne ' ) ; Returns warning_msg if implied expression is detected , otherwise None . insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 248 , 'Norby ' , 'Biernacki ' , ' C ' , 'Clementine ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 22 , 'Grazia ' , 'Syne ' , ' C ' , 'Adrian ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 153 , 'Alfy ' , 'McCahill ' , ' B ' , 'Bertha ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 214 , 520.52 , 98 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 63 , 542.48 , 52 ) ; customer_id INT insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 17 , 'Carlyle ' , 'Zimek ' , ' B ' , 'Adelbert ' ) ; return SqlParser ( db_connection=postgresql ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 165 , 84.61 , 1 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 142 , 'Elfrieda ' , 'Cleary ' , ' C ' , 'Becca ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 154 , 'Conney ' , 'Riteley ' , ' C ' , 'Bertram ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 180 , 'Leonelle ' , 'Chiommienti ' , ' B ' , 'Caitlin ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 61 , 343.91 , 223 ) ; f '' '' '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 224 , 'Dayle ' , 'Eirwin ' , ' B ' , 'Chick ' ) ; with conn.cursor ( ) as cur : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 190 , 'Kara ' , 'Backs ' , ' B ' , 'Campbell ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 220 , 'Kylen ' , 'Bewicke ' , ' B ' , 'Cheryl ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 113 , 305.06 , 123 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 2 , 'Tomlin ' , 'Nozzolinii ' , ' B ' , 'Abbigail ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 31 , 394.48 , 62 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 141 , 183.27 , 44 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 89 , 'Nickie ' , 'Bloss ' , ' C ' , 'Antonio ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 243 , 209.34 , 31 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 157 , 'Noach ' , 'MacRitchie ' , ' C ' , 'Bethena ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 191 , 'Frankie ' , 'Canny ' , ' B ' , 'Candace ' ) ; from pytest_postgresql import factories Column , , fname VARCHAR ( 50 ) NOT NULL insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 11 , 'Amby ' , 'Ligoe ' , ' C ' , 'Absalom ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 185 , 505.7 , 49 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 250 , 'Langston ' , 'Prosser ' , ' C ' , 'Clifford ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 126 , 'Lilllie ' , 'Annis ' , ' C ' , 'Aurelia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 51 , 'Kennan ' , 'Burstowe ' , ' B ' , 'Alixandra ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 3 , 189.43 , 19 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 163 , 'Gerhardt ' , 'Simcock ' , ' B ' , 'Blanche ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 188 , 495.68 , 39 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 123 , 370.87 , 115 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 74 , 63.02 , 117 ) ; factory = factories.postgresql_proc ( insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 191 , 183.55 , 142 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 116 , 292.86 , 97 ) ; db_connection : Connection ) : checker = ImpliedExpressionChecker ( parsed_sql = sql_parser.parse_one ( sql_statement ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 71 , 'Cynthie ' , 'Rouby ' , ' B ' , 'Anastasia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 47 , 'Tracey ' , 'Sauvan ' , ' B ' , 'Alice ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 129 , 426.3 , 136 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 131 , 255.66 , 127 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 233 , 'Tibold ' , 'Sleigh ' , ' C ' , 'Christoph ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 249 , 'Rhoda ' , 'Leheude ' , ' C ' , 'Cliff ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 146 , 184.13 , 22 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 16 , 330.92 , 130 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 65 , 'Glenna ' , 'Alastair ' , ' C ' , 'Alyssa ' ) ; cur.execute ( insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 225 , 'Egbert ' , 'Vasyunin ' , ' B ' , 'Chloe ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 197 , 'Missie ' , 'Fealty ' , ' C ' , 'Carol ' ) ; from .. sqlparser import SqlParser insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 25 , 83.54 , 79 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 84 , 'Birk ' , 'Malling ' , ' C ' , 'Annie ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 122 , 406.1 , 80 ) ; qep_parser_without_constraint_exclusion = \ with self._conn.cursor ( ) as cur : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 213 , 329.78 , 105 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 86 , 'Lauren ' , 'Tolworth ' , ' B ' , 'Anthony ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 90 , 169.25 , 30 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 103 , 'Ede ' , 'Golden of Ireland ' , ' C ' , 'Armanda ' ) ; CUSTOMERS_TABLE_NAME = `` implied_expression_orderby_test_table_customers '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 37 , 322.11 , 41 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 79 , 'Preston ' , 'Groves ' , ' B ' , 'Angelina ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 179 , 453.95 , 43 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 200 , 592.16 , 137 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 139 , 441.16 , 97 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 124 , 'Penelope ' , 'Quadling ' , ' C ' , 'Augustine ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 209 , 203.86 , 244 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 124 , 552.02 , 191 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 212 , 'Annecorinne ' , 'Soles ' , ' B ' , 'Cedric ' ) ; qep_analysis_with_constraint_exclusion = \ insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 56 , 501.06 , 129 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 90 , 'Forest ' , 'Trim ' , ' B ' , 'Appoline ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 134 , 'Georgetta ' , 'Crossley ' , ' B ' , 'Barnabas ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 168 , 'Melicent ' , 'Cheston ' , ' B ' , 'Bradford ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 227 , 'Jeralee ' , 'Atwill ' , ' C ' , 'Christa ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 152 , 'Towny ' , 'Middell ' , ' B ' , 'Bert ' ) ; def load_database ( * * kwargs ) : def sql_parser ( postgresql : Connection ) : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 62 , 'Seline ' , 'McGray ' , ' B ' , 'Alphinias ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 70 , 'Carmela ' , 'Sedgeworth ' , ' C ' , 'Amos ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 148 , 'Lidia ' , 'Quinane ' , ' C ' , 'Benjamin ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 243 , 'Hannah ' , 'Mattheis ' , ' C ' , 'Clarinda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 241 , 296.03 , 169 ) ; SELECT ( 1 , 2 , 3 ) ; '' '' '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 69 , 266.3 , 39 ) ; ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 238 , 'Gregor ' , 'Crinion ' , ' B ' , 'Cindy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 117 , 23.13 , 46 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 85 , 'Brig ' , 'Triswell ' , ' C ' , 'Anselm ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 109 , 'Marquita ' , 'Impy ' , ' B ' , 'Aron ' ) ; CREATE TABLE { ORDERS_TABLE_NAME } ( insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 132 , 488.95 , 234 ) ; , type CHAR ( 1 ) NOT NULL insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 84 , 396.02 , 111 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 87 , 441.16 , 191 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 229 , 'Melessa ' , 'MacAleese ' , ' C ' , 'Christiana ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 231 , 51.77 , 118 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 19 , 'Daphne ' , 'Bullen ' , ' B ' , 'Adeline ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 134 , 296.72 , 222 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 133 , 499.73 , 235 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 204 , 'Cassy ' , 'Pearcehouse ' , ' C ' , 'Casper ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 17 , 302.31 , 225 ) ; f '' '' '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 195 , 'Dewey ' , 'Bottom ' , ' C ' , 'Carmelo ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 80 , 'Petey ' , 'Colloby ' , ' B ' , 'Ann ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 180 , 452.67 , 234 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 140 , 297.41 , 101 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 228 , 'Rudd ' , 'Ames ' , ' B ' , 'Christian ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 238 , 448.86 , 16 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 172 , 'Pammi ' , 'Codling ' , ' B ' , 'Breeanna ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 199 , 376.5 , 53 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 110 , 'Donall ' , 'Labrenz ' , ' B ' , 'Artelepsa ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 250 , 367.56 , 214 ) ; '' '' '' ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 111 , 'Torey ' , 'Sessuns ' , ' B ' , 'Artemus ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 25 , 'Neely ' , 'Merrydew ' , ' B ' , 'Agatha ' ) ; SQL_NOT_NULL_CONSTRAINT_VIOLATION = \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 244 , 'Katrine ' , 'Janiak ' , ' B ' , 'Clarissa ' ) ; def db_connection ( postgresql : Connection ) : warning_msg = checker.check ( ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 195 , 504.28 , 117 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 131 , 'Ive ' , 'Matches ' , ' B ' , 'Barbara ' ) ; WHERE sname > fname ; '' '' '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 161 , 'Barron ' , 'Dishmon ' , ' B ' , 'Bill ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 12 , 591.72 , 143 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 55 , 'Terrill ' , 'Syde ' , ' B ' , 'Allison ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 187 , 271.52 , 242 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 222 , 416.65 , 59 ) ; from psycopg import Connection insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 100 , 424.83 , 50 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 241 , 'Sigismund ' , 'Mowsdill ' , ' B ' , 'Clare ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 193 , 449.91 , 213 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 210 , 'Pamelina ' , 'Vittery ' , ' C ' , 'Cathy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 178 , 563.08 , 161 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 156 , 130.63 , 188 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 126 , 384.61 , 226 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 106 , 'Merrily ' , 'Coundley ' , ' C ' , 'Arminda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 196 , 259.0 , 244 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 192 , 'Dudley ' , 'Vesco ' , ' B ' , 'Carlotta ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 113 , 'Dania ' , 'Foxton ' , ' C ' , 'Arthusa ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 211 , 399.2 , 138 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 98 , 177.22 , 86 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 247 , 'Dulcie ' , 'Crutchley ' , ' B ' , 'Clement ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 164 , 'Abel ' , 'Bezants ' , ' C ' , 'Bob ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 154 , 291.52 , 54 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 35 , 389.81 , 218 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 164 , 193.39 , 169 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 21 , 'Nady ' , 'Lempertz ' , ' B ' , 'Adolphus ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 244 , 273.35 , 153 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 215 , 'Nollie ' , 'Jemmett ' , ' B ' , 'Charity ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 95 , 'Amandie ' , 'Botham ' , ' B ' , 'Araminta ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 27 , 'Callean ' , 'Werlock ' , ' C ' , 'Aileen ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 172 , 15.3 , 30 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 105 , 'Cary ' , 'Sells ' , ' C ' , 'Armilda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 13 , 503.52 , 216 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 136 , 'Aretha ' , 'Arias ' , ' C ' , 'Bart ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 3 , 'Christen ' , 'Culley ' , ' C ' , 'Abednego ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 135 , 'Janenna ' , 'McCamish ' , ' C ' , 'Barney ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 15 , 'Zachary ' , 'Faloon ' , ' C ' , 'Adela ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 102 , 158.53 , 220 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 71 , 175.29 , 115 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 93 , 'Sashenka ' , 'Fedorski ' , ' C ' , 'Arabella ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 198 , 120.47 , 95 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 152 , 291.54 , 10 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 106 , 236.57 , 4 ) ; with self._conn.cursor ( ) as cur : conn.commit ( ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 92 , 156.72 , 192 ) ; print ( warning_msg ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 76 , 281.92 , 183 ) ; SQL_CHECK_CONSTRAINT_VIOLATION = \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 107 , 'Celisse ' , 'Rubra ' , ' B ' , 'Arminta ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 34 , 'Lorens ' , 'Buzin ' , ' C ' , 'Aldo ' ) ; self.parsed_sql : exp.Expression = parsed_sql self._conn.commit ( ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 116 , 'Annmarie ' , 'Errichelli ' , ' B ' , 'Asaph ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 115 , 'Shirl ' , 'Pilpovic ' , ' C ' , 'Asahel ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 225 , 26.43 , 228 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 46 , 'Mechelle ' , 'Vinick ' , ' B ' , 'Algernon ' ) ; CHECK ( type IN ( ' C ' , ' B ' ) ) -- C = customer , B = business insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 38 , 'Web ' , 'Catterill ' , ' B ' , 'Alex ' ) ; warning_msg = `` Warning : Found impossible comparison due to column/table constraints [ pg4n : :ImpliedExpression ] '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 224 , 293.35 , 186 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 54 , 'Malchy ' , 'Hearty ' , ' B ' , 'Allisandra ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 217 , 'Lucy ' , 'Durtnell ' , ' C ' , 'Charlie ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 94 , 'Halimeda ' , 'Freak ' , ' B ' , 'Arabelle ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 9 , 519.43 , 175 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 230 , 'Cordell ' , 'Bineham ' , ' B ' , 'Christiano ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 75 , 'Erma ' , 'Cranstone ' , ' B ' , 'Andrew ' ) ; DROP TABLE IF EXISTS { CUSTOMERS_TABLE_NAME } ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 184 , 380.46 , 98 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 68 , 'Leisha ' , 'Darlington ' , ' C ' , 'Ambrose ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 219 , 'Adriane ' , 'Ccomini ' , ' B ' , 'Chauncey ' ) ; , sname VARCHAR ( 50 ) NOT NULL insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 59 , 141.8 , 118 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 236 , 'Garnette ' , 'Tabrett ' , ' C ' , 'Cicely ' ) ; , FOREIGN KEY ( customer_id ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 43 , 'Belle ' , 'Barsham ' , ' B ' , 'Alfonse ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 145 , 'Adena ' , 'Wenham ' , ' C ' , 'Belinda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 197 , 529.63 , 46 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 39 , 'Tabbie ' , 'Glison ' , ' B ' , 'Alexander ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 33 , 140.92 , 236 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 29 , 217.18 , 124 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 80 , 17.1 , 21 ) ; if not has_implied_expression : self.db_connection : Connection = db_connection insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 96 , 311.78 , 173 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 185 , 'Tanitansy ' , 'Headington ' , ' C ' , 'Calista ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 120 , 'Corinna ' , 'Pyburn ' , ' B ' , 'Audrey ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 33 , 'Amble ' , 'Jewes ' , ' B ' , 'Alberta ' ) ; , nickname VARCHAR ( 20 ) NOT NULL insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 165 , 'Angele ' , 'Wildbore ' , ' C ' , 'Bobby ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 108 , 'Janene ' , 'Motten ' , ' C ' , 'Arnold ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 107 , 23.63 , 179 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 168 , 137.02 , 109 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 6 , 'Daisey ' , 'Hamill ' , ' B ' , 'Abigail ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 167 , 'Ninnette ' , 'Steere ' , ' C ' , 'Brad ' ) ; has_onetime_filter_with_constraint_exclusion = \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 69 , 'Maryjo ' , 'Pink ' , ' C ' , 'Amelia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 50 , 'Anne-marie ' , 'Mounsie ' , ' B ' , 'Alison ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 151 , 'Prentiss ' , 'Filby ' , ' B ' , 'Berney ' ) ; return node.get ( `` One-Time Filter '' ) ! = None insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 231 , 'Calhoun ' , 'BoHlingolsen ' , ' C ' , 'Christina ' ) ; SELECT customer_id , fname , sname insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 49 , 'Theodosia ' , 'Rosson ' , ' B ' , 'Aline ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 220 , 367.15 , 163 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 99 , 354.37 , 66 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 51 , 244.27 , 119 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 158 , 'Anett ' , 'Hercules ' , ' B ' , 'Beverly ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 26 , 'Jenica ' , 'Martina ' , ' C ' , 'Agnes ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 175 , 161.61 , 58 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 72 , 539.87 , 62 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 203 , 545.33 , 116 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 21 , 471.12 , 179 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 138 , 223.81 , 183 ) ; qep_parser_with_constraint_exclusion = \ insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 40 , 33.89 , 23 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 101 , 'Hamilton ' , 'Pellew ' , ' B ' , 'Arizona ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 88 , 'Sansone ' , 'Copsey ' , ' C ' , 'Antonia ' ) ; from .sqlparser import ( cur.execute ( `` set constraint_exclusion = off ; '' ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 111 , 490.85 , 191 ) ; import sqlglot.expressions as exp insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 232 , 'Maritsa ' , 'Cowpland ' , ' C ' , 'Christine ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 163 , 61.42 , 69 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 247 , 123.55 , 179 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 60 , 'Sibyl ' , 'Thoms ' , ' C ' , 'Almira ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 236 , 485.18 , 167 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 83 , 451.45 , 203 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 193 , 'Brucie ' , 'Coning ' , ' C ' , 'Carlton ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 228 , 542.3 , 42 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 127 , 451.77 , 17 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 120 , 454.18 , 214 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 174 , 'Carolyn ' , 'Quinlan ' , ' C ' , 'Brian ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 199 , 'Matilda ' , 'Malenoir ' , ' C ' , 'Caroline ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 179 , 'Daphne ' , 'Kells ' , ' C ' , 'Broderick ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 9 , 'Lester ' , 'Markus ' , ' C ' , 'Abraham ' ) ; postgresql = factories.postgresql ( `` factory '' ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 143 , 239.98 , 109 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 53 , 592.15 , 207 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 7 , 'Lorin ' , 'Dollimore ' , ' C ' , 'Abijah ' ) ; , customer_id INT NOT NULL insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 55 , 391.93 , 128 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 1 , 'Josi ' , 'Grimsell ' , ' B ' , 'Aaron ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 175 , 'Davy ' , 'Blomefield ' , ' B ' , 'Brianna ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 118 , 'Hermy ' , 'Whieldon ' , ' B ' , 'Ashley ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 44 , 'Buffy ' , ' O '' Cridigan ' , ' B ' , 'Alfred ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 177 , 334.0 , 167 ) ; def check ( self ) - > Optional [ str ] : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 86 , 537.64 , 201 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 85 , 404.96 , 79 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 53 , 'Riva ' , 'Scawen ' , ' C ' , 'Allen ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 249 , 491.05 , 63 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 105 , 107.29 , 12 ) ; from typing import Optional insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 223 , 200.44 , 47 ) ; assert warning_msg == None insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 73 , 144.33 , 52 ) ; , PRIMARY KEY ( customer_id ) from .qepparser import ( insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 74 , 'Giffy ' , 'Cottee ' , ' C ' , 'Andrea ' ) ; , PRIMARY KEY ( order_id ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 207 , 'Elise ' , 'Kamenar ' , ' C ' , 'Caswell ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 155 , 274.14 , 151 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 215 , 515.79 , 96 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 22 , 193.12 , 6 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 150 , 'Agnesse ' , 'Liebmann ' , ' B ' , 'Bernard ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 104 , 'Timofei ' , 'Grene ' , ' B ' , 'Armena ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 160 , 144.6 , 82 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 8 , 'Gasparo ' , 'Bohlje ' , ' C ' , 'Abner ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 60 , 473.05 , 208 ) ; cur.execute ( `` set constraint_exclusion = on ; '' ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 58 , 'Lettie ' , 'Coffin ' , ' B ' , 'Almena ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 125 , 'Leo ' , 'Creaney ' , ' B ' , 'Augustus ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 190 , 401.19 , 88 ) ; `` `` '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 108 , 294.25 , 131 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 110 , 144.28 , 59 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 144 , 'Ange ' , 'Pasterfield ' , ' C ' , 'Bedelia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 138 , 'Ainsley ' , 'Wraighte ' , ' C ' , 'Barticus ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 147 , 180.39 , 2 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 58 , 10.24 , 74 ) ; has_onetime_filter_with_constraint_exclusion and \ qep_analysis_without_constraint_exclusion = \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 203 , 'Rory ' , 'Hallatt ' , ' C ' , 'Casey ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 216 , 'Elsbeth ' , 'MacGaughie ' , ' B ' , 'Charles ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 149 , 340.62 , 215 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 186 , 'Chloette ' , 'Ratt ' , ' B ' , 'Calpurnia ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 174 , 597.34 , 184 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 184 , 'Louise ' , 'Jansey ' , ' C ' , 'California ' ) ; def __init__ ( self , * args , conn=None , constraint_exclusion=True , * * kwargs ) : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 189 , 'Merle ' , 'Erridge ' , ' C ' , 'Camille ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 2 , 409.8 , 217 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 158 , 65.82 , 201 ) ; sql_statement = SQL_SIMPLE else : QEPNode , insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 198 , 'Kellby ' , 'Threlfall ' , ' C ' , 'Carolann ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 101 , 328.66 , 189 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 239 , 'Atalanta ' , 'Girdler ' , ' C ' , 'Claire ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 217 , 302.24 , 189 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 230 , 389.39 , 247 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 143 , 'Sasha ' , 'Eunson ' , ' C ' , 'Beck ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 235 , 230.72 , 168 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 95 , 367.31 , 48 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 36 , 225.6 , 136 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 208 , 'Legra ' , 'Drought ' , ' C ' , 'Catherine ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 100 , 'Gypsy ' , 'Bottrell ' , ' C ' , 'Aristotle ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 206 , 'Ardyth ' , 'Conningham ' , ' B ' , 'Cassidy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 94 , 406.59 , 129 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 194 , 'Corilla ' , 'Aldwinckle ' , ' C ' , 'Carmellia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 81 , 'Sharline ' , 'Rosenwald ' , ' B ' , 'Anna ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 6 , 132.85 , 206 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 235 , 'Justus ' , 'Barthrup ' , ' B ' , 'Christy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 135 , 574.1 , 222 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 205 , 'Orlan ' , 'Kynder ' , ' C ' , 'Cassandra ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 147 , 'Wilmer ' , 'MacWhan ' , ' B ' , 'Benedict ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 47 , 163.79 , 141 ) ; REFERENCES { CUSTOMERS_TABLE_NAME } ( customer_id ) def __init__ ( self , * args , conn=None , * * kwargs ) : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 52 , 81.47 , 212 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 205 , 508.59 , 59 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 5 , 582.52 , 172 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 211 , 'Jobi ' , 'Bails ' , ' B ' , 'Cecilia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 40 , 'Olva ' , 'Leborgne ' , ' C ' , 'Alexandra ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 114 , 'Fara ' , 'Arkil ' , ' B ' , 'Arzada ' ) ; self._conn.commit ( ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 149 , 'Erik ' , 'Cushe ' , ' B ' , 'Benjy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 64 , 534.3 , 108 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 66 , 'Sadella ' , 'Boxhall ' , ' B ' , 'Alzada ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 4 , 'Nancey ' , 'Fawlkes ' , ' C ' , 'Abel ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 125 , 170.66 , 131 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 38 , 366.31 , 59 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 72 , 'Nadiya ' , 'Gingles ' , ' B ' , 'Anderson ' ) ; QEPAnalysis , insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 35 , 'Lainey ' , 'Davidow ' , ' C ' , 'Aldrich ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 226 , 'Emelina ' , 'Ayliff ' , ' B ' , 'Chris ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 145 , 112.51 , 162 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 34 , 64.76 , 13 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 20 , 'Robbi ' , ' O '' Caherny ' , ' B ' , 'Adelphia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 36 , 'Bendite ' , 'Morfett ' , ' B ' , 'Aleksandr ' ) ; def __init__ ( self , parsed_sql : exp.Expression , sql_statement : str , insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 73 , 'Seymour ' , 'Maffioletti ' , ' B ' , 'Andre ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 16 , 'Augustin ' , 'Blaxall ' , ' C ' , 'Adelaide ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 155 , 'Murdock ' , 'Dix ' , ' C ' , 'Bess ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 207 , 205.25 , 199 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 173 , 297.4 , 85 ) ; load= [ load_database ] , insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 18 , 438.38 , 26 ) ; has_implied_expression = \ WHERE sname IS NULL ; '' '' '' from .. implied_expression_checker import ImpliedExpressionChecker insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 65 , 318.64 , 6 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 91 , 331.76 , 115 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 200 , 'Fanni ' , 'Iacopetti ' , ' C ' , 'Carolyn ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 67 , 'Zsazsa ' , 'Bellocht ' , ' C ' , 'Amanda ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 97 , 'Germain ' , 'Haly ' , ' B ' , 'Archilles ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 222 , 'Hazel ' , 'Rushforth ' , ' C ' , 'Chester ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 81 , 490.65 , 41 ) ; return warning_msg insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 218 , 'Raffarty ' , 'Sweeney ' , ' C ' , 'Charlotte ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 182 , 'Sasha ' , 'Stiffkins ' , ' C ' , 'Caldonia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 31 , 'Dario ' , 'Siehard ' , ' C ' , 'Alazama ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 112 , 'Nanci ' , 'Byrd ' , ' C ' , 'Arthur ' ) ; not has_onetime_filter_without_constraint_exclusion","['src/pg4n/implied_expression_checker.py', 'src/pg4n/qepparser.py', 'src/pg4n/test/test_implied_expression_checker.py']",2022-11-07 18:55:37+00:00,2022-11-08 08:07:17+00:00,2022-11-08 10:09:32+02:00
56,de27eb5c5d71e31de1e07099cbea189952749079,2.3807027901057157e-05,1,,Detect subquery condition that can be moved to the `` parent '' query ( e30 per Brass ),Merge pull request # 58 from Project-C-SQL/feat/subquery-select,"insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 221 , 487.39 , 227 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 13 , 'Marion ' , 'Penelli ' , ' B ' , 'Adaline ' ) ; subqueries = self.parsed_sql.find_all ( exp.In , exp.SubqueryPredicate ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 14 , 586.06 , 181 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 153 , 350.78 , 247 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 5 , 'Callida ' , 'Tomasello ' , ' B ' , 'Abiel ' ) ; select_column_names = [ ] insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 50 , 306.71 , 235 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 10 , 414.55 , 234 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 246 , 510.74 , 188 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 78 , 569.4 , 99 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 93 , 452.63 , 115 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 218 , 389.51 , 177 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 166 , 95.01 , 189 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 97 , 313.39 , 241 ) ; if i ! = len ( self.nested_condition_contexts ) - 1 : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 119 , 579.12 , 43 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 176 , 'Marylou ' , 'Guilloton ' , ' C ' , 'Bridget ' ) ; warning_msg += '\n ' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 23 , 'Jeanette ' , 'Fincher ' , ' B ' , 'Adriane ' ) ; WHERE order_total_eur > 20 ) ; '' '' '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 132 , 'Olympe ' , 'Faber ' , ' B ' , 'Barbery ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 233 , 87.21 , 179 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 196 , 'Louisa ' , 'Matasov ' , ' B ' , 'Carmon ' ) ; return None insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 42 , 561.85 , 222 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 78 , 'Matilde ' , 'Froome ' , ' B ' , 'Angelica ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 159 , 281.36 , 198 ) ; select_column_names.append ( column_name ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 20 , 207.6 , 9 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 216 , 388.15 , 142 ) ; underlined_query = whole_statement [ : subquery_start_offset ] + \ insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 4 , 144.14 , 157 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 192 , 206.39 , 151 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 24 , 538.88 , 38 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 77 , 'Maegan ' , 'Wheldon ' , ' C ' , 'Angela ' ) ; import pytest insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 82 , 106.39 , 237 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 29 , 'Dawna ' , 'Knipe ' , ' C ' , 'Alanson ' ) ; customer_id in ( SELECT order_id assert warning_msg is not None insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 242 , 356.69 , 244 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 210 , 332.45 , 47 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 63 , 'Gratia ' , 'Moss ' , ' B ' , 'Althea ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 187 , 'Donall ' , 'Casolla ' , ' B ' , 'Calvin ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 32 , 'Aubrie ' , 'Lockitt ' , ' C ' , 'Albert ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 176 , 22.8 , 175 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 245 , 327.9 , 212 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 169 , 'Elsbeth ' , 'Nucciotti ' , ' B ' , 'Bradley ' ) ; WHERE customer_id in ( SELECT order_id VT100_UNDERLINE + \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 37 , 'Talbot ' , 'Keddey ' , ' B ' , 'Aleva ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 237 , 293.23 , 140 ) ; assert warning_msg is None enumerate ( self.nested_condition_contexts ) : WHERE type = ' B ' ; '' '' '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 229 , 89.34 , 147 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 56 , 'Kaitlin ' , 'Payle ' , ' B ' , 'Allyson ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 44 , 537.56 , 2 ) ; SELECT customer_id insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 188 , 'Ferguson ' , 'Mackriell ' , ' B ' , 'Cameron ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 204 , 212.04 , 203 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 122 , 'Myrlene ' , 'Worcs ' , ' B ' , 'Augusta ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 183 , 'Harvey ' , 'Skinn ' , ' B ' , 'Caleb ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 226 , 212.04 , 28 ) ; # exp.In is not SubqueryPredicate for some reason insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 46 , 362.72 , 240 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 201 , 411.07 , 202 ) ; order_id INT insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 242 , 'Brenden ' , 'Simmons ' , ' B ' , 'Clarence ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 52 , 'Gerrilee ' , 'Ackland ' , ' B ' , 'Allan ' ) ; self._detect_suspicious_nested_conditions ( ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 119 , 'Gregg ' , 'Lazenbury ' , ' B ' , 'Aubrey ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 171 , 'Fredrick ' , 'Matuszynski ' , ' C ' , 'Breanna ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 137 , 'Lucilia ' , 'Bentick ' , ' C ' , 'Bartholomew ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 11 , 88.19 , 50 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 162 , 'Jessee ' , 'List ' , ' B ' , 'Billy ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 14 , 'Davon ' , 'Burris ' , ' C ' , 'Addison ' ) ; , order_total_eur DECIMAL ( 6,2 ) NOT NULL insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 32 , 331.93 , 144 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 83 , 'Wolf ' , 'Brenton ' , ' B ' , 'Annette ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 246 , 'Albert ' , 'Heimann ' , ' B ' , 'Cleatus ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 189 , 164.91 , 68 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 240 , 384.87 , 107 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 144 , 504.73 , 154 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 127 , 'Rhoda ' , 'Kurton ' , ' C ' , 'Avarilla ' ) ; whole_statement [ subquery_end_offset : len ( whole_statement ) ] insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 28 , 'Nanice ' , 'MacMaster ' , ' B ' , 'Alan ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 151 , 221.16 , 212 ) ; VT100_RESET = `` \x1b [ 0m '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 148 , 203.36 , 180 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 169 , 552.88 , 241 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 57 , 'Vita ' , 'Dunnett ' , ' B ' , 'Allyssa ' ) ; sql_statement = SQL_SUBQUERY_SELECT_WITH_TOPLEVEL_CONDITIONS_SUSPICIOUS not used in that subquery of its own columns , otherwise returns None . insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 214 , 'Chalmers ' , 'Britton ' , ' C ' , 'Celinda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 70 , 596.2 , 221 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 12 , 'Tiffi ' , 'Riolfo ' , ' C ' , 'Ada ' ) ; SqlParser.get_column_name_from_column_expression ( insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 173 , 'Kristopher ' , 'Mackelworth ' , ' B ' , 'Brenda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 7 , 183.92 , 236 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 219 , 594.84 , 121 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 130 , 'Rora ' , 'Adcock ' , ' C ' , 'Babs ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 162 , 168.92 , 27 ) ; sql_statement = SQL_SUBQUERY_SELECT_EXISTS_SUSPICIOUS insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 89 , 556.68 , 74 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 183 , 546.08 , 88 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 118 , 23.96 , 195 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 18 , 'Odie ' , 'Rowling ' , ' C ' , 'Adele ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 30 , 'Colin ' , 'Jansie ' , ' C ' , 'Alastair ' ) ; sql_statement = SQL_NO_SUBQUERIES insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 177 , 'Genvieve ' , 'Marthen ' , ' B ' , 'Brittany ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 150 , 439.75 , 18 ) ; import psycopg insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 102 , 'Ricca ' , 'Rupprecht ' , ' B ' , 'Arlene ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 227 , 189.25 , 230 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 206 , 226.62 , 228 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 186 , 561.85 , 156 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 1 , 535.36 , 111 ) ; sql_statement = SQL_MULTIPLE_SUBQUERY_SELECTS_SUSPICIOUS FROM { CUSTOMERS_TABLE_NAME } insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 212 , 179.55 , 180 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 103 , 14.83 , 183 ) ; WHERE order_total_eur > 20 ) ) OR insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 171 , 175.72 , 249 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 128 , 'Jere ' , 'Cometti ' , ' B ' , 'Azariah ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 137 , 417.16 , 215 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 10 , 'Sonnie ' , 'Kelling ' , ' B ' , 'Abram ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 140 , 'Suki ' , 'Flinn ' , ' B ' , 'Bea ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 30 , 435.57 , 105 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 104 , 97.04 , 11 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 115 , 351.68 , 153 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 208 , 344.91 , 150 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 239 , 327.06 , 34 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 91 , 'Bobby ' , 'Fortesquieu ' , ' B ' , 'Aquilla ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 121 , 'Clywd ' , 'Stokey ' , ' B ' , 'August ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 28 , 87.44 , 1 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 8 , 424.8 , 244 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 109 , 170.82 , 206 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 181 , 150.37 , 69 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 64 , 'Dyan ' , 'Crosbie ' , ' B ' , 'Alverta ' ) ; order_id > 40 ; '' '' '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 194 , 328.76 , 41 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 121 , 132.25 , 50 ) ; WHERE type = ' B ' ) ; '' '' '' def test_check ( sql_parser : SqlParser ) : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 123 , 'Lyon ' , 'Nolleau ' , ' C ' , 'Augustina ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 248 , 321.97 , 195 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 201 , 'Arv ' , 'Spawforth ' , ' B ' , 'Carrie ' ) ; for i , nested_condition_context in \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 221 , 'Cassondra ' , 'Mattingson ' , ' B ' , 'Chesley ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 96 , 'Tiertza ' , 'Bunford ' , ' C ' , 'Archibald ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 202 , 'Sonja ' , 'Pentycross ' , ' B ' , 'Carthaette ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 234 , 'Cayla ' , 'Statter ' , ' B ' , 'Christopher ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 146 , 'Dunstan ' , 'Cressey ' , ' B ' , 'Bella ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 240 , 'Britte ' , 'Muge ' , ' B ' , 'Clara ' ) ; from .. subquery_select_checker import SubquerySelectChecker insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 156 , 'Allistir ' , 'Frary ' , ' C ' , 'Beth ' ) ; VT100_RESET + \ insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 88 , 210.95 , 158 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 117 , 'Marysa ' , 'Wadman ' , ' C ' , 'Asenath ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 133 , 'Clementia ' , 'Fergusson ' , ' B ' , 'Barbie ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 237 , 'Jeramie ' , 'Gallehock ' , ' C ' , 'Cinderella ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 161 , 184.39 , 94 ) ; FROM { ORDERS_TABLE_NAME } insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 130 , 575.58 , 235 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 178 , 'Rogers ' , 'Plose ' , ' B ' , 'Brittney ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 42 , 'Pyotr ' , 'Feldhorn ' , ' C ' , 'Alexis ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 209 , 'Dulcea ' , 'Akister ' , ' C ' , 'Cathleen ' ) ; CREATE TABLE { CUSTOMERS_TABLE_NAME } ( insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 66 , 454.41 , 11 ) ; SQL_NO_SUBQUERIES = \ insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 23 , 236.48 , 51 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 41 , 158.78 , 145 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 43 , 133.73 , 196 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 59 , 'Lin ' , 'Race ' , ' B ' , 'Almina ' ) ; column_exps = select_expression.find_all ( exp.Column ) for subquery in subqueries : subquery : exp.Expression insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 182 , 478.47 , 70 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 54 , 591.44 , 145 ) ; all_subquery_column_names = [ x.name for x in all_subquery_columns ] insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 79 , 94.87 , 194 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 128 , 415.86 , 243 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 160 , 'Patti ' , 'Louis ' , ' C ' , 'Biddie ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 166 , 'Angelo ' , 'Vanstone ' , ' C ' , 'Boetius ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 98 , 'Elfreda ' , 'Tome ' , ' C ' , 'Ariadne ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 136 , 411.87 , 10 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 157 , 477.53 , 205 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 15 , 47.79 , 248 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 77 , 335.23 , 149 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 57 , 349.14 , 58 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 87 , 'Nanette ' , 'McElwee ' , ' B ' , 'Antoinette ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 48 , 'Marve ' , 'Eykel ' , ' C ' , 'Alicia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 61 , 'Blisse ' , 'Dillway ' , ' C ' , 'Alonzo ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 167 , 547.07 , 197 ) ; def _detect_suspicious_nested_conditions ( self ) : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 45 , 'Seymour ' , 'Mayer ' , ' B ' , 'Alfreda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 112 , 38.97 , 239 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 223 , 'Annice ' , 'Haynes ' , ' B ' , 'Chet ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 24 , 'Jacinthe ' , 'Kleeman ' , ' B ' , 'Adrienne ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 62 , 418.98 , 60 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 27 , 137.86 , 21 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 170 , 539.11 , 92 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 67 , 550.21 , 63 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 181 , 'Daria ' , 'Wistance ' , ' C ' , 'Caitlyn ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 26 , 590.52 , 50 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 170 , 'Bard ' , 'Shaw ' , ' C ' , 'Brady ' ) ; ) ; class SubquerySelectChecker : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 45 , 46.05 , 177 ) ; conn : Connection = psycopg.connect ( * * kwargs ) WHERE ( EXISTS ( SELECT order_total_eur insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 49 , 376.9 , 89 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 19 , 107.53 , 94 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 92 , 'Raven ' , 'Eilles ' , ' C ' , 'Ara ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 139 , 'Kelsi ' , 'Suddell ' , ' C ' , 'Bazaleel ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 141 , 'Jacinta ' , 'Villiers ' , ' B ' , 'Beatrice ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 234 , 254.56 , 98 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 48 , 199.52 , 234 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 68 , 73.27 , 189 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 245 , 'Holly ' , 'Roy ' , ' C ' , 'Claudia ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 232 , 330.85 , 204 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 99 , 'Phineas ' , 'Yuryaev ' , ' B ' , 'Arielle ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 114 , 339.9 , 108 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 142 , 509.25 , 190 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 213 , 'Rubin ' , 'Lunney ' , ' B ' , 'Celeste ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 41 , 'Reilly ' , 'Kennler ' , ' B ' , 'Alexandria ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 76 , 'Ardys ' , 'Currm ' , ' B ' , 'Andriane ' ) ; # ( e.g . FROM statement ) of the subquery . insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 202 , 99.52 , 171 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 159 , 'Carilyn ' , 'Vinecombe ' , ' B ' , 'Bezaleel ' ) ; DROP TABLE IF EXISTS { ORDERS_TABLE_NAME } ; column_exp ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 75 , 238.65 , 203 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 39 , 42.62 , 95 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 129 , 'Ashla ' , 'De-Ville ' , ' C ' , 'Bab ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 82 , 'Abey ' , 'Darridon ' , ' C ' , 'Anne ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 248 , 'Norby ' , 'Biernacki ' , ' C ' , 'Clementine ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 22 , 'Grazia ' , 'Syne ' , ' C ' , 'Adrian ' ) ; FROM { ORDERS_TABLE_NAME } class SubquerySelectContext : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 153 , 'Alfy ' , 'McCahill ' , ' B ' , 'Bertha ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 214 , 520.52 , 98 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 63 , 542.48 , 52 ) ; customer_id INT insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 17 , 'Carlyle ' , 'Zimek ' , ' B ' , 'Adelbert ' ) ; return SqlParser ( db_connection=postgresql ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 165 , 84.61 , 1 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 142 , 'Elfrieda ' , 'Cleary ' , ' C ' , 'Becca ' ) ; WHERE order_id % 2 = 0 ) AND insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 154 , 'Conney ' , 'Riteley ' , ' C ' , 'Bertram ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 180 , 'Leonelle ' , 'Chiommienti ' , ' B ' , 'Caitlin ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 61 , 343.91 , 223 ) ; f '' '' '' WHERE type = ' B ' ) AND insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 224 , 'Dayle ' , 'Eirwin ' , ' B ' , 'Chick ' ) ; with conn.cursor ( ) as cur : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 190 , 'Kara ' , 'Backs ' , ' B ' , 'Campbell ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 220 , 'Kylen ' , 'Bewicke ' , ' B ' , 'Cheryl ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 113 , 305.06 , 123 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 2 , 'Tomlin ' , 'Nozzolinii ' , ' B ' , 'Abbigail ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 31 , 394.48 , 62 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 141 , 183.27 , 44 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 89 , 'Nickie ' , 'Bloss ' , ' C ' , 'Antonio ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 243 , 209.34 , 31 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 157 , 'Noach ' , 'MacRitchie ' , ' C ' , 'Bethena ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 191 , 'Frankie ' , 'Canny ' , ' B ' , 'Candace ' ) ; from pytest_postgresql import factories , fname VARCHAR ( 50 ) NOT NULL insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 11 , 'Amby ' , 'Ligoe ' , ' C ' , 'Absalom ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 185 , 505.7 , 49 ) ; FROM { ORDERS_TABLE_NAME } insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 250 , 'Langston ' , 'Prosser ' , ' C ' , 'Clifford ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 126 , 'Lilllie ' , 'Annis ' , ' C ' , 'Aurelia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 51 , 'Kennan ' , 'Burstowe ' , ' B ' , 'Alixandra ' ) ; SQL_SUBQUERY_SELECT_EXISTS_SUSPICIOUS = \ insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 188 , 495.68 , 39 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 3 , 189.43 , 19 ) ; warning_msg = `` '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 123 , 370.87 , 115 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 74 , 63.02 , 117 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 163 , 'Gerhardt ' , 'Simcock ' , ' B ' , 'Blanche ' ) ; factory = factories.postgresql_proc ( insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 191 , 183.55 , 142 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 116 , 292.86 , 97 ) ; parsed_sql = sql_parser.parse_one ( sql_statement ) if subqueries is None : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 71 , 'Cynthie ' , 'Rouby ' , ' B ' , 'Anastasia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 47 , 'Tracey ' , 'Sauvan ' , ' B ' , 'Alice ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 129 , 426.3 , 136 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 131 , 255.66 , 127 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 233 , 'Tibold ' , 'Sleigh ' , ' C ' , 'Christoph ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 249 , 'Rhoda ' , 'Leheude ' , ' C ' , 'Cliff ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 146 , 184.13 , 22 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 16 , 330.92 , 130 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 65 , 'Glenna ' , 'Alastair ' , ' C ' , 'Alyssa ' ) ; cur.execute ( insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 225 , 'Egbert ' , 'Vasyunin ' , ' B ' , 'Chloe ' ) ; SELECT customers_id insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 197 , 'Missie ' , 'Fealty ' , ' C ' , 'Carol ' ) ; from .. sqlparser import SqlParser insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 25 , 83.54 , 79 ) ; assert checker is not None insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 84 , 'Birk ' , 'Malling ' , ' C ' , 'Annie ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 122 , 406.1 , 80 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 213 , 329.78 , 105 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 86 , 'Lauren ' , 'Tolworth ' , ' B ' , 'Anthony ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 90 , 169.25 , 30 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 103 , 'Ede ' , 'Golden of Ireland ' , ' C ' , 'Armanda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 37 , 322.11 , 41 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 79 , 'Preston ' , 'Groves ' , ' B ' , 'Angelina ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 179 , 453.95 , 43 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 200 , 592.16 , 137 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 139 , 441.16 , 97 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 124 , 'Penelope ' , 'Quadling ' , ' C ' , 'Augustine ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 209 , 203.86 , 244 ) ; subquery_end_offset = subquery_start_offset + len ( subquery ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 124 , 552.02 , 191 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 212 , 'Annecorinne ' , 'Soles ' , ' B ' , 'Cedric ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 56 , 501.06 , 129 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 90 , 'Forest ' , 'Trim ' , ' B ' , 'Appoline ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 134 , 'Georgetta ' , 'Crossley ' , ' B ' , 'Barnabas ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 168 , 'Melicent ' , 'Cheston ' , ' B ' , 'Bradford ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 227 , 'Jeralee ' , 'Atwill ' , ' C ' , 'Christa ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 152 , 'Towny ' , 'Middell ' , ' B ' , 'Bert ' ) ; def load_database ( * * kwargs ) : def sql_parser ( postgresql : Connection ) : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 62 , 'Seline ' , 'McGray ' , ' B ' , 'Alphinias ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 70 , 'Carmela ' , 'Sedgeworth ' , ' C ' , 'Amos ' ) ; sql_statement = SQL_NO_CONDITIONS insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 148 , 'Lidia ' , 'Quinane ' , ' C ' , 'Benjamin ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 243 , 'Hannah ' , 'Mattheis ' , ' C ' , 'Clarinda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 241 , 296.03 , 169 ) ; SELECT ( 1 , 2 , 3 ) ; '' '' '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 69 , 266.3 , 39 ) ; ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 238 , 'Gregor ' , 'Crinion ' , ' B ' , 'Cindy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 117 , 23.13 , 46 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 85 , 'Brig ' , 'Triswell ' , ' C ' , 'Anselm ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 109 , 'Marquita ' , 'Impy ' , ' B ' , 'Aron ' ) ; CREATE TABLE { ORDERS_TABLE_NAME } ( insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 132 , 488.95 , 234 ) ; , type CHAR ( 1 ) NOT NULL insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 84 , 396.02 , 111 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 87 , 441.16 , 191 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 229 , 'Melessa ' , 'MacAleese ' , ' C ' , 'Christiana ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 231 , 51.77 , 118 ) ; FROM { ORDERS_TABLE_NAME } insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 19 , 'Daphne ' , 'Bullen ' , ' B ' , 'Adeline ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 134 , 296.72 , 222 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 133 , 499.73 , 235 ) ; warning_header = `` Warning : No column in subquery SELECT references its tables [ pg4n : :SubquerySelect ] \n '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 204 , 'Cassy ' , 'Pearcehouse ' , ' C ' , 'Casper ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 17 , 302.31 , 225 ) ; f '' '' '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 195 , 'Dewey ' , 'Bottom ' , ' C ' , 'Carmelo ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 80 , 'Petey ' , 'Colloby ' , ' B ' , 'Ann ' ) ; warning_msg += warning_header + underlined_query insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 180 , 452.67 , 234 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 140 , 297.41 , 101 ) ; FROM { CUSTOMERS_TABLE_NAME } insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 228 , 'Rudd ' , 'Ames ' , ' B ' , 'Christian ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 238 , 448.86 , 16 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 172 , 'Pammi ' , 'Codling ' , ' B ' , 'Breeanna ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 199 , 376.5 , 53 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 110 , 'Donall ' , 'Labrenz ' , ' B ' , 'Artelepsa ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 250 , 367.56 , 214 ) ; '' '' '' ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 111 , 'Torey ' , 'Sessuns ' , ' B ' , 'Artemus ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 25 , 'Neely ' , 'Merrydew ' , ' B ' , 'Agatha ' ) ; for column_exp in column_exps : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 244 , 'Katrine ' , 'Janiak ' , ' B ' , 'Clarissa ' ) ; warning_msg = checker.check ( ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 195 , 504.28 , 117 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 131 , 'Ive ' , 'Matches ' , ' B ' , 'Barbara ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 161 , 'Barron ' , 'Dishmon ' , ' B ' , 'Bill ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 12 , 591.72 , 143 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 55 , 'Terrill ' , 'Syde ' , ' B ' , 'Allison ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 187 , 271.52 , 242 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 222 , 416.65 , 59 ) ; from psycopg import Connection insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 100 , 424.83 , 50 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 241 , 'Sigismund ' , 'Mowsdill ' , ' B ' , 'Clare ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 193 , 449.91 , 213 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 210 , 'Pamelina ' , 'Vittery ' , ' C ' , 'Cathy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 178 , 563.08 , 161 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 156 , 130.63 , 188 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 126 , 384.61 , 226 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 106 , 'Merrily ' , 'Coundley ' , ' C ' , 'Arminda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 196 , 259.0 , 244 ) ; SELECT order_id insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 192 , 'Dudley ' , 'Vesco ' , ' B ' , 'Carlotta ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 113 , 'Dania ' , 'Foxton ' , ' C ' , 'Arthusa ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 211 , 399.2 , 138 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 98 , 177.22 , 86 ) ; all_subquery_columns = self.sql_parser.get_query_columns ( subquery ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 164 , 'Abel ' , 'Bezants ' , ' C ' , 'Bob ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 154 , 291.52 , 54 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 35 , 389.81 , 218 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 164 , 193.39 , 169 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 247 , 'Dulcie ' , 'Crutchley ' , ' B ' , 'Clement ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 21 , 'Nady ' , 'Lempertz ' , ' B ' , 'Adolphus ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 244 , 273.35 , 153 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 215 , 'Nollie ' , 'Jemmett ' , ' B ' , 'Charity ' ) ; from dataclasses import dataclass insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 95 , 'Amandie ' , 'Botham ' , ' B ' , 'Araminta ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 27 , 'Callean ' , 'Werlock ' , ' C ' , 'Aileen ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 172 , 15.3 , 30 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 105 , 'Cary ' , 'Sells ' , ' C ' , 'Armilda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 13 , 503.52 , 216 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 136 , 'Aretha ' , 'Arias ' , ' C ' , 'Bart ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 3 , 'Christen ' , 'Culley ' , ' C ' , 'Abednego ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 135 , 'Janenna ' , 'McCamish ' , ' C ' , 'Barney ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 15 , 'Zachary ' , 'Faloon ' , ' C ' , 'Adela ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 102 , 158.53 , 220 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 71 , 175.29 , 115 ) ; if len ( self.nested_condition_contexts ) == 0 : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 93 , 'Sashenka ' , 'Fedorski ' , ' C ' , 'Arabella ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 198 , 120.47 , 95 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 152 , 291.54 , 10 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 106 , 236.57 , 4 ) ; conn.commit ( ) from .sqlparser import SqlParser insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 92 , 156.72 , 192 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 76 , 281.92 , 183 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 107 , 'Celisse ' , 'Rubra ' , ' B ' , 'Arminta ' ) ; checker = SubquerySelectChecker ( parsed_sql , sql_parser ) sql_statement = SQL_SUBQUERY_SELECT_IN_SUSPICIOUS insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 34 , 'Lorens ' , 'Buzin ' , ' C ' , 'Aldo ' ) ; self.parsed_sql : exp.Expression = parsed_sql insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 116 , 'Annmarie ' , 'Errichelli ' , ' B ' , 'Asaph ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 115 , 'Shirl ' , 'Pilpovic ' , ' C ' , 'Asahel ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 225 , 26.43 , 228 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 46 , 'Mechelle ' , 'Vinick ' , ' B ' , 'Algernon ' ) ; CHECK ( type IN ( ' C ' , ' B ' ) ) -- C = customer , B = business insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 38 , 'Web ' , 'Catterill ' , ' B ' , 'Alex ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 224 , 293.35 , 186 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 54 , 'Malchy ' , 'Hearty ' , ' B ' , 'Allisandra ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 217 , 'Lucy ' , 'Durtnell ' , ' C ' , 'Charlie ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 94 , 'Halimeda ' , 'Freak ' , ' B ' , 'Arabelle ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 9 , 519.43 , 175 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 230 , 'Cordell ' , 'Bineham ' , ' B ' , 'Christiano ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 75 , 'Erma ' , 'Cranstone ' , ' B ' , 'Andrew ' ) ; DROP TABLE IF EXISTS { CUSTOMERS_TABLE_NAME } ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 184 , 380.46 , 98 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 68 , 'Leisha ' , 'Darlington ' , ' C ' , 'Ambrose ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 219 , 'Adriane ' , 'Ccomini ' , ' B ' , 'Chauncey ' ) ; , sname VARCHAR ( 50 ) NOT NULL insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 59 , 141.8 , 118 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 236 , 'Garnette ' , 'Tabrett ' , ' C ' , 'Cicely ' ) ; , FOREIGN KEY ( customer_id ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 43 , 'Belle ' , 'Barsham ' , ' B ' , 'Alfonse ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 145 , 'Adena ' , 'Wenham ' , ' C ' , 'Belinda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 197 , 529.63 , 46 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 39 , 'Tabbie ' , 'Glison ' , ' B ' , 'Alexander ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 33 , 140.92 , 236 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 29 , 217.18 , 124 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 80 , 17.1 , 21 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 96 , 311.78 , 173 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 185 , 'Tanitansy ' , 'Headington ' , ' C ' , 'Calista ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 120 , 'Corinna ' , 'Pyburn ' , ' B ' , 'Audrey ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 33 , 'Amble ' , 'Jewes ' , ' B ' , 'Alberta ' ) ; , nickname VARCHAR ( 20 ) NOT NULL insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 165 , 'Angele ' , 'Wildbore ' , ' C ' , 'Bobby ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 108 , 'Janene ' , 'Motten ' , ' C ' , 'Arnold ' ) ; SQL_NO_CONDITIONS = \ # We need to find whether the subquery SELECT uses a tuple variable insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 107 , 23.63 , 179 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 168 , 137.02 , 109 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 6 , 'Daisey ' , 'Hamill ' , ' B ' , 'Abigail ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 167 , 'Ninnette ' , 'Steere ' , ' C ' , 'Brad ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 69 , 'Maryjo ' , 'Pink ' , ' C ' , 'Amelia ' ) ; subquery_start_offset = whole_statement.find ( subquery ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 50 , 'Anne-marie ' , 'Mounsie ' , ' B ' , 'Alison ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 151 , 'Prentiss ' , 'Filby ' , ' B ' , 'Berney ' ) ; CUSTOMERS_TABLE_NAME = `` e29_test_table_customers '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 231 , 'Calhoun ' , 'BoHlingolsen ' , ' C ' , 'Christina ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 49 , 'Theodosia ' , 'Rosson ' , ' B ' , 'Aline ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 220 , 367.15 , 163 ) ; for select_expression in select.expressions : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 99 , 354.37 , 66 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 51 , 244.27 , 119 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 158 , 'Anett ' , 'Hercules ' , ' B ' , 'Beverly ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 26 , 'Jenica ' , 'Martina ' , ' C ' , 'Agnes ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 175 , 161.61 , 58 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 72 , 539.87 , 62 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 203 , 545.33 , 116 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 21 , 471.12 , 179 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 138 , 223.81 , 183 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 40 , 33.89 , 23 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 101 , 'Hamilton ' , 'Pellew ' , ' B ' , 'Arizona ' ) ; select_column_names ) ) : def __init__ ( self , parsed_sql : exp.Expression , sql_parser : SqlParser ) : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 88 , 'Sansone ' , 'Copsey ' , ' C ' , 'Antonia ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 111 , 490.85 , 191 ) ; import sqlglot.expressions as exp insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 232 , 'Maritsa ' , 'Cowpland ' , ' C ' , 'Christine ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 163 , 61.42 , 69 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 247 , 123.55 , 179 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 60 , 'Sibyl ' , 'Thoms ' , ' C ' , 'Almira ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 236 , 485.18 , 167 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 83 , 451.45 , 203 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 193 , 'Brucie ' , 'Coning ' , ' C ' , 'Carlton ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 228 , 542.3 , 42 ) ; SQL_MULTIPLE_SUBQUERY_SELECTS_SUSPICIOUS = \ insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 127 , 451.77 , 17 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 120 , 454.18 , 214 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 174 , 'Carolyn ' , 'Quinlan ' , ' C ' , 'Brian ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 199 , 'Matilda ' , 'Malenoir ' , ' C ' , 'Caroline ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 179 , 'Daphne ' , 'Kells ' , ' C ' , 'Broderick ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 9 , 'Lester ' , 'Markus ' , ' C ' , 'Abraham ' ) ; postgresql = factories.postgresql ( `` factory '' ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 143 , 239.98 , 109 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 53 , 592.15 , 207 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 7 , 'Lorin ' , 'Dollimore ' , ' C ' , 'Abijah ' ) ; , customer_id INT NOT NULL insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 55 , 391.93 , 128 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 1 , 'Josi ' , 'Grimsell ' , ' B ' , 'Aaron ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 175 , 'Davy ' , 'Blomefield ' , ' B ' , 'Brianna ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 118 , 'Hermy ' , 'Whieldon ' , ' B ' , 'Ashley ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 44 , 'Buffy ' , ' O '' Cridigan ' , ' B ' , 'Alfred ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 177 , 334.0 , 167 ) ; def check ( self ) - > Optional [ str ] : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 86 , 537.64 , 201 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 85 , 404.96 , 79 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 53 , 'Riva ' , 'Scawen ' , ' C ' , 'Allen ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 249 , 491.05 , 63 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 105 , 107.29 , 12 ) ; from typing import Optional insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 223 , 200.44 , 47 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 73 , 144.33 , 52 ) ; , PRIMARY KEY ( customer_id ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 74 , 'Giffy ' , 'Cottee ' , ' C ' , 'Andrea ' ) ; , PRIMARY KEY ( order_id ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 207 , 'Elise ' , 'Kamenar ' , ' C ' , 'Caswell ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 155 , 274.14 , 151 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 215 , 515.79 , 96 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 22 , 193.12 , 6 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 150 , 'Agnesse ' , 'Liebmann ' , ' B ' , 'Bernard ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 104 , 'Timofei ' , 'Grene ' , ' B ' , 'Armena ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 160 , 144.6 , 82 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 8 , 'Gasparo ' , 'Bohlje ' , ' C ' , 'Abner ' ) ; subquery + \ subquery = str ( nested_condition_context.subquery ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 60 , 473.05 , 208 ) ; if all ( filter ( lambda x : x not in all_subquery_column_names , self.sql_parser : SqlParser = sql_parser insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 58 , 'Lettie ' , 'Coffin ' , ' B ' , 'Almena ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 125 , 'Leo ' , 'Creaney ' , ' B ' , 'Augustus ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 190 , 401.19 , 88 ) ; `` `` '' VT100_UNDERLINE = `` \x1b [ 4m '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 108 , 294.25 , 131 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 110 , 144.28 , 59 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 144 , 'Ange ' , 'Pasterfield ' , ' C ' , 'Bedelia ' ) ; SQL_SUBQUERY_SELECT_IN_SUSPICIOUS = \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 138 , 'Ainsley ' , 'Wraighte ' , ' C ' , 'Barticus ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 147 , 180.39 , 2 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 58 , 10.24 , 74 ) ; select = subquery.find ( exp.Select ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 203 , 'Rory ' , 'Hallatt ' , ' C ' , 'Casey ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 216 , 'Elsbeth ' , 'MacGaughie ' , ' B ' , 'Charles ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 149 , 340.62 , 215 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 186 , 'Chloette ' , 'Ratt ' , ' B ' , 'Calpurnia ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 174 , 597.34 , 184 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 184 , 'Louise ' , 'Jansey ' , ' C ' , 'California ' ) ; SQL_SUBQUERY_SELECT_WITH_TOPLEVEL_CONDITIONS_SUSPICIOUS = \ self.nested_condition_contexts.append ( context ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 189 , 'Merle ' , 'Erridge ' , ' C ' , 'Camille ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 2 , 409.8 , 217 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 158 , 65.82 , 201 ) ; ORDERS_TABLE_NAME = `` e29_test_table_orders '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 198 , 'Kellby ' , 'Threlfall ' , ' C ' , 'Carolann ' ) ; Returns warning message if there no column SELECTed in a subquery is insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 101 , 328.66 , 189 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 239 , 'Atalanta ' , 'Girdler ' , ' C ' , 'Claire ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 217 , 302.24 , 189 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 230 , 389.39 , 247 ) ; whole_statement = str ( self.parsed_sql ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 143 , 'Sasha ' , 'Eunson ' , ' C ' , 'Beck ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 95 , 367.31 , 48 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 36 , 225.6 , 136 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 235 , 230.72 , 168 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 208 , 'Legra ' , 'Drought ' , ' C ' , 'Catherine ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 100 , 'Gypsy ' , 'Bottrell ' , ' C ' , 'Aristotle ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 206 , 'Ardyth ' , 'Conningham ' , ' B ' , 'Cassidy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 94 , 406.59 , 129 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 194 , 'Corilla ' , 'Aldwinckle ' , ' C ' , 'Carmellia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 81 , 'Sharline ' , 'Rosenwald ' , ' B ' , 'Anna ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 6 , 132.85 , 206 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 235 , 'Justus ' , 'Barthrup ' , ' B ' , 'Christy ' ) ; column_name = \ insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 135 , 574.1 , 222 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 205 , 'Orlan ' , 'Kynder ' , ' C ' , 'Cassandra ' ) ; self.nested_condition_contexts : list [ SubquerySelectContext ] = [ ] insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 147 , 'Wilmer ' , 'MacWhan ' , ' B ' , 'Benedict ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 47 , 163.79 , 141 ) ; REFERENCES { CUSTOMERS_TABLE_NAME } ( customer_id ) return insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 52 , 81.47 , 212 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 205 , 508.59 , 59 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 5 , 582.52 , 172 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 211 , 'Jobi ' , 'Bails ' , ' B ' , 'Cecilia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 40 , 'Olva ' , 'Leborgne ' , ' C ' , 'Alexandra ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 114 , 'Fara ' , 'Arkil ' , ' B ' , 'Arzada ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 149 , 'Erik ' , 'Cushe ' , ' B ' , 'Benjy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 64 , 534.3 , 108 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 66 , 'Sadella ' , 'Boxhall ' , ' B ' , 'Alzada ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 4 , 'Nancey ' , 'Fawlkes ' , ' C ' , 'Abel ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 125 , 170.66 , 131 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 38 , 366.31 , 59 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 72 , 'Nadiya ' , 'Gingles ' , ' B ' , 'Anderson ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 226 , 'Emelina ' , 'Ayliff ' , ' B ' , 'Chris ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 35 , 'Lainey ' , 'Davidow ' , ' C ' , 'Aldrich ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 145 , 112.51 , 162 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 34 , 64.76 , 13 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 20 , 'Robbi ' , ' O '' Caherny ' , ' B ' , 'Adelphia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 36 , 'Bendite ' , 'Morfett ' , ' B ' , 'Aleksandr ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 73 , 'Seymour ' , 'Maffioletti ' , ' B ' , 'Andre ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 16 , 'Augustin ' , 'Blaxall ' , ' C ' , 'Adelaide ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 155 , 'Murdock ' , 'Dix ' , ' C ' , 'Bess ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 207 , 205.25 , 199 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 173 , 297.4 , 85 ) ; load= [ load_database ] , insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 18 , 438.38 , 26 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 65 , 318.64 , 6 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 91 , 331.76 , 115 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 200 , 'Fanni ' , 'Iacopetti ' , ' C ' , 'Carolyn ' ) ; WHERE EXISTS ( SELECT order_total_eur insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 67 , 'Zsazsa ' , 'Bellocht ' , ' C ' , 'Amanda ' ) ; FROM { CUSTOMERS_TABLE_NAME } insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 97 , 'Germain ' , 'Haly ' , ' B ' , 'Archilles ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 222 , 'Hazel ' , 'Rushforth ' , ' C ' , 'Chester ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 81 , 490.65 , 41 ) ; return warning_msg insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 218 , 'Raffarty ' , 'Sweeney ' , ' C ' , 'Charlotte ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 182 , 'Sasha ' , 'Stiffkins ' , ' C ' , 'Caldonia ' ) ; context = SubquerySelectContext ( subquery ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 31 , 'Dario ' , 'Siehard ' , ' C ' , 'Alazama ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 112 , 'Nanci ' , 'Byrd ' , ' C ' , 'Arthur ' ) ;","['src/pg4n/subquery_select_checker.py', 'src/pg4n/test/test_subquery_select_checker.py']",2022-11-07 18:55:37+00:00,2022-11-08 08:07:17+00:00,2022-11-08 10:07:16+02:00
61,7a2404b05defc51c519424b9b8ecfc2de17e58a5,1.0197189112659544e-05,1,,Warning message levels ?,Merge pull request # 78 from Project-C-SQL/feat/config,"for config_fname in config_fnames : from os import getcwd , getenv return config_values assert config_values [ `` SubquerySelect '' ] == False if match : = ConfigParser._option_matcher.match ( line ) : file=sys.stderr , from .config_parser import ConfigParser iNnErOrDeRbY true # CmpDomains false output_line = line.rstrip ( `` \n '' ) f '' error : unable to read config file : ' { config_fname } ' '' , for key in multiply_defined_options : SeenOptionContext ( ) ) def test_parse ( ) : def _optval_to_bool ( self , optval : str ) - > bool : parser = ConfigParser ( tmp_file ) # # 3 # # jkelm el el e fields = ConfigValues.__annotations__.keys ( ) # Needed for bytes containing files from .. config_values import ConfigValues for field in fields : for k , v in new_config_values.items ( ) : from typing import TypedDict cwd = os.getcwd ( ) print ( class ConfigParser : line = bytes.decode ( line , `` utf-8 '' ) if os.path.isfile ( cwd_config_path ) : # configuration file output is not tested because its system dependent self.file.seek ( 0 ) config_fnames = [ ] # in configuration file : ' . * ' except Exception as e : return field # As a Last resort , we check the current directory for a config file . # line 7 : 'InnerOrderBy true ' assert config_values is not None return True print ( multiply_defined_options.add ( key ) if os.path.isfile ( home_config_path ) : ) if key in [ x.key for x in seen_option_contexts ] : # `` '' '' try : return None ImpliedExpression : bool config_fnames.append ( cwd_config_path ) convert that user written value to the proper one that matches the import os.path The configuration files are read in order from : config_parser = ConfigParser ( config_file ) line = str ( line ) # Not so brilliant computational complexity # line 8 : 'InnerOrderBy true ' if len ( config_fnames ) == 0 : line_number : int home = getenv ( `` HOME '' ) from .config_values import ConfigValues _option_matcher : re.Pattern = re.compile ( file=sys.stderr , key = self._convert_from_anycase_to_propercase ( optname ) print ( import sys # CONFIG1 = `` '' '' ImpliedExpression false output_line = line.rstrip ( `` \n '' ) if match : = ConfigParser._empty_line_matcher.match ( line ) : if xdg_config_home : from typing import Optional if hasattr ( e , `` errno '' ) : fields in ConfigValues class . config_values [ key ] = self._optval_to_bool ( ImpliedExpression yes seen_option_lines += f '' line { ctx.line_number } : ' { ctx.line } '\n '' CmpDomains : bool # The following stuff is for improved error messages Converts config file option value string into bool . /etc/pg4n/config , $ XDG_CONFIG_HOME/pg4n/config , or if tmp_file.seek ( 0 ) if match : = ConfigParser._comment_matcher.match ( line ) : INNERORDERBY true self.file : TextIO = file if optval.lower ( ) in false_values : # Contains all the key-value pairs meaningful in a config file . seen_option_contexts.append ( if optval.lower ( ) in true_values : # line 1 : 'ImpliedExpression false ' _empty_line_matcher : re.Pattern = re.compile ( r '' ^\s * $ '' ) ) # # # # # # # # # # # # # # # # # # # # # # Users can write option values case-insensitively . We still need to # line 6 : 'InnerOrderBy true ' assert config_values [ `` CmpDomains '' ] == False assert config_values [ `` InnerOrderBy '' ] == True Assumes that anycase_key matches some option name case-insensitively . false_values = ( `` false '' , `` 0 '' , `` no '' ) def __init__ ( self ) : _comment_matcher : re.Pattern = re.compile ( r '' ^\s * # + . * $ '' ) `` `` '' # ImpliedExpression 1 class SeenOptionContext : # # # # # # # # # config_fnames.append ( custom_config_home_path ) class ConfigValues ( TypedDict ) : if isinstance ( line , bytes ) : if anycase_key.lower ( ) == field.lower ( ) : f '' error : unable to get current working directory ' { e } ' '' , file=sys.stderr multiply_defined_options = set ( ) return config_values if len ( config_values ) > 0 else None innerorderby true config_values [ k ] = v f '' warning : unable to parse line { line_number } : ' { output_line } ' in configuration file : ' { self.file.name } ' '' , def _convert_from_anycase_to_propercase ( self , anycase_key : str ) - > str : # Gives too many false positives from tempfile import TemporaryFile from dataclasses import dataclass # file CONFIG # def test_multiple_option_definition_warings ( ) : if optname.lower ( ) in optnames : from typing import Optional , TextIO # This is the matching output of running the program that reads only 1 config for line_number , line in enumerate ( self.file.readlines ( ) ) : true_values = ( `` true '' , `` 1 '' , `` yes '' ) assert config_values [ `` ImpliedExpression '' ] == True ) else : with open ( config_fname , `` r '' ) as config_file : CONFIG_FILE_NAME = `` pg4n.conf '' xdg_config_home = getenv ( `` XDG_CONFIG_HOME '' ) CmpDomains false # # # `` `` '' seen_option_contexts : list [ SeenOptionContext ] = [ ] # str ( match.group ( `` optval '' ) ) def read ( self ) - > Optional [ ConfigValues ] : seen_option_lines = `` '' pass def parse ( self ) - > Optional [ ConfigValues ] : import re # warning : option 'ImpliedExpression ' is set multiple times file=sys.stderr , cwd_config_path = cwd + `` / '' + CONFIG_FILE_NAME if new_config_values is not None : ) Excepts only valid option values . # warning_matcher = re.compile ( \ with TemporaryFile ( buffering=0 ) as tmp_file : key : str else : # TODO : The actual test tmp_file.flush ( ) Reads config values from file givein in __init__ . if os.path.isfile ( custom_config_home_path ) : each new value introduced in latter files overriding the previous value . return False else : # To make this work with bytes objects like TemporaryFile contents def __init__ ( self , file : TextIO ) : f '' error : unable to read config file : ' { config_fname } ' [ str ( { e.errno } ) ] '' , new_config_values : ConfigValues = config_parser.parse ( ) etc_config_path = `` /etc/ '' + CONFIG_FILE_NAME optnames = [ x.lower ( ) for x in ConfigValues.__annotations__.keys ( ) ] try : for ctx in filter ( lambda x : x.key == key , seen_option_contexts ) : # InnerOrderBy true line : str # This is the config file CONFIG = `` '' '' ImpliedExpression 0 f '' warning : bad warning name or value in line { line_number } : ' { output_line } ' in configuration file : ' { self.file.name } ' '' , SubquerySelect : bool except Exception as e : home_config_path = home + `` /.config/ '' + CONFIG_FILE_NAME flags=re.IGNORECASE , # line 5 : 'InnerOrderBy true ' else : optname = match.group ( `` optname '' ) if os.path.isfile ( etc_config_path ) : SubquerySelect 0 # line 2 : 'ImpliedExpression 1 ' custom_config_home_path = xdg_config_home + `` / '' + CONFIG_FILE_NAME continue config_fnames.append ( home_config_path ) config_fnames.append ( etc_config_path ) # line 4 : 'InnerOrderBy true ' return False r '' \s * ( ? P < optname > \w+ ) \s+ ( ? P < optval > 1|0|true|false|yes|no ) \s * $ '' , # ) InnerOrderBy true $ XDG_CONFIG_HOME is not set , from $ HOME/.config/pg4n/config , class ConfigReader : f '' warning : option ' { key } ' is set multiple times\n { seen_option_lines } in configuration file : ' { self.file.name } ' '' , # line 10 : 'InnerOrderBy true ' InnerOrderBy : bool # SubquerySelect yes tmp_file.write ( bytes ( CONFIG , `` utf-8 '' ) ) config_values : ConfigValues = { } config_values : Optional [ ConfigValues ] = parser.parse ( ) key=key , line=line.rstrip ( `` \n '' ) , line_number=line_number from .. config_parser import ConfigParser assert False , f '' { e } ''","['src/pg4n/config_parser.py', 'src/pg4n/config_reader.py', 'src/pg4n/config_values.py', 'src/pg4n/test/test_config_parser.py']",2022-11-08 09:23:02+00:00,2022-11-22 10:09:25+00:00,2022-11-21 22:39:05+02:00
63,cd7168bd9791c3c51875f85850371cec52a72e57,1.0447770364407916e-05,1,References at ` src/bin/psql/prompt.c ` and ` src/bin/psql/settings.h ` in PostgreSQL source tree .,Find out all possible psql prompt formats,Merge pull request # 80 from Project-C-SQL/fix/wrapper,"from pyparsing import CaselessLiteral , Char , Literal , MatchFirst , \ str ( self.supported_psql_versions ) + `` . '' # in live scenarios most of the time , but I can not reproduce it with this ZeroOrMore ( Char ( `` \n '' ) | Char ( `` \r '' ) ) + self.match_whole_rev_sql_stmt pexpect.spawn ( `` psql `` + bytes.decode ( self.psql_args ) `` psql ( 14.5 ) \nType \ '' help\ '' for help.\n\npgdb= # SELECT * FROM orders ; \npgdb= # INSERT INTO orders VALUES ( 6 , 6 , 6 ) ; \npgdb= # SELECT * FROM\n orders WHERE order_total_eur = 100 ; `` match_error : ParserElement = \ Literal ( `` psql ( PostgreSQL ) `` ) + Combine ( Word ( nums ) + ' . ' + Word ( nums ) ) self.db_name : bytes = db_name_parameter psql.ofilter ( b'\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) # If it is SELECT , remove multiline delimiters and then statement is # magic strings related seemingly solely to ctrl-R use are b ' 207.60 | 9\x1b [ m\r\n 21 | 471.12 | 179\x1b [ m\r\n : \x1b [ K ' ) Literal ( `` ERROR : '' ) Literal ( `` > = '' ) | Literal ( `` # = '' ) case_query_2_prompt = \ match_prompt + match_sql_stmt + match_sql_stmt_end psql.ofilter ( b '' '\r ( reverse-i-search ) ` ' : `` ) # assert p.parse_last_found_stmt ( case_select_then_insert ) == \ psql.ofilter ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C1 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 1\x1b [ 27m00 ; \x08\x08\x08\x08\x08\x08 '' ) ParseException , ParseResults , ParserElement , StringEnd , Word , ZeroOrMore , \ `` SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; '' # BUG ( ? ) : Assumes only single statement query psql.ofilter ( b'\r ( reverse-i-search ) ` \ ' : ' ) # TODO/BUG : removing \n 's is a tough problem , see : .replace ( db_name + `` - > '' , `` '' ) \ try : match_sql_stmt : ParserElement = \ tok_stmt_end # case_query_3_prompt = b ' order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004hpgdb= # ' version_info = \ case_multiple_queries_and_whitespaces = \ # psql.ofilter ( return_press_1 ) match_sql_stmt_start : ParserElement = \ parse_sql_stmt : ParserElement = \ .replace ( db_name + `` - # '' , `` '' ) return reversed_flattened_res stmt_res = match_version_stmt.parse_string ( psql ) # `` '' # print ( psql.pyte_screen.display ) b'\x1b [ ? 2004l\r order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\r\nTest\r\n\r\n\x1b [ ? 2004htest_db= # ' self.psql_args : bytes = psql_args if stmt_res : # TODO : For some reason Literal ( `` > = '' ) does not provide a match , # Literal ( `` ERROR : '' ) psql.ofilter ( b'\x08order_total_eur = 0 AND order_total_eur = 1\x1b [ 1P00 ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) psql.ofilter ( b'\r\n ' ) # case_select_then_insert = `` psql ( 14.5 ) \nType \ '' help\ '' for help.\n\npgdb= # SELECT * FROM orders ; \npgdb= # INSERT INTO orders VALUES ( 6 , 6 , 6 ) ; '' psql.ofilter ( b'orders ' ) except ParseException as e : ( CaselessLiteral ( `` > - '' ) | CaselessLiteral ( `` # - '' ) ) + \ # ctrl-R to previous query with three key presses searching ( 1 .. 0 .. 0 ) . Press return . ( CaselessLiteral ( `` > = '' ) | CaselessLiteral ( `` # = '' ) ) + \ # should parse as \n - > `` '' if self.debug : match_rev_any_sql_stmt : ParserElement = \ def parse_psql_version ( self , psql : str ) - > str : c = pexpect.spawn ( `` psql `` + bytes.decode ( self.psql_args ) , match_select_stmt : ParserElement = \ from pyparsing import \ tok_rev_prompt : ParserElement = \ case_multiline_query = \ psql.ofilter ( b'\x1b [ ? 2004htest_db- # ' ) if len ( res_list ) == 4 : # includes \x1b [ ? 2004l # complicated case : user has ctrl-R 'd , copy-pasted command or something , # If parsing was successful , pick interesting parts . version_info.expect ( pexpect.EOF ) result : str = `` '' ( CaselessLiteral ( `` = > '' ) | CaselessLiteral ( `` = # '' ) ) # reverse string for parsing efficiency db_name : str = `` '' Word ( prompt_chars ) + Char ( '\n ' ) psql.ofilter ( b'\x08order_total_eur = 0 AND order_total_eur = 10\x1b [ C\x1b [ 1P ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) # fresh prompt : psql.ofilter ( b'SELECT ' ) # extra whitespace : psql.ofilter ( b ' * ' ) f.close ( ) return `` '' # `` pgdb= > SELECT if is_select : # Something weird going this test case . Pyte understands this case right match_last_stmt : ParserElement = \ tok_prompt : ParserElement = \ results = [ stmt_res_list [ length - 2 ] , psql.ofilter ( b'\x08\x08 ' ) ZeroOrMore ( White ( ) ) + tok_stmt_end + ... + \ # b ' order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\r\nTest\r\n\r\n\x1b [ ? 2004hpgdb= # ' psql.ofilter ( b'\r\x1b [ C ' ) assert p.parse_last_found_stmt ( case_select_then_insert ) == \ ZeroOrMore ( Char ( `` \n '' ) | Char ( `` \r '' ) | White ( ) ) + \ from functools import reduce ( StringEnd ( ) | ( Literal ( `` ? [ \x1b '' ) + \ # then reverse the matched string . psql.ofilter ( b '' \x08\x08\x08= ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m=\x1b [ 27m 100 ; \x08\x08\x08\x08\x08\x08 '' ) match_rev_sql_stmt_start : ParserElement = \ b'\r\x1b [ 16Ppgdb= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_tot\x08\r\n\x1b [ ? 2004l\r ' # saved stream of characters . Literal ( `` > = '' ) | Literal ( `` # = '' ) # parser combinations # `` pgdb= > SELECT * FROM orders WHERE order_tot # should parse as \n - > `` `` to avoid `` SELECT * FROM .. '' . psql.ofilter ( b'\r\x1b [ K\x1b > \x1b [ r\x1b [ ? 1049l ' ) supported_psql_versions : list [ str ] = [ `` 14.5 '' ] version_ok : bool = version in self.supported_psql_versions : returns : version string ( e.g `` 14.5 '' ) ( CaselessLiteral ( `` - > '' ) | CaselessLiteral ( `` - # '' ) ) psql.ofilter ( b'FROM ' ) ParseResults , ParserElement , StringEnd , White , Word , ZeroOrMore , \ # psql.ofilter ( case_query_3 ) print ( version_msg ) b'\r\nTest\r\n\r\n\x1b [ ? 2004htest_db= # ' psql.ofilter ( b'\x1b [ ? 2004l\r\x1b [ ? 1049h\x1b=\r order_id | order_total_eur | customer_id \x1b [ m\r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\x1b [ m\r\n 1 | 535.36 | 111\x1b [ m\r\n 2 | 409.80 | 217\x1b [ m\r\n 3 | 189.43 | 19\x1b [ m\r\n 4 | 144.14 | 157\x1b [ m\r\n 5 | 582.52 | 172\x1b [ m\r\n 6 | 132.85 | 206\x1b [ m\r\n 7 | 183.92 | 236\x1b [ m\r\n 8 | 424.80 | 244\x1b [ m\r\n 9 | 519.43 | 175\x1b [ m\r\n 10 | 414.55 | 234\x1b [ m\r\n 11 | 88.19 | 50\x1b [ m\r\n 12 | 591.72 | 143\x1b [ m\r\n 13 | 503.52 | 216\x1b [ m\r\n 14 | 586.06 | 181\x1b [ m\r\n 15 | 47.79 | 248\x1b [ m\r\n 16 | 330.92 | 130\x1b [ m\r\n 17 | 302.31 | 225\x1b [ m\r\n 18 | 438.38 | 26\x1b [ m\r\n 19 | 107.53 | 94\x1b [ m\r\n 20 | ' Word ( stmt_chars ) case_query_with_newline = \ # Arrow-up to previous query , alt-B until 'orders WHERE ' and remove the `` sql ( 14.5 ) \nType \ '' help\ '' for help.\n\npgdb= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n '' b ' order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004hpgdb= # ' case_select_then_insert = `` psql ( 14.5 ) \nType \ '' help\ '' for help.\n\npgdb= # SELECT * FROM orders ; \npgdb= # INSERT INTO orders VALUES ( 6 , 6 , 6 ) ; '' # TODO : strip `` - > '' / '' - # '' from string to allow multiline queries `` `` '' Parse for psql version and return version number . MatchFirst ( [ tok_prompt ] ) `` -- version '' ) # fresh prompt in this case : # BUG : Will match until previous SELECT query , if newest is e.g INSERT assert psql.ofilter ( case_query_2_prompt ) == \ results = [ stmt_res_list [ length - 3 ] , psql.ofilter ( b'SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; ' ) # in live scenarios most of the time , but I can not reproduce it with this assert p.parse_last_found_stmt ( case_empirical_1 ) == \ assert psql.ofilter ( b'\x1b [ ? 2004l\r order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004htest_db= # ' ) == \ self.tok_rev_prompt_end + \ stmt_res_list [ length - 3 ] , assert p.parse_last_found_stmt ( case_query_with_newline ) == \ # match_error : ParserElement = \ if len ( res_list ) == 4 : # results include \x1b [ ? 2004l match_prompt : ParserElement = \ stmt_res_list [ length - 4 ] ] # reverse order `` SELECT * FROM orders ; '' # case_query_3 = \ psql.ofilter ( case_query_2 ) `` sql ( 14.5 ) \nType \ '' help\ '' for help.\n\npgdb= # SELECT * FROM orders WHERE order\n_total_eur = 100 ; \n\n\n '' def check_psql_version ( self ) - > str : # ready for analysis . tok_prompt_linebreak : ParserElement = \ f.write ( str ( e.explain ( ) ) + `` \n '' ) # magic strings related to solely to ctrl-R use are assert p.parse_last_found_stmt ( case_multiline_query ) == \ # Fix it by matching rev_stmt_start also against rev_prompt version : str = self.parser.parse_psql_version ( version_info_str ) tok_rev_prompt_end : ParserElement = \ assert psql.pg4n_message == `` Test '' from shutil import get_terminal_size assert psql.ofilter ( b'\x1b [ ? 2004htest_db= # ' ) == \ `` SELECT * FROM orders WHERE order_total_eur = 100 ; '' match_select_stmt.parse_string ( no_newlines_res ) is not [ ] # complicated case : user has ctrl-R 'd , copypasted command or something . demultilined_res = no_newlines_res\ tok_stmt_end + ... + match_rev_sql_stmt_start # Broken case found in empirical testing # TODO : allow multiple statements # reverse back , concatenate , and remove \n 's # Match statement that might have \r\n or whitespace at the end . identbodychars identbodychars , nums elif len ( res_list ) == 2 : # parsing stops right after database name CaselessLiteral ( `` SELECT `` ) # All interesting stmts are 'select ' # saved stream of characters . Most likely the control streams depend def __init__ ( self , db_name_parameter : bytes , elif len ( res_list ) == 2 : # stops right after database name if version_ok : ( Literal ( `` > = '' ) | Literal ( `` # = '' ) ) + \ assert psql.ofilter ( case_query_2_prompt ) == \ version_msg = self.check_psql_version ( ) psql.ofilter ( b '' \r\n\x1b [ ? 2004l\r '' ) psql.ofilter ( b ' ; ' ) case_empirical_1 = \ # Arrow-up to previous query , alt-B until 'orders WHERE ' and remove the CaselessLiteral , Char , Combine , Literal , ParseException , \ psql.ofilter ( b'\x1b [ ? 2004l\r\x1b [ ? 2004htest_db- # ' ) # Is the statement a SELECT statement ? def __init__ ( self , psql_args : bytes , # TODO : test case for multiline - > queries `` `` '' # replacing \n 's with `` '' maybe has less edge cases . # parser tokens : return result f = open ( `` psqlparser.log '' , `` a '' ) # b'SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; ' return demultilined_res psql.ofilter ( b'\r\n\r\r\n ' ) case_query_2_prompt = b '' order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004htest_db= # `` # psql.ofilter ( b'\x08\x08 ' ) match_whole_rev_sql_stmt : ParserElement = \ Char ( '\n ' ) + Word ( prompt_chars ) + \ ( StringEnd ( ) | ( Literal ( `` ? [ \x1b '' ) psql.ofilter ( b '' \x08\x08\x08t ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_to\x1b [ 7mt\x1b [ 27mal_eur = 100 ; \x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08 '' ) else : match_version_stmt : ParserElement = \ # al_eur = 100 ; '' `` SELECT * FROM orders WHERE order_total_eur = 100 ; '' # Parse prompt text at the end , so multiline queries can be cleaned tok_rev_prompt_end b ' order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n ' + b'\r\n ' + b'Test ' + b'\r\n\r\n ' + b'\x1b [ ? 2004hpgdb= # ' psql.ofilter ( b'\r\n\x1b [ ? 2004l\r ' ) is_select : bool = False `` `` psql.ofilter ( b '' \x1b [ A\rtest_db= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; \x1b [ K\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\r\n\r '' ) psql.ofilter ( b'\x08\x08\x08\x08 ' ) # on terminal size , and can not be just copy-pasted from live tests . psql.ofilter ( b'\x08\x08\x08\x08\x08\x08 ' ) stmt_res = match_last_stmt.parse_string ( psql_rev ) b '' order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\r\nTest\r\n\r\n\x1b [ ? 2004htest_db= # `` no_newlines_res = reversed_flattened_res.replace ( '\n ' , `` ) # Something weird going these test case . Pyte understands this case right psql.ofilter ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 10\x1b [ 27m0 ; \x08\x08\x08\x08\x08\x08 '' ) assert p.parse_last_found_stmt ( case_multiple_queries_and_whitespaces ) == \ psql.ofilter ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 100\x1b [ 27m ; \x08\x08\x08\x08\x08\x08 '' ) # psql.ofilter ( b'\x08\x08\x08\x08 ' ) stmt_res : ParseResults = None stmt_res = match_rev_last_stmt.parse_string ( psql_rev ) # assert psql.ofilter ( case_query_3_prompt ) == \ tok_rev_prompt_linebreak : ParserElement = \ psql = new_psqlwrapper ( ) b '' \x1b [ A\rtest_db= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; \x1b [ K\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\r\n\r '' self.tok_rev_prompt_end version_info_str : str = bytes.decode ( version_info.before ) match_sql_stmt_end : ParserElement = \ stmt_res_list [ length - 4 ] ] `` psql ( 14.5 ) \nType \ '' help\ '' for help.\n\npgdb= # SELECT * FROM\npgdb- # orders ; '' self.match_rev_any_sql_stmt + Word ( self.prompt_chars ) : param psql : psql -- version output # reverse given string , match reversed tokens , pick first match , is_select = \ # TODO ( ? ) : We may have to match for errors # ctrl-R to previous query . Query includes a return press near end . return `` Pg4n has only been tested on psql versions `` + \ result = stmt_res.as_list ( ) [ 1 ] # multiline query # but works fine without the whitespace .. # * FROM orders WHERE order_total_eur = 100 ; # psql.ofilter ( b'\x08\x1b [ 1P ' ) # properly . # extra 2 whitespaces : ZeroOrMore ( White ( ) ) + CaselessLiteral ( `` SELECT '' ) if version_msg ! = `` '' : CaselessLiteral ( `` TCELES '' ) + ( CaselessLiteral ( `` > = '' ) | CaselessLiteral ( `` # = '' ) ) c = pexpect.spawn ( `` psql `` + bytes.decode ( self.db_name ) , match_rev_last_stmt : ParserElement = \ # psql.ofilter ( b'\x08\x08\x08\x08\x08\x08 ' ) db_name = stmt_res_list [ length - 1 ] [ : :-1 ]","['src/pg4n/psqlparser.py', 'src/pg4n/psqlwrapper.py', 'src/pg4n/test/test_psqlparser.py', 'src/pg4n/test/test_psqlwrapper.py']",2022-11-08 10:01:52+00:00,2022-12-16 17:39:42+00:00,2022-11-21 16:23:44+02:00
68,7a2404b05defc51c519424b9b8ecfc2de17e58a5,1.0338359061279334e-05,1,"Find out idiomatic ways to configure python programs . Command-line arguments might not be practical , as the program takes psql arguments also . Configurable things could be like disabling specific semantic error warnings , or maybe passing passwords . Associated issues # 61",Configuring the program,Merge pull request # 78 from Project-C-SQL/feat/config,"for config_fname in config_fnames : from os import getcwd , getenv return config_values assert config_values [ `` SubquerySelect '' ] == False if match : = ConfigParser._option_matcher.match ( line ) : file=sys.stderr , from .config_parser import ConfigParser iNnErOrDeRbY true # CmpDomains false output_line = line.rstrip ( `` \n '' ) f '' error : unable to read config file : ' { config_fname } ' '' , for key in multiply_defined_options : SeenOptionContext ( ) ) def test_parse ( ) : def _optval_to_bool ( self , optval : str ) - > bool : parser = ConfigParser ( tmp_file ) # # 3 # # jkelm el el e fields = ConfigValues.__annotations__.keys ( ) # Needed for bytes containing files from .. config_values import ConfigValues for field in fields : for k , v in new_config_values.items ( ) : from typing import TypedDict cwd = os.getcwd ( ) print ( class ConfigParser : line = bytes.decode ( line , `` utf-8 '' ) if os.path.isfile ( cwd_config_path ) : # configuration file output is not tested because its system dependent self.file.seek ( 0 ) config_fnames = [ ] # in configuration file : ' . * ' except Exception as e : return field # As a Last resort , we check the current directory for a config file . # line 7 : 'InnerOrderBy true ' assert config_values is not None return True print ( multiply_defined_options.add ( key ) if os.path.isfile ( home_config_path ) : ) if key in [ x.key for x in seen_option_contexts ] : # `` '' '' try : return None ImpliedExpression : bool config_fnames.append ( cwd_config_path ) convert that user written value to the proper one that matches the import os.path The configuration files are read in order from : config_parser = ConfigParser ( config_file ) line = str ( line ) # Not so brilliant computational complexity # line 8 : 'InnerOrderBy true ' if len ( config_fnames ) == 0 : line_number : int home = getenv ( `` HOME '' ) from .config_values import ConfigValues _option_matcher : re.Pattern = re.compile ( file=sys.stderr , key = self._convert_from_anycase_to_propercase ( optname ) print ( import sys # CONFIG1 = `` '' '' ImpliedExpression false output_line = line.rstrip ( `` \n '' ) if match : = ConfigParser._empty_line_matcher.match ( line ) : if xdg_config_home : from typing import Optional if hasattr ( e , `` errno '' ) : fields in ConfigValues class . config_values [ key ] = self._optval_to_bool ( ImpliedExpression yes seen_option_lines += f '' line { ctx.line_number } : ' { ctx.line } '\n '' CmpDomains : bool # The following stuff is for improved error messages Converts config file option value string into bool . /etc/pg4n/config , $ XDG_CONFIG_HOME/pg4n/config , or if tmp_file.seek ( 0 ) if match : = ConfigParser._comment_matcher.match ( line ) : INNERORDERBY true self.file : TextIO = file if optval.lower ( ) in false_values : # Contains all the key-value pairs meaningful in a config file . seen_option_contexts.append ( if optval.lower ( ) in true_values : # line 1 : 'ImpliedExpression false ' _empty_line_matcher : re.Pattern = re.compile ( r '' ^\s * $ '' ) ) # # # # # # # # # # # # # # # # # # # # # # Users can write option values case-insensitively . We still need to # line 6 : 'InnerOrderBy true ' assert config_values [ `` CmpDomains '' ] == False assert config_values [ `` InnerOrderBy '' ] == True Assumes that anycase_key matches some option name case-insensitively . false_values = ( `` false '' , `` 0 '' , `` no '' ) def __init__ ( self ) : _comment_matcher : re.Pattern = re.compile ( r '' ^\s * # + . * $ '' ) `` `` '' # ImpliedExpression 1 class SeenOptionContext : # # # # # # # # # config_fnames.append ( custom_config_home_path ) class ConfigValues ( TypedDict ) : if isinstance ( line , bytes ) : if anycase_key.lower ( ) == field.lower ( ) : f '' error : unable to get current working directory ' { e } ' '' , file=sys.stderr multiply_defined_options = set ( ) return config_values if len ( config_values ) > 0 else None innerorderby true config_values [ k ] = v f '' warning : unable to parse line { line_number } : ' { output_line } ' in configuration file : ' { self.file.name } ' '' , def _convert_from_anycase_to_propercase ( self , anycase_key : str ) - > str : # Gives too many false positives from tempfile import TemporaryFile from dataclasses import dataclass # file CONFIG # def test_multiple_option_definition_warings ( ) : if optname.lower ( ) in optnames : from typing import Optional , TextIO # This is the matching output of running the program that reads only 1 config for line_number , line in enumerate ( self.file.readlines ( ) ) : true_values = ( `` true '' , `` 1 '' , `` yes '' ) assert config_values [ `` ImpliedExpression '' ] == True ) else : with open ( config_fname , `` r '' ) as config_file : CONFIG_FILE_NAME = `` pg4n.conf '' xdg_config_home = getenv ( `` XDG_CONFIG_HOME '' ) CmpDomains false # # # `` `` '' seen_option_contexts : list [ SeenOptionContext ] = [ ] # str ( match.group ( `` optval '' ) ) def read ( self ) - > Optional [ ConfigValues ] : seen_option_lines = `` '' pass def parse ( self ) - > Optional [ ConfigValues ] : import re # warning : option 'ImpliedExpression ' is set multiple times file=sys.stderr , cwd_config_path = cwd + `` / '' + CONFIG_FILE_NAME if new_config_values is not None : ) Excepts only valid option values . # warning_matcher = re.compile ( \ with TemporaryFile ( buffering=0 ) as tmp_file : key : str else : # TODO : The actual test tmp_file.flush ( ) Reads config values from file givein in __init__ . if os.path.isfile ( custom_config_home_path ) : each new value introduced in latter files overriding the previous value . return False else : # To make this work with bytes objects like TemporaryFile contents def __init__ ( self , file : TextIO ) : f '' error : unable to read config file : ' { config_fname } ' [ str ( { e.errno } ) ] '' , new_config_values : ConfigValues = config_parser.parse ( ) etc_config_path = `` /etc/ '' + CONFIG_FILE_NAME optnames = [ x.lower ( ) for x in ConfigValues.__annotations__.keys ( ) ] try : for ctx in filter ( lambda x : x.key == key , seen_option_contexts ) : # InnerOrderBy true line : str # This is the config file CONFIG = `` '' '' ImpliedExpression 0 f '' warning : bad warning name or value in line { line_number } : ' { output_line } ' in configuration file : ' { self.file.name } ' '' , SubquerySelect : bool except Exception as e : home_config_path = home + `` /.config/ '' + CONFIG_FILE_NAME flags=re.IGNORECASE , # line 5 : 'InnerOrderBy true ' else : optname = match.group ( `` optname '' ) if os.path.isfile ( etc_config_path ) : SubquerySelect 0 # line 2 : 'ImpliedExpression 1 ' custom_config_home_path = xdg_config_home + `` / '' + CONFIG_FILE_NAME continue config_fnames.append ( home_config_path ) config_fnames.append ( etc_config_path ) # line 4 : 'InnerOrderBy true ' return False r '' \s * ( ? P < optname > \w+ ) \s+ ( ? P < optval > 1|0|true|false|yes|no ) \s * $ '' , # ) InnerOrderBy true $ XDG_CONFIG_HOME is not set , from $ HOME/.config/pg4n/config , class ConfigReader : f '' warning : option ' { key } ' is set multiple times\n { seen_option_lines } in configuration file : ' { self.file.name } ' '' , # line 10 : 'InnerOrderBy true ' InnerOrderBy : bool # SubquerySelect yes tmp_file.write ( bytes ( CONFIG , `` utf-8 '' ) ) config_values : ConfigValues = { } config_values : Optional [ ConfigValues ] = parser.parse ( ) key=key , line=line.rstrip ( `` \n '' ) , line_number=line_number from .. config_parser import ConfigParser assert False , f '' { e } ''","['src/pg4n/config_parser.py', 'src/pg4n/config_reader.py', 'src/pg4n/config_values.py', 'src/pg4n/test/test_config_parser.py']",2022-11-10 10:29:55+00:00,2022-11-21 20:39:06+00:00,2022-11-21 22:39:05+02:00
79,535fdf800713ce7b74f1e330e9c02af0bb981db2,1.0247560567222536e-05,1,"Removing ` \n 's is a tough problem , see ought to replace \n with ` ` to avoid ` SELECT * FROM ` .",Edge cases with newlined psql queries,Merge pull request # 95 from Project-C-SQL/feat/error-handling-and-syntax-error-detection,"stmt_chars : str = printable.translate ( str.maketrans ( `` '' , `` '' , stmt_end ) ) # for optimization reasons , check output only if len ( ) > 1 , so keyboard encoding= '' utf-8 '' , if prompt_res : : returns : if user has indeed hit return . print_msg + `` \r\n\r\n '' `` `` '' Initiate session by getting psql connection parameters via psql \ self.pg_pass , : param psql : screenscraped psql string with only whitespace \ Literal , analysis_result : Optional [ str ] = None control codes . \n is newline ( carriage return \r will be added by \ match_version_stmt : ParserElement = ( def _check_psql_version ( self ) - > str : self.pg4n_message = `` '' assert psql.ofilter ( b'\x1b [ ? 2004htest_db= # ' ) == \ latest_output : bytes hook_syntax_f : Callable [ [ str ] , str ] , `` - * # '' , `` * * # '' , `` \ ' * # '' , `` \ '' * # '' , `` $ * # '' , `` ( * # '' , EqWildcardChecker ( sanitized_sql , qep_analysis ) .check ( ) # This will match against `` % R % x % # `` , e.g `` - > `` . from functools import reduce ) # ( Return is always at least 2 length ) output : bytes # Implied expression Stream ( potential_future_screen ) prompt_res : ParseResults = None `` `` '' Parse for weird Return presses . if magical_return_res : psql.ofilter ( b'\x08\x08 ' ) `` SELECT * FROM orders WHERE order_total_eur = 100 ; '' psql.ofilter ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 100\x1b [ 27m ; \x08\x08\x08\x08\x08\x08 '' ) from .psqlwrapper import PsqlWrapper # TODO/BUG : removing \n 's is a tough problem , see : from typing import Optional , Tuple : param prompt : is output where message is injected to . A fresh prompt \ self.pg4n_message = `` '' self stmt_res : Optional [ ParseResults ] = None tok_rev_prompt_end : ParserElement = Combine ( # Strange HAVING clause without GROUP BY output to pyte screen for future screen-scraping . White , from .psqlwrapper import PsqlWrapper # % R = - , * , ' , `` ; also $ , ( # cheaper and easier to reverse & start from the end from pyparsing import \ def check_and_act_on_repl_output ( self , latest_output : bytes ) - > bytes : qep_analysis : QEPAnalysis = QEPParser ( conn=conn ) .parse ( sql_query ) ... # as interesting things usually are at end of a long string . # Based on exploratory testing , self.pg_tuple = ( ) - > Optional [ Tuple [ str , str , str , str , str ] ] : results = [ to pick up relevant SQL statements for the hook function . self.tok_pre_database + self.tok_database + \ to pick up relevant SQL statements and syntax errors for hook functions . '' '' '' ZeroOrMore ( White ( ) ) + tok_stmt_end + ... + \ pg_port : str , identbodychars , results = [ stmt_res_list [ 3 ] , main.py [ psql arguments ] < database name > '' ) parsed_sql_query : str = \ control codes and newlines ( without carriage returns ) . conn ) .check ( ) ZeroOrMore , `` `` '' Parse for an empty prompt , to detect when a query \ identbodychars , nums if split_prompt == [ ] : new_output : bytes = self._check_and_act_on_repl_output ( output ) ( StringEnd ( ) # output may stop at end of db name , list , facilitating easy message injection . demultilined_res : str = no_newlines_res tok_stmt_end : ParserElement = Char ( ' ; ' ) sanitized_sql : exp.Expression = sql_parser.parse_one ( sql_query ) # Literal ( '\ '' ' ) | Literal ( ' $ ' ) | Literal ( ' ( ' ) ) Literal , Word , \ e.explain ( ) ) results : list [ str ] = [ ] screen : str = \ tok_rev_error : ParserElement = Literal ( `` : RORRE '' ) ) - > None : self.tok_pre_port + self.tok_port if version == `` '' : stmt_res_list [ length - 3 ] , # and resulting message is saved here until when new prompt comes in sql_query , `` port= '' + self.pg_port `` - ? > '' , `` * ? > '' , `` \ ' ? > '' , `` \ '' ? > '' , `` $ ? > '' , `` ( ? > '' ] line.rstrip ( ) for line in self.pyte_screen.display ) # If we have a semantic error message waiting # If there is a fresh prompt : assert psql._intercept ( fresh_prompt_1 ) == \ ] analysis_result = StrangeHavingChecker ( psql._intercept ( b'SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; ' ) sem_router = SemanticRouter ( * conn_info ) psql.ofilter ( b '' \x08\x08\x08= ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m=\x1b [ 27m 100 ; \x08\x08\x08\x08\x08\x08 '' ) def ifilter ( self , input : bytes ) - > bytes : def run_analysis ( self , sql_query : str ) - > str : # for matching . psql.ofilter ( b'\x08\x08\x08\x08 ' ) ) `` `` '' Parse for an empty prompt and everything preceding it \ psql._intercept ( b'\r\x1b [ K\x1b > \x1b [ r\x1b [ ? 1049l ' ) debug : bool = False psql._intercept ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C1 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 1\x1b [ 27m00 ; \x08\x08\x08\x08\x08\x08 '' ) sanitized_sql , results : List [ str ] = [ ] `` - ! > '' , `` * ! > '' , `` \ ' ! > '' , `` \ '' ! > '' , `` $ ! > '' , `` ( ! > '' , `` `` '' Check for weird Return presses . sql_query : str # Since latest_output contains error details , we will have to pg_user : str , def test_parse_new_prompt ( ) - > None : return `` '' : returns : a two-part list with everything before the prompt \ # magic strings ( related at least to ctrl-R use ) are psql._intercept ( b'\r\n ' ) lambda x , y : x + y , sys.argv [ 1 : ] , `` '' `` `` '' Handle semantic analysis modules . '' '' '' StrangeHavingChecker ( sanitized_sql , qep_analysis ) .check ( ) return `` '' # No semantic errors found print ( `` pg4n [ psql arguments ] < database name > '' ) analysis_result = SubquerySelectChecker ( self.parser.parse_new_prompt_and_rest ( psql.start ( ) stmt_res_list [ length - 4 ] psql.ofilter ( b'SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; ' ) # tok_multiline_prompt_end : ParserElement = \ # line and then the prompt , to allow easy message injection . if analysis_result is not None : version_msg = self.check_psql_version ( ) if self.parser.output_has_new_prompt ( `` `` '' User input filter function for pexpect.interact : not used . self.pg_port , psql._intercept ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 10\x1b [ 27m0 ; \x08\x08\x08\x08\x08\x08 '' ) ... + StringEnd ( ) ) ) c = pexpect.spawn ( `` psql `` + bytes.decode ( self.psql_args ) , return self.pg_tuple # SELECT in subquery # just match against a list of all possible combinations # `` pgdb= > SELECT `` psql `` psql.ofilter ( b'\x08order_total_eur = 0 AND order_total_eur = 10\x1b [ C\x1b [ 1P ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) match_rev_prompt_end : ParserElement = \ # `` \r\n\x1b [ ? 2004l\r '' , `` \r\n\r\r\n '' and `` \x08\r\n '' . from functools import reduce self.parser.parse_syntax_error ( potential_future_contents ) from .psqlconninfo import PsqlConnInfo List is empty if no fresh prompt was found . # Reversing happens for performance reasons , : returns : an empty list if no prompt found . Otherwise has [ ' > = ' ] or \ bytes.decode ( latest_output ) stmt_res_list [ length - 4 ] ] SubqueryOrderByChecker ( sanitized_sql , qep_analysis ) .check ( ) # debug creates pyte.screen ( current screenscraping context ) and `` `` '' Parse for syntax error output . `` `` '' Forward output to ` check_and_act_on_repl_output ( ) ` and feed \ ) .check ( ) def output_has_new_prompt ( self , psql : str ) - > bool : pg_name : str sys.argv [ 1 ] .encode ( `` utf-8 '' ) , sql_parser : SqlParser = SqlParser ( conn ) # no syntax error analysis : `` host= '' + self.pg_host def parse_syntax_error ( self , psql : str ) - > str : line.rstrip ( ) for line in self.pyte_screen.display ) ) # 'rev ' in variable names is shorthand for reversed . # asterisk unpacks the 5-tuple magical_return_res : Optional [ ParseResults ] = None split_prompt : List [ str ] = self.parser.parse_new_prompt_and_rest ( assert p.parse_last_stmt ( case_multiline_query ) == \ if analysis_result is not None : return has_magical_return hook_semantic_f : Callable [ [ str ] , str ] , ) - > bytes : psql._intercept ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 100\x1b [ 27m ; \x08\x08\x08\x08\x08\x08 '' ) : returns : a two-part list with everything before the prompt \ results = [ `` , match_rev_prompt_end : ParserElement = self.tok_rev_prompt_end : returns : a prompt with injected message . # Turn on verbose output to psqlparser.log file in working directory `` user= '' + self.pg_user `` `` '' Detect when psql query evaluation has ended by parsing for a new prompt . def test_ofilter ( ) - > None : analysis_result : Optional [ str ] = None magical_return_res = \ import os stmt_chars : str = \ line.rstrip ( ) for line in potential_future_screen.display analysis_result = \ # Literal ( `` ERROR : '' ) def test_output_has_new_prompt ( ) - > None : assert p.parse_last_stmt ( case_select_then_select ) == \ : returns : unchanged input . psql._intercept ( return_press_1 ) assert p.parse_last_found_stmt ( case_empirical_1 ) == \ ' . ' match_rev_any_sql_stmt .replace ( db_name + `` - # '' , `` '' ) except ParseException : self.parser.parse_last_found_stmt ( screen ) str ( self.supported_psql_versions ) + `` . '' `` `` '' wrapper ) . def main ( ) - > None : [ `` - # '' , `` * # '' , `` \ ' # '' , `` \ '' # '' , `` $ # '' , `` ( # '' , evaluation has ended . qep_analysis print ( f '' { os.path.basename ( sys.executable ) } \ if magical_return_res : def test_parse_magical_return ( ) - > None : # Licensed under MIT . are received . assert p.output_has_new_prompt ( case_mixed_results ) assert p.parse_last_found_stmt ( case_select_then_insert ) == \ has_magical_return = True psql.ofilter ( b '' \r\n\x1b [ ? 2004l\r '' ) CaselessLiteral ( `` SELECT '' ) match_error_statement : ParserElement = ( # If we have a semantic error message waiting and there is a fresh return ( self.pg_host , '' , # save a potential warning to be included in before next fresh prompt . split_prompt [ 1 ] , # % R = = , ^ # % / % R % x % # per postgres bin/psql/settings.h sem_router = SemanticRouter ( * conn_info ) # asterisk unpacks the 5-tuple lambda x : `` '' , self.pg4n_message = self.analyze ( parsed_sql_query ) : returns : if output has a weird Return press . StringEnd ( ) psql._intercept ( b'\x08\x08\x08\x08 ' ) def __init__ ( self , psql_args : str ) : # Parsing functions common to more than 1 parsing functions are listed here reversed_flattened_res : str = \ psql_rev : str = psql [ : :-1 ] # psqlwrapper.log ( capturing terminal stream ) in working directory match_rev_any_sql_stmt : ParserElement = \ : param hook_semantic_f : is a callback to which scraped SQL queries are\ ParserElement , | Literal ( `` \r\n\r\r\n '' [ : :-1 ] ) \ no_newlines_res = reversed_flattened_res.replace ( '\n ' , ' ' ) # superusers have = # prompt ( StringEnd ( ) | ( Literal ( `` ? [ \x1b '' ) # semantic analysis : self.tok_pre_host + self.tok_host + \ if self.parser.parse_magical_return ( psql.ofilter ( b'\x08\x08\x08\x08\x08\x08 ' ) `` SELECT * FROM orders WHERE order_total_eur = 100 ; '' for multiline_prompt_end in self.multiline_prompt_ends : def _check_and_act_on_repl_output ( has_new_prompt : bool = False return bytes ( split_prompt [ 0 ] + `` \r\n '' # Implied expression # should convert \n - > `` `` to avoid `` SELECT * FROM .. '' . psql.ofilter ( case_query_1 ) # Opt ( Literal ( ' * ' ) | Literal ( ' ! ' ) | Literal ( ' ? ' ) , `` '' ) psql.ofilter ( b'\r\x1b [ C ' ) # feed query to semantic analysis hook function [ ' # = ' ] . if prompt_res : self.pg_pass , psql_output = pexpect.spawn ( from shutil import get_terminal_size prompt_res = match_rev_prompt_and_then_rest.parse_string ( psql_rev ) self , # keyboard input does not trigger parsing Combine , dimensions= ( self.rows , self.cols ) ) ParseResults , ParserElement , StringEnd , White , Word , ZeroOrMore , \ stmt_res_list [ 2 ] , : param hook_f : is a callback to which scraped SQL queries are passed \ assert p.parse_last_found_stmt ( case_select_then_select ) == \ psql._intercept ( case_psql_start ) Literal ( `` psql ( PostgreSQL ) `` ) + Combine ( Word ( nums ) + ' . ' + Word ( nums ) ) prompt_res = match_rev_prompt_end.parse_string ( psql_rev ) elif len ( res_list ) == 2 : # parsing stops right after database name ] respectively . bytes.decode ( latest_output ) ) ! = [ ] : # there is new prompt analysis_result = CmpDomainChecker ( sanitized_sql , columns ) .check ( ) has_magical_return : bool = False `` utf-8 '' ) assert p.parse_last_found_stmt ( case_query_with_newline ) == \ columns `` utf-8 '' tok_rev_error `` - > '' , `` * > '' , `` \ ' > '' , `` \ '' > '' , `` $ > '' , `` ( > '' , from pyparsing import ( # get terminal screen contents # % # = # , > res_list [ 2 ] [ : :-1 ] tok_rev_prompt_end self.tok_pre_port + self.tok_port + \ ZeroOrMore ( White ( ) ) + CaselessLiteral ( `` SELECT '' ) psql._intercept ( b'\x08order_total_eur = 0 AND order_total_eur = 10\x1b [ C\x1b [ 1P ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) c.interact ( input_filter=lambda x : x , output_filter=self._intercept ) pg_user : str , def test_parse_last_found_stmt ( ) - > None : self.semantic_analyze : Callable [ [ str ] , str ] = hook_semantic_f psql._intercept ( b'\r\x1b [ C ' ) print ( e.explain ( ) ) self.tok_rev_prompt_end psql_args : str # `` = > SELECT * FROM orders WHERE order_tot PsqlParser ( ) assert p.parse_last_found_stmt ( case_trivial ) == \ tok_marker_caret # feed query to hook function and save resulting message `` `` '' Check PostgreSQL version via psql child process and match \ assert p.parse_last_stmt ( case_select_then_insert ) == \ self.syntax_analyze : Callable [ [ str ] , str ] = hook_syntax_f pexpect.spawn ( `` psql `` + bytes.decode ( self.psql_args ) with psycopg.connect ( # Comparing different domains psql._intercept ( case_query_1 ) self.pg_name ) # `` \r\n\x1b [ ? 2004l\r '' , `` \r\n\r\r\n '' and `` \x08\r\n '' . psql.ofilter ( b'SELECT ' ) self.pg_port , def output_has_magical_return ( self , psql : str ) - > bool : psql._intercept ( b'FROM ' ) c.interact ( input_filter=self.ifilter , version_msg = self._check_psql_version ( ) def parse_magical_return ( self , psql : str ) - > List [ str ] : ) as conn : self.tok_pre_user + self.tok_user stmt_res_list [ 1 ] ] version_info = pexpect.spawn ( res_list [ 1 ] [ : :-1 ] + res_list [ 0 ] [ : :-1 ] stmt_res : ParseResults = None self.tok_rev_prompt_end self.pg_user , return prompt # prompt is malformed and is returned as-is . : param db_name_parameter : is name of database we are connecting to . match_rev_last_stmt : ParserElement = \ match_rev_any_sql_stmt : ParserElement = ( no_newlines_res = unreversed_flattened_res.replace ( '\n ' , ' ' ) match_version_stmt : ParserElement = \ analysis_result = EqWildcardChecker ( psql._intercept ( b'\x08order_total_eur = 0 AND order_total_eur = 1\x1b [ 1P00 ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) import sys ZeroOrMore ( Char ( `` \n '' ) | Char ( `` \r '' ) | White ( ) ) return new_output res_list [ 2 ] [ : :-1 ] + res_list [ 1 ] [ : :-1 ] + res_list [ 0 ] [ : :-1 ] c = pexpect.spawn ( return input | ( # or continue \x1b [ ? .. ParserElement.setDefaultWhitespaceChars ( `` ) psql.ofilter ( b'orders ' ) # rev means reversed , these are for performance reasons . ParseException , ParserElement , \ from functools import reduce ( Literal ( ' # ' ) | Literal ( ' > ' ) ) # optimization : do not spend time parsing if there is no message : psql.ofilter ( b ' ; ' ) if output [ 0:2 ] == b '' \r\n '' : def ofilter ( self , output : bytes ) - > bytes : psql._intercept ( b'\x1b [ ? 2004l\r\x1b [ ? 1049h\x1b=\r order_id | order_total_eur | customer_id \x1b [ m\r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\x1b [ m\r\n 1 | 535.36 | 111\x1b [ m\r\n 2 | 409.80 | 217\x1b [ m\r\n 3 | 189.43 | 19\x1b [ m\r\n 4 | 144.14 | 157\x1b [ m\r\n 5 | 582.52 | 172\x1b [ m\r\n 6 | 132.85 | 206\x1b [ m\r\n 7 | 183.92 | 236\x1b [ m\r\n 8 | 424.80 | 244\x1b [ m\r\n 9 | 519.43 | 175\x1b [ m\r\n 10 | 414.55 | 234\x1b [ m\r\n 11 | 88.19 | 50\x1b [ m\r\n 12 | 591.72 | 143\x1b [ m\r\n 13 | 503.52 | 216\x1b [ m\r\n 14 | 586.06 | 181\x1b [ m\r\n 15 | 47.79 | 248\x1b [ m\r\n 16 | 330.92 | 130\x1b [ m\r\n 17 | 302.31 | 225\x1b [ m\r\n 18 | 438.38 | 26\x1b [ m\r\n 19 | 107.53 | 94\x1b [ m\r\n 20 | ' results = [ stmt_res_list [ length - 3 ] , if stmt_res : psql._intercept ( b'\x08\x08\x08\x08\x08\x08 ' ) # `` pgdb= > SELECT * FROM orders WHERE order_tot match_rev_magical_returns.parse_string ( psql_rev ) Opt ( White ( ) ) match_rev_last_stmt : ParserElement = ( split_prompt : List [ str ] = \ : param prompt : is where the message is injected . A fresh prompt is \ match_psql_conninfo : ParserElement = ( if len ( res_list ) == 2 : # parsing stops right after database name # TODO ( ? ) : We may have to match for errors : returns : syntax error message from 'ERROR : ' to last '^ ' . parser : PsqlParser name . potential_future_screen = \ return `` Pg4n has only been tested on psql versions `` + \ psql._intercept ( b '' \r\n\x1b [ ? 2004l\r '' ) `` `` '' Parse for a fresh prompt and everything preceding it into 2-length \ `` port= '' + self.pg_port : returns : if user has hit return . # Replacing \n 's has some edge cases where wrapper transparency assert p.parse_last_stmt ( case_empirical_1 ) == \ if self.pg4n_message ! = `` '' : `` user= '' + self.pg_user ) : ) - > str : # replacing \n 's with `` '' maybe has less edge cases . Or actually more . [ `` > = '' ] def test_output_has_magical_return ( ) - > None : [ `` \rl4002 ? [ \x1b\n\r '' ] res_list [ 3 ] [ : :-1 ] , def get ( intercepted queries and syntax errors . # command-line arguments prevent interactive sessions ( e.g pg4n -- help ) `` psql `` + bytes.decode ( self.psql_args ) + `` -- version '' Word ( self.prompt_chars ) otherwise a warning message . bytes.decode ( output , `` utf-8 '' ) ) ! = [ ] : sql_parser : SqlParser = SqlParser ( conn ) return results StringEnd , assert p.output_has_magical_return ( case_long_return ) self.tok_pre_user + self.tok_user + \ assert p.parse_magical_return ( case_long_return ) == \ reduce ( lambda x , y : x + y [ : :-1 ] , results , `` '' ) expected . if syntax_error ! = `` '' : : returns : ( hostname , port , user , password , database name ) \ return `` '' # No semantic errors found from .semanticrouter import SemanticRouter [ `` # = '' ] Otherwise has newline text . Word ( nums ) psql.ofilter ( b'\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) # This will match against `` % R % x % # `` , e.g `` = > `` . `` - ! # '' , `` * ! # '' , `` \ ' ! # '' , `` \ '' ! # '' , `` $ ! # '' , `` ( ! # '' , CaselessLiteral , # Wildcards without LIKE ) # e.g . `` pg4n -- help '' is being run . assert psql.ofilter ( fresh_prompt_1 ) == \ # Inconsistent expression pg_port : str , def check_psql_version ( self ) - > str : try : match_select_stmt : ParserElement = ( reduce ( lambda x , y : x + y [ : :-1 ] , results , `` '' ) sanitized_sql : exp.Expression = sql_parser.parse_one ( sql_query ) # should parse as \n - > `` '' split_prompt [ 1 ] , new_output : bytes = self._replace_prompt ( latest_output ) return new_output : returns : a prompt with injected message , or unchanged if \ # Inconsistent expression deepcopy ( self.pyte_screen ) name . '' '' '' Char , return analysis_result Literal ( `` \r\n\x1b [ ? 2004l\r '' [ : :-1 ] ) self.pg_name assert p.output_has_new_prompt ( case_trivial ) tok_marker_caret : ParserElement = Literal ( `` ^ '' ) psql.ofilter ( b'\r\x1b [ K\x1b > \x1b [ r\x1b [ ? 1049l ' ) potential_future_screen_output_sink.feed ( from .psqlconninfo import PsqlConnInfo prompt_res = match_rev_prompt_end.parse_string ( psql_rev ) output to pyte screen for screenscraping . psql.ofilter ( b'\x1b [ ? 2004l\r\x1b [ ? 1049h\x1b=\r order_id | order_total_eur | customer_id \x1b [ m\r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\x1b [ m\r\n 1 | 535.36 | 111\x1b [ m\r\n 2 | 409.80 | 217\x1b [ m\r\n 3 | 189.43 | 19\x1b [ m\r\n 4 | 144.14 | 157\x1b [ m\r\n 5 | 582.52 | 172\x1b [ m\r\n 6 | 132.85 | 206\x1b [ m\r\n 7 | 183.92 | 236\x1b [ m\r\n 8 | 424.80 | 244\x1b [ m\r\n 9 | 519.43 | 175\x1b [ m\r\n 10 | 414.55 | 234\x1b [ m\r\n 11 | 88.19 | 50\x1b [ m\r\n 12 | 591.72 | 143\x1b [ m\r\n 13 | 503.52 | 216\x1b [ m\r\n 14 | 586.06 | 181\x1b [ m\r\n 15 | 47.79 | 248\x1b [ m\r\n 16 | 330.92 | 130\x1b [ m\r\n 17 | 302.31 | 225\x1b [ m\r\n 18 | 438.38 | 26\x1b [ m\r\n 19 | 107.53 | 94\x1b [ m\r\n 20 | ' ) except ParseException as e : passed to , and from which corresponding semantic warning messages are \ prompt_res : Optional [ ParseResults ] = None ImpliedExpressionChecker ( sanitized_sql , sql_query , f.write ( psql._intercept ( b'\x1b [ ? 2004l\r\x1b [ ? 2004htest_db- # ' ) # an insightful syntax error message from the syntax analysis . # SELECT in subquery self.pg_tuple : Optional [ Tuple [ str , str , str , str , str ] ] = None def parse_new_prompt_and_rest ( self , psql : str ) - > List [ str ] : self.tok_pre_database + self.tok_database psql._intercept ( b'orders ' ) if self.debug : pg_host : str , psql_rev = psql [ : :-1 ] analysis_result = InconsistentExpressionChecker ( unreversed_flattened_res : str = reduce ( parsed_sql_query : str = self.parser.parse_last_stmt ( screen ) Combine ( pg_name : str stmt_res = match_error_statement.parse_string ( psql_rev ) # prompt2 per bin/psql/prompt.c : # for simplicity , just use pexpect here bytes.decode ( prompt , `` utf-8 '' ) CaselessLiteral , Char , Combine , Literal , ParseException , \ ... # has already been parsed as prompt_chars # match_error : ParserElement = \ screen : str = '\n'.join ( # prompt : # from .inconsistent_expression_checker import InconsistentExpressionChecker print_msg + `` \r\n\r\n '' psql.ofilter ( return_press_1 ) encoding= '' utf-8 '' , unreversed_flattened_res : str = \ def __init__ ( self , psql_args : bytes , stmt_res_list = stmt_res.as_list ( ) Char ( ' ; ' ) def parse_last_stmt ( self , psql : str ) - > str : f.close ( ) import pexpect # should convert \n - > `` '' to avoid `` order_tot al_eur '' `` dbname= '' + self.pg_name magical_return_res = \ detecting new prompt fails . str ( self.supported_psql_versions ) from pyparsing import Literal , Word , ParseException , ParserElement , \ new_output : bytes = `` '' # Strange HAVING clause without GROUP BY res_list = prompt_res.as_list ( ) `` - * > '' , `` * * > '' , `` \ ' * > '' , `` \ '' * > '' , `` $ * > '' , `` ( * > '' , self.tok_rev_prompt_end # Semantic analysis is always done when user presses Return psql = PsqlWrapper ( psql.ofilter ( b'\x08order_total_eur = 0 AND order_total_eur = 1\x1b [ 1P00 ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) res_list = prompt_res.as_list ( ) psql._intercept ( b '' \x1b [ A\rtest_db= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; \x1b [ K\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\r\n\r '' ) sem_router.run_analysis , assert psql.ofilter ( b'\x1b [ ? 2004l\r order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004htest_db= # ' ) == \ assert p.parse_new_prompt ( case_trivial ) == \ self.pg4n_message = self.semantic_analyze ( parsed_sql_query ) `` . '' # To save time , since linebreak prompts are only removed , # Replacing \n 's with `` `` seems to have less edge cases . ParseException , # AND-clause will stop executing after first False . Word ( nums ) new_output = self._replace_prompt ( latest_output ) # Wildcards without LIKE Only one ( static ) class instance is intended for use in program . print ( bytes.decode ( psql_output.before ) ) pg_pass : str , # % x = nothing , * , ! , ? from typing import Optional bytes.decode ( output , `` utf-8 '' ) has_new_prompt = True ) : ... self | Literal ( `` \x08\r\n '' [ : :-1 ] ) and then starting the session . '' '' '' analysis_result = SumDistinctChecker ( except ParseException as e : from .psqlparser import PsqlParser assert p.parse_last_stmt ( case_query_with_newline ) == \ magical_return_res : ParseResults = None psql._intercept ( b'\x1b [ ? 2004htest_db- # ' ) is expected , or otherwise no injection is made . ] SumDistinctChecker ( sanitized_sql , qep_analysis ) .check ( ) with psycopg.connect ( `` host= '' + self.pg_host columns : list [ Column ] = sql_parser.get_query_columns ( sanitized_sql ) potential_future_contents : str = '\n'.join ( if self.pg4n_message ! = `` '' \ if stmt_res is not None : def __init__ ( `` password= '' + self.pg_pass | Literal ( `` \r\n\r\r\n '' [ : :-1 ] ) if len ( res_list ) == 4 : # results include \x1b [ ? 2004l syntax_error = \ ) : multiline_prompt_ends : list [ str ] = \ # either by only having single element , or using Combine to squash sql_parser hook_f : Callable [ [ str ] , str ] , parser : PsqlParser ) : output_filter=self.ofilter ) demultilined_res = demultilined_res.replace ( prompt , `` '' ) match_select_stmt : ParserElement = \ match_psql_conninfo : ParserElement = \ assert p.parse_last_stmt ( case_multiple_queries_and_whitespaces ) == \ Word ( self.prompt_chars ) + \ potential_future_screen_output_sink = \ Opt ( Literal ( ' * ' ) | Literal ( ' ! ' ) | Literal ( ' ? ' ) , `` '' ) def parse_last_found_stmt ( self , psql : str ) - > str : psql.ofilter ( b'FROM ' ) printable.translate ( str.maketrans ( `` '' , `` '' , stmt_end ) ) psql.ofilter ( b'\r\n\x1b [ ? 2004l\r ' ) qep_analysis : QEPAnalysis = QEPParser ( conn=conn ) .parse ( sql_query ) columns : list [ Column ] = sql_parser.get_query_columns ( sanitized_sql ) : returns : an empty list if no presses are found . \ match_rev_magical_returns : ParserElement = \ tok_stmt_end : ParserElement = \ results = magical_return_res.as_list ( ) psql._intercept ( b ' * ' ) assert psql._intercept ( case_query_2_prompt ) == \ conn if conn_info is not None : def parse_new_prompt ( self , psql : str ) - > List [ str ] : def test_parse_last_stmt ( ) - > None : self.match_rev_any_sql_stmt + Word ( self.prompt_chars ) psql._intercept ( b'\x08\x08 ' ) f.write ( '\n'.join ( psql_rev : str = psql [ : :-1 ] # slicing is fastest operation for reverse and self.parser.parse_new_prompt ( psql_output.expect ( pexpect.EOF ) # Psql is not connecting to any database , Opt , # Analysis is always done when user presses Return def parse_new_prompt_and_rest ( self , psql : str ) - > list [ str ] : messages are passed to , and from which corresponding warning messages \ pg_pass : str , self.pg4n_message = self.syntax_analyze ( syntax_error ) psql.ofilter ( case_psql_start ) ) psql.ofilter ( b'\r\n\r\r\n ' ) # `` = > SELECT psql._intercept ( b'SELECT ' ) f.write ( str ( e.explain ( ) ) + `` \n '' ) split_prompt [ 0 ] + `` \r\n '' from typing import List to and from which semantic error messages are received in return . def start ( def _intercept ( results = [ nums : param psql : screenscraped psql string analysis_result = CmpDomainChecker ( # ( Literal ( '- ' ) | Literal ( ' * ' ) | Literal ( '\ '' ) | except Exception : # Matches only program errors ( see flake8 rule E722 ) res_list [ 1 ] [ : :-1 ] pg_host : str , from shutil import get_terminal_size psql = PsqlWrapper ( sys.argv [ 1 ] .encode ( `` utf-8 '' ) , assert psql._intercept ( b'\x1b [ ? 2004htest_db= # ' ) == \ # magic strings related seemingly solely to ctrl-R use are # input does not trigger parsing ( Return is always at least 2 length ) # ORDER BY in subquery version_info = \ # and resulting message is saved until when new prompt comes in # * FROM orders WHERE order_total_eur = 100 ; psql.ofilter ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 10\x1b [ 27m0 ; \x08\x08\x08\x08\x08\x08 '' ) # prompt1 per bin/psql/prompt.c : SubquerySelectChecker ( sanitized_sql , sql_parser ) .check ( ) self.tok_pre_host + self.tok_host psql.ofilter ( b '' '\r ( reverse-i-search ) ` ' : `` ) def main ( ) - > None : if output [ 0:2 ] == b'\r\n ' : psql_rev = psql [ : :-1 ] # slicing is fastest operation for reversing Literal ( `` > = '' ) | Literal ( `` # = '' ) # * FROM orders WHERE order_total_eur = 100 ; '' self.analyze : Callable [ [ str ] , str ] = hook_f self.match_rev_magical_returns.parse_string ( psql_rev ) return analysis_result match_rev_prompt_and_then_rest : ParserElement = \ Word , psql._intercept ( b '' \x08\x08\x08= ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m=\x1b [ 27m 100 ; \x08\x08\x08\x08\x08\x08 '' ) res_list [ 0 ] [ : :-1 ] import sys dimensions= ( self.rows , self.cols ) ParseResults , after most recent query . print ( `` Fatal error : psql connection info could not be parsed\n '' psql._intercept ( b'\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) from typing import Optional psql.ofilter ( b'\r\n ' ) '\n'.join ( line.rstrip ( ) for line in self.pyte_screen.display ) : returns : if output is a fresh prompt . # ^either stops after dbname or includes \x1b [ ? 2004l ... `` -- version '' ) analysis_result = SubqueryOrderByChecker ( reduce ( 5-tuple or None . lambda x , y : x + y [ : :-1 ] , results , `` '' # ORDER BY in subquery psql._intercept ( b'\r\n\r\r\n ' ) `` psql `` + bytes.decode ( self.psql_args ) , `` `` '' # and save resulting message # % / = current database if self.parser.output_has_magical_return ( results = prompt_res.as_list ( ) assert p.parse_last_stmt ( case_trivial ) == \ ( Literal ( '= ' ) | Literal ( '^ ' ) ) `` password= '' + self.pg_pass ) as conn : # reverse string for parsing efficiency `` `` '' def start ( self ) - > None : # multiple elements into one . These are often combined to build functions .replace ( db_name + `` - > '' , `` '' ) \ psql._intercept ( b ' ; ' ) f = open ( `` psqlparser.log '' , `` a '' ) to 2 cells . match_rev_prompt_and_then_rest : ParserElement = ( # ParserElement for these would look this : bytes.decode ( prompt , `` utf-8 '' ) ) return ( `` `` '' Forward output to ` _check_and_act_on_repl_output ` and feed \ # Combine ( debug : bool = False psql._intercept ( b'\r\n\x1b [ ? 2004l\r ' ) # SUM/AVG ( DISTINCT ) `` Pg4n has only been tested on psql versions `` : param psql : screen-scraped psql output . PsqlParser ( ) ) prompt_res = match_rev_prompt_and_then_rest.parse_string ( psql_rev ) child process , initializing semantic analysis and wrapper modules , \ : param hook_syntax_f : is a callback to which scraped syntax error \ elif len ( res_list ) == 4 : # results include \x1b [ ? 2004h .. self.pg_user , psql_args : bytes , `` - ? # '' , `` * ? # '' , `` \ ' ? # '' , `` \ '' ? # '' , `` $ ? # '' , `` ( ? # '' , def run_analysis ( line and then the prompt , to allow easy message injection . # should parse as \n - > `` `` to avoid `` SELECT * FROM .. '' . ZeroOrMore ( Char ( `` \n '' ) | Char ( `` \r '' ) | White ( ) ) + \ else : # ( Literal ( ' # ' ) | Literal ( ' > ' ) ) ) sem_router.run_analysis , from .semanticrouter import SemanticRouter `` `` '' Start psql process and feed hook functions with \ def __init__ ( self , psql.ofilter ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C1 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 1\x1b [ 27m00 ; \x08\x08\x08\x08\x08\x08 '' ) InconsistentExpressionChecker ( sanitized_sql , qep_analysis ) .check ( ) assert psql._intercept ( b'\x1b [ ? 2004l\r order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004htest_db= # ' ) == \ Literal ( `` \r\n\x1b [ ? 2004l\r '' [ : :-1 ] ) \ tok_stmt_end ) self.pg_host , # Comparing different domains Literal ( `` psql ( PostgreSQL ) `` ) `` `` '' Start psql process and then start feeding hook function with \ Literal ( `` ? [ \x1b '' ) # in this case control code parameter : returns : an empty string if current version has been tested , \ analysis_result = ImpliedExpressionChecker ( received in return . ZeroOrMore ( White ( ) ) return lambda syntax_error_analysis : `` '' , against versions pg4n is tested with . psql.ofilter ( b'\x1b [ ? 2004l\r\x1b [ ? 2004htest_db- # ' ) def test_intercept ( ) - > None : | Literal ( `` \x08\r\n '' [ : :-1 ] ) # tok , or token , is parsing element with only single element output , match_rev_magical_returns : ParserElement = ( psql.ofilter ( b '' \x1b [ A\rtest_db= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; \x1b [ K\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\r\n\r '' ) # see how the screen would look like , but still allow injecting assert p.parse_new_prompt ( case_mixed_results ) == \ self.tok_rev_prompt_end + \ # SQL parser , QEP parser , or an analysis module exploded : Control is only returned after psql process exits . ParserElement.setDefaultWhitespaceChars ( `` '' ) tok_rev_prompt_end : ParserElement = \ new_output : bytes = self.check_and_act_on_repl_output ( output ) `` dbname= '' + self.pg_name return unreversed_flattened_res psql.start ( ) prompt = db_name + multiline_prompt_end # for optimization reasons , check output only if len ( ) > 1 , so most intercepted output . '' '' '' # breaks , because both of these work right in straight psql . See : from .psqlparser import PsqlParser psql._intercept ( b '' '\r ( reverse-i-search ) ` ' : `` ) with . results = [ res_list [ 3 ] [ : :-1 ] , # possibly provide a message to be included in next new prompt . psql.ofilter ( b'\x1b [ ? 2004htest_db- # ' ) demultilined_res = no_newlines_res\ return has_new_prompt def get ( self ) - > ( str , str , str , str , str ) : return bytes ( print ( e.explain ( ) ) : param input : user input characters . assert p.parse_last_found_stmt ( case_multiple_queries_and_whitespaces ) == \ : param psql_args : are the command-line arguments pg4n has been called \ assert p.parse_last_found_stmt ( case_multiline_query ) == \ psql.ofilter ( b ' * ' ) # SUM/AVG ( DISTINCT ) assert psql.ofilter ( case_query_2_prompt ) == \ from copy import deepcopy","['src/pg4n/main.py', 'src/pg4n/psqlconninfo.py', 'src/pg4n/psqlparser.py', 'src/pg4n/psqlwrapper.py', 'src/pg4n/semanticrouter.py', 'src/pg4n/test/test_psqlparser.py', 'src/pg4n/test/test_psqlwrapper.py']",2022-11-19 17:10:41+00:00,2022-12-12 12:47:05+00:00,2022-12-12 14:47:03+02:00
87,535fdf800713ce7b74f1e330e9c02af0bb981db2,1.0320036381017417e-05,1,,Handle psqlconninfo etc . errors gracefully with e.g sole `` -- help '' argument,Merge pull request # 95 from Project-C-SQL/feat/error-handling-and-syntax-error-detection,"stmt_chars : str = printable.translate ( str.maketrans ( `` '' , `` '' , stmt_end ) ) # for optimization reasons , check output only if len ( ) > 1 , so keyboard encoding= '' utf-8 '' , if prompt_res : : returns : if user has indeed hit return . print_msg + `` \r\n\r\n '' `` `` '' Initiate session by getting psql connection parameters via psql \ self.pg_pass , : param psql : screenscraped psql string with only whitespace \ Literal , analysis_result : Optional [ str ] = None control codes . \n is newline ( carriage return \r will be added by \ match_version_stmt : ParserElement = ( def _check_psql_version ( self ) - > str : self.pg4n_message = `` '' assert psql.ofilter ( b'\x1b [ ? 2004htest_db= # ' ) == \ latest_output : bytes hook_syntax_f : Callable [ [ str ] , str ] , `` - * # '' , `` * * # '' , `` \ ' * # '' , `` \ '' * # '' , `` $ * # '' , `` ( * # '' , EqWildcardChecker ( sanitized_sql , qep_analysis ) .check ( ) # This will match against `` % R % x % # `` , e.g `` - > `` . from functools import reduce ) # ( Return is always at least 2 length ) output : bytes # Implied expression Stream ( potential_future_screen ) prompt_res : ParseResults = None `` `` '' Parse for weird Return presses . if magical_return_res : psql.ofilter ( b'\x08\x08 ' ) `` SELECT * FROM orders WHERE order_total_eur = 100 ; '' psql.ofilter ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 100\x1b [ 27m ; \x08\x08\x08\x08\x08\x08 '' ) from .psqlwrapper import PsqlWrapper # TODO/BUG : removing \n 's is a tough problem , see : from typing import Optional , Tuple : param prompt : is output where message is injected to . A fresh prompt \ self.pg4n_message = `` '' self stmt_res : Optional [ ParseResults ] = None tok_rev_prompt_end : ParserElement = Combine ( # Strange HAVING clause without GROUP BY output to pyte screen for future screen-scraping . White , from .psqlwrapper import PsqlWrapper # % R = - , * , ' , `` ; also $ , ( # cheaper and easier to reverse & start from the end from pyparsing import \ def check_and_act_on_repl_output ( self , latest_output : bytes ) - > bytes : qep_analysis : QEPAnalysis = QEPParser ( conn=conn ) .parse ( sql_query ) ... # as interesting things usually are at end of a long string . # Based on exploratory testing , self.pg_tuple = ( ) - > Optional [ Tuple [ str , str , str , str , str ] ] : results = [ to pick up relevant SQL statements for the hook function . self.tok_pre_database + self.tok_database + \ to pick up relevant SQL statements and syntax errors for hook functions . '' '' '' ZeroOrMore ( White ( ) ) + tok_stmt_end + ... + \ pg_port : str , identbodychars , results = [ stmt_res_list [ 3 ] , main.py [ psql arguments ] < database name > '' ) parsed_sql_query : str = \ control codes and newlines ( without carriage returns ) . conn ) .check ( ) ZeroOrMore , `` `` '' Parse for an empty prompt , to detect when a query \ identbodychars , nums if split_prompt == [ ] : new_output : bytes = self._check_and_act_on_repl_output ( output ) ( StringEnd ( ) # output may stop at end of db name , list , facilitating easy message injection . demultilined_res : str = no_newlines_res tok_stmt_end : ParserElement = Char ( ' ; ' ) sanitized_sql : exp.Expression = sql_parser.parse_one ( sql_query ) # Literal ( '\ '' ' ) | Literal ( ' $ ' ) | Literal ( ' ( ' ) ) Literal , Word , \ e.explain ( ) ) results : list [ str ] = [ ] screen : str = \ tok_rev_error : ParserElement = Literal ( `` : RORRE '' ) ) - > None : self.tok_pre_port + self.tok_port if version == `` '' : stmt_res_list [ length - 3 ] , # and resulting message is saved here until when new prompt comes in sql_query , `` port= '' + self.pg_port `` - ? > '' , `` * ? > '' , `` \ ' ? > '' , `` \ '' ? > '' , `` $ ? > '' , `` ( ? > '' ] line.rstrip ( ) for line in self.pyte_screen.display ) # If we have a semantic error message waiting # If there is a fresh prompt : assert psql._intercept ( fresh_prompt_1 ) == \ ] analysis_result = StrangeHavingChecker ( psql._intercept ( b'SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; ' ) sem_router = SemanticRouter ( * conn_info ) psql.ofilter ( b '' \x08\x08\x08= ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m=\x1b [ 27m 100 ; \x08\x08\x08\x08\x08\x08 '' ) def ifilter ( self , input : bytes ) - > bytes : def run_analysis ( self , sql_query : str ) - > str : # for matching . psql.ofilter ( b'\x08\x08\x08\x08 ' ) ) `` `` '' Parse for an empty prompt and everything preceding it \ psql._intercept ( b'\r\x1b [ K\x1b > \x1b [ r\x1b [ ? 1049l ' ) debug : bool = False psql._intercept ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C1 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 1\x1b [ 27m00 ; \x08\x08\x08\x08\x08\x08 '' ) sanitized_sql , results : List [ str ] = [ ] `` - ! > '' , `` * ! > '' , `` \ ' ! > '' , `` \ '' ! > '' , `` $ ! > '' , `` ( ! > '' , `` `` '' Check for weird Return presses . sql_query : str # Since latest_output contains error details , we will have to pg_user : str , def test_parse_new_prompt ( ) - > None : return `` '' : returns : a two-part list with everything before the prompt \ # magic strings ( related at least to ctrl-R use ) are psql._intercept ( b'\r\n ' ) lambda x , y : x + y , sys.argv [ 1 : ] , `` '' `` `` '' Handle semantic analysis modules . '' '' '' StrangeHavingChecker ( sanitized_sql , qep_analysis ) .check ( ) return `` '' # No semantic errors found print ( `` pg4n [ psql arguments ] < database name > '' ) analysis_result = SubquerySelectChecker ( self.parser.parse_new_prompt_and_rest ( psql.start ( ) stmt_res_list [ length - 4 ] psql.ofilter ( b'SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; ' ) # tok_multiline_prompt_end : ParserElement = \ # line and then the prompt , to allow easy message injection . if analysis_result is not None : version_msg = self.check_psql_version ( ) if self.parser.output_has_new_prompt ( `` `` '' User input filter function for pexpect.interact : not used . self.pg_port , psql._intercept ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 10\x1b [ 27m0 ; \x08\x08\x08\x08\x08\x08 '' ) ... + StringEnd ( ) ) ) c = pexpect.spawn ( `` psql `` + bytes.decode ( self.psql_args ) , return self.pg_tuple # SELECT in subquery # just match against a list of all possible combinations # `` pgdb= > SELECT `` psql `` psql.ofilter ( b'\x08order_total_eur = 0 AND order_total_eur = 10\x1b [ C\x1b [ 1P ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) match_rev_prompt_end : ParserElement = \ # `` \r\n\x1b [ ? 2004l\r '' , `` \r\n\r\r\n '' and `` \x08\r\n '' . from functools import reduce self.parser.parse_syntax_error ( potential_future_contents ) from .psqlconninfo import PsqlConnInfo List is empty if no fresh prompt was found . # Reversing happens for performance reasons , : returns : an empty list if no prompt found . Otherwise has [ ' > = ' ] or \ bytes.decode ( latest_output ) stmt_res_list [ length - 4 ] ] SubqueryOrderByChecker ( sanitized_sql , qep_analysis ) .check ( ) # debug creates pyte.screen ( current screenscraping context ) and `` `` '' Parse for syntax error output . `` `` '' Forward output to ` check_and_act_on_repl_output ( ) ` and feed \ ) .check ( ) def output_has_new_prompt ( self , psql : str ) - > bool : pg_name : str sys.argv [ 1 ] .encode ( `` utf-8 '' ) , sql_parser : SqlParser = SqlParser ( conn ) # no syntax error analysis : `` host= '' + self.pg_host def parse_syntax_error ( self , psql : str ) - > str : line.rstrip ( ) for line in self.pyte_screen.display ) ) # 'rev ' in variable names is shorthand for reversed . # asterisk unpacks the 5-tuple magical_return_res : Optional [ ParseResults ] = None split_prompt : List [ str ] = self.parser.parse_new_prompt_and_rest ( assert p.parse_last_stmt ( case_multiline_query ) == \ if analysis_result is not None : return has_magical_return hook_semantic_f : Callable [ [ str ] , str ] , ) - > bytes : psql._intercept ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 100\x1b [ 27m ; \x08\x08\x08\x08\x08\x08 '' ) : returns : a two-part list with everything before the prompt \ results = [ `` , match_rev_prompt_end : ParserElement = self.tok_rev_prompt_end : returns : a prompt with injected message . # Turn on verbose output to psqlparser.log file in working directory `` user= '' + self.pg_user `` `` '' Detect when psql query evaluation has ended by parsing for a new prompt . def test_ofilter ( ) - > None : analysis_result : Optional [ str ] = None magical_return_res = \ import os stmt_chars : str = \ line.rstrip ( ) for line in potential_future_screen.display analysis_result = \ # Literal ( `` ERROR : '' ) def test_output_has_new_prompt ( ) - > None : assert p.parse_last_stmt ( case_select_then_select ) == \ : returns : unchanged input . psql._intercept ( return_press_1 ) assert p.parse_last_found_stmt ( case_empirical_1 ) == \ ' . ' match_rev_any_sql_stmt .replace ( db_name + `` - # '' , `` '' ) except ParseException : self.parser.parse_last_found_stmt ( screen ) str ( self.supported_psql_versions ) + `` . '' `` `` '' wrapper ) . def main ( ) - > None : [ `` - # '' , `` * # '' , `` \ ' # '' , `` \ '' # '' , `` $ # '' , `` ( # '' , evaluation has ended . qep_analysis print ( f '' { os.path.basename ( sys.executable ) } \ if magical_return_res : def test_parse_magical_return ( ) - > None : # Licensed under MIT . are received . assert p.output_has_new_prompt ( case_mixed_results ) assert p.parse_last_found_stmt ( case_select_then_insert ) == \ has_magical_return = True psql.ofilter ( b '' \r\n\x1b [ ? 2004l\r '' ) CaselessLiteral ( `` SELECT '' ) match_error_statement : ParserElement = ( # If we have a semantic error message waiting and there is a fresh return ( self.pg_host , '' , # save a potential warning to be included in before next fresh prompt . split_prompt [ 1 ] , # % R = = , ^ # % / % R % x % # per postgres bin/psql/settings.h sem_router = SemanticRouter ( * conn_info ) # asterisk unpacks the 5-tuple lambda x : `` '' , self.pg4n_message = self.analyze ( parsed_sql_query ) : returns : if output has a weird Return press . StringEnd ( ) psql._intercept ( b'\x08\x08\x08\x08 ' ) def __init__ ( self , psql_args : str ) : # Parsing functions common to more than 1 parsing functions are listed here reversed_flattened_res : str = \ psql_rev : str = psql [ : :-1 ] # psqlwrapper.log ( capturing terminal stream ) in working directory match_rev_any_sql_stmt : ParserElement = \ : param hook_semantic_f : is a callback to which scraped SQL queries are\ ParserElement , | Literal ( `` \r\n\r\r\n '' [ : :-1 ] ) \ no_newlines_res = reversed_flattened_res.replace ( '\n ' , ' ' ) # superusers have = # prompt ( StringEnd ( ) | ( Literal ( `` ? [ \x1b '' ) # semantic analysis : self.tok_pre_host + self.tok_host + \ if self.parser.parse_magical_return ( psql.ofilter ( b'\x08\x08\x08\x08\x08\x08 ' ) `` SELECT * FROM orders WHERE order_total_eur = 100 ; '' for multiline_prompt_end in self.multiline_prompt_ends : def _check_and_act_on_repl_output ( has_new_prompt : bool = False return bytes ( split_prompt [ 0 ] + `` \r\n '' # Implied expression # should convert \n - > `` `` to avoid `` SELECT * FROM .. '' . psql.ofilter ( case_query_1 ) # Opt ( Literal ( ' * ' ) | Literal ( ' ! ' ) | Literal ( ' ? ' ) , `` '' ) psql.ofilter ( b'\r\x1b [ C ' ) # feed query to semantic analysis hook function [ ' # = ' ] . if prompt_res : self.pg_pass , psql_output = pexpect.spawn ( from shutil import get_terminal_size prompt_res = match_rev_prompt_and_then_rest.parse_string ( psql_rev ) self , # keyboard input does not trigger parsing Combine , dimensions= ( self.rows , self.cols ) ) ParseResults , ParserElement , StringEnd , White , Word , ZeroOrMore , \ stmt_res_list [ 2 ] , : param hook_f : is a callback to which scraped SQL queries are passed \ assert p.parse_last_found_stmt ( case_select_then_select ) == \ psql._intercept ( case_psql_start ) Literal ( `` psql ( PostgreSQL ) `` ) + Combine ( Word ( nums ) + ' . ' + Word ( nums ) ) prompt_res = match_rev_prompt_end.parse_string ( psql_rev ) elif len ( res_list ) == 2 : # parsing stops right after database name ] respectively . bytes.decode ( latest_output ) ) ! = [ ] : # there is new prompt analysis_result = CmpDomainChecker ( sanitized_sql , columns ) .check ( ) has_magical_return : bool = False `` utf-8 '' ) assert p.parse_last_found_stmt ( case_query_with_newline ) == \ columns `` utf-8 '' tok_rev_error `` - > '' , `` * > '' , `` \ ' > '' , `` \ '' > '' , `` $ > '' , `` ( > '' , from pyparsing import ( # get terminal screen contents # % # = # , > res_list [ 2 ] [ : :-1 ] tok_rev_prompt_end self.tok_pre_port + self.tok_port + \ ZeroOrMore ( White ( ) ) + CaselessLiteral ( `` SELECT '' ) psql._intercept ( b'\x08order_total_eur = 0 AND order_total_eur = 10\x1b [ C\x1b [ 1P ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) c.interact ( input_filter=lambda x : x , output_filter=self._intercept ) pg_user : str , def test_parse_last_found_stmt ( ) - > None : self.semantic_analyze : Callable [ [ str ] , str ] = hook_semantic_f psql._intercept ( b'\r\x1b [ C ' ) print ( e.explain ( ) ) self.tok_rev_prompt_end psql_args : str # `` = > SELECT * FROM orders WHERE order_tot PsqlParser ( ) assert p.parse_last_found_stmt ( case_trivial ) == \ tok_marker_caret # feed query to hook function and save resulting message `` `` '' Check PostgreSQL version via psql child process and match \ assert p.parse_last_stmt ( case_select_then_insert ) == \ self.syntax_analyze : Callable [ [ str ] , str ] = hook_syntax_f pexpect.spawn ( `` psql `` + bytes.decode ( self.psql_args ) with psycopg.connect ( # Comparing different domains psql._intercept ( case_query_1 ) self.pg_name ) # `` \r\n\x1b [ ? 2004l\r '' , `` \r\n\r\r\n '' and `` \x08\r\n '' . psql.ofilter ( b'SELECT ' ) self.pg_port , def output_has_magical_return ( self , psql : str ) - > bool : psql._intercept ( b'FROM ' ) c.interact ( input_filter=self.ifilter , version_msg = self._check_psql_version ( ) def parse_magical_return ( self , psql : str ) - > List [ str ] : ) as conn : self.tok_pre_user + self.tok_user stmt_res_list [ 1 ] ] version_info = pexpect.spawn ( res_list [ 1 ] [ : :-1 ] + res_list [ 0 ] [ : :-1 ] stmt_res : ParseResults = None self.tok_rev_prompt_end self.pg_user , return prompt # prompt is malformed and is returned as-is . : param db_name_parameter : is name of database we are connecting to . match_rev_last_stmt : ParserElement = \ match_rev_any_sql_stmt : ParserElement = ( no_newlines_res = unreversed_flattened_res.replace ( '\n ' , ' ' ) match_version_stmt : ParserElement = \ analysis_result = EqWildcardChecker ( psql._intercept ( b'\x08order_total_eur = 0 AND order_total_eur = 1\x1b [ 1P00 ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) import sys ZeroOrMore ( Char ( `` \n '' ) | Char ( `` \r '' ) | White ( ) ) return new_output res_list [ 2 ] [ : :-1 ] + res_list [ 1 ] [ : :-1 ] + res_list [ 0 ] [ : :-1 ] c = pexpect.spawn ( return input | ( # or continue \x1b [ ? .. ParserElement.setDefaultWhitespaceChars ( `` ) psql.ofilter ( b'orders ' ) # rev means reversed , these are for performance reasons . ParseException , ParserElement , \ from functools import reduce ( Literal ( ' # ' ) | Literal ( ' > ' ) ) # optimization : do not spend time parsing if there is no message : psql.ofilter ( b ' ; ' ) if output [ 0:2 ] == b '' \r\n '' : def ofilter ( self , output : bytes ) - > bytes : psql._intercept ( b'\x1b [ ? 2004l\r\x1b [ ? 1049h\x1b=\r order_id | order_total_eur | customer_id \x1b [ m\r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\x1b [ m\r\n 1 | 535.36 | 111\x1b [ m\r\n 2 | 409.80 | 217\x1b [ m\r\n 3 | 189.43 | 19\x1b [ m\r\n 4 | 144.14 | 157\x1b [ m\r\n 5 | 582.52 | 172\x1b [ m\r\n 6 | 132.85 | 206\x1b [ m\r\n 7 | 183.92 | 236\x1b [ m\r\n 8 | 424.80 | 244\x1b [ m\r\n 9 | 519.43 | 175\x1b [ m\r\n 10 | 414.55 | 234\x1b [ m\r\n 11 | 88.19 | 50\x1b [ m\r\n 12 | 591.72 | 143\x1b [ m\r\n 13 | 503.52 | 216\x1b [ m\r\n 14 | 586.06 | 181\x1b [ m\r\n 15 | 47.79 | 248\x1b [ m\r\n 16 | 330.92 | 130\x1b [ m\r\n 17 | 302.31 | 225\x1b [ m\r\n 18 | 438.38 | 26\x1b [ m\r\n 19 | 107.53 | 94\x1b [ m\r\n 20 | ' results = [ stmt_res_list [ length - 3 ] , if stmt_res : psql._intercept ( b'\x08\x08\x08\x08\x08\x08 ' ) # `` pgdb= > SELECT * FROM orders WHERE order_tot match_rev_magical_returns.parse_string ( psql_rev ) Opt ( White ( ) ) match_rev_last_stmt : ParserElement = ( split_prompt : List [ str ] = \ : param prompt : is where the message is injected . A fresh prompt is \ match_psql_conninfo : ParserElement = ( if len ( res_list ) == 2 : # parsing stops right after database name # TODO ( ? ) : We may have to match for errors : returns : syntax error message from 'ERROR : ' to last '^ ' . parser : PsqlParser name . potential_future_screen = \ return `` Pg4n has only been tested on psql versions `` + \ psql._intercept ( b '' \r\n\x1b [ ? 2004l\r '' ) `` `` '' Parse for a fresh prompt and everything preceding it into 2-length \ `` port= '' + self.pg_port : returns : if user has hit return . # Replacing \n 's has some edge cases where wrapper transparency assert p.parse_last_stmt ( case_empirical_1 ) == \ if self.pg4n_message ! = `` '' : `` user= '' + self.pg_user ) : ) - > str : # replacing \n 's with `` '' maybe has less edge cases . Or actually more . [ `` > = '' ] def test_output_has_magical_return ( ) - > None : [ `` \rl4002 ? [ \x1b\n\r '' ] res_list [ 3 ] [ : :-1 ] , def get ( intercepted queries and syntax errors . # command-line arguments prevent interactive sessions ( e.g pg4n -- help ) `` psql `` + bytes.decode ( self.psql_args ) + `` -- version '' Word ( self.prompt_chars ) otherwise a warning message . bytes.decode ( output , `` utf-8 '' ) ) ! = [ ] : sql_parser : SqlParser = SqlParser ( conn ) return results StringEnd , assert p.output_has_magical_return ( case_long_return ) self.tok_pre_user + self.tok_user + \ assert p.parse_magical_return ( case_long_return ) == \ reduce ( lambda x , y : x + y [ : :-1 ] , results , `` '' ) expected . if syntax_error ! = `` '' : : returns : ( hostname , port , user , password , database name ) \ return `` '' # No semantic errors found from .semanticrouter import SemanticRouter [ `` # = '' ] Otherwise has newline text . Word ( nums ) psql.ofilter ( b'\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) # This will match against `` % R % x % # `` , e.g `` = > `` . `` - ! # '' , `` * ! # '' , `` \ ' ! # '' , `` \ '' ! # '' , `` $ ! # '' , `` ( ! # '' , CaselessLiteral , # Wildcards without LIKE ) # e.g . `` pg4n -- help '' is being run . assert psql.ofilter ( fresh_prompt_1 ) == \ # Inconsistent expression pg_port : str , def check_psql_version ( self ) - > str : try : match_select_stmt : ParserElement = ( reduce ( lambda x , y : x + y [ : :-1 ] , results , `` '' ) sanitized_sql : exp.Expression = sql_parser.parse_one ( sql_query ) # should parse as \n - > `` '' split_prompt [ 1 ] , new_output : bytes = self._replace_prompt ( latest_output ) return new_output : returns : a prompt with injected message , or unchanged if \ # Inconsistent expression deepcopy ( self.pyte_screen ) name . '' '' '' Char , return analysis_result Literal ( `` \r\n\x1b [ ? 2004l\r '' [ : :-1 ] ) self.pg_name assert p.output_has_new_prompt ( case_trivial ) tok_marker_caret : ParserElement = Literal ( `` ^ '' ) psql.ofilter ( b'\r\x1b [ K\x1b > \x1b [ r\x1b [ ? 1049l ' ) potential_future_screen_output_sink.feed ( from .psqlconninfo import PsqlConnInfo prompt_res = match_rev_prompt_end.parse_string ( psql_rev ) output to pyte screen for screenscraping . psql.ofilter ( b'\x1b [ ? 2004l\r\x1b [ ? 1049h\x1b=\r order_id | order_total_eur | customer_id \x1b [ m\r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\x1b [ m\r\n 1 | 535.36 | 111\x1b [ m\r\n 2 | 409.80 | 217\x1b [ m\r\n 3 | 189.43 | 19\x1b [ m\r\n 4 | 144.14 | 157\x1b [ m\r\n 5 | 582.52 | 172\x1b [ m\r\n 6 | 132.85 | 206\x1b [ m\r\n 7 | 183.92 | 236\x1b [ m\r\n 8 | 424.80 | 244\x1b [ m\r\n 9 | 519.43 | 175\x1b [ m\r\n 10 | 414.55 | 234\x1b [ m\r\n 11 | 88.19 | 50\x1b [ m\r\n 12 | 591.72 | 143\x1b [ m\r\n 13 | 503.52 | 216\x1b [ m\r\n 14 | 586.06 | 181\x1b [ m\r\n 15 | 47.79 | 248\x1b [ m\r\n 16 | 330.92 | 130\x1b [ m\r\n 17 | 302.31 | 225\x1b [ m\r\n 18 | 438.38 | 26\x1b [ m\r\n 19 | 107.53 | 94\x1b [ m\r\n 20 | ' ) except ParseException as e : passed to , and from which corresponding semantic warning messages are \ prompt_res : Optional [ ParseResults ] = None ImpliedExpressionChecker ( sanitized_sql , sql_query , f.write ( psql._intercept ( b'\x1b [ ? 2004l\r\x1b [ ? 2004htest_db- # ' ) # an insightful syntax error message from the syntax analysis . # SELECT in subquery self.pg_tuple : Optional [ Tuple [ str , str , str , str , str ] ] = None def parse_new_prompt_and_rest ( self , psql : str ) - > List [ str ] : self.tok_pre_database + self.tok_database psql._intercept ( b'orders ' ) if self.debug : pg_host : str , psql_rev = psql [ : :-1 ] analysis_result = InconsistentExpressionChecker ( unreversed_flattened_res : str = reduce ( parsed_sql_query : str = self.parser.parse_last_stmt ( screen ) Combine ( pg_name : str stmt_res = match_error_statement.parse_string ( psql_rev ) # prompt2 per bin/psql/prompt.c : # for simplicity , just use pexpect here bytes.decode ( prompt , `` utf-8 '' ) CaselessLiteral , Char , Combine , Literal , ParseException , \ ... # has already been parsed as prompt_chars # match_error : ParserElement = \ screen : str = '\n'.join ( # prompt : # from .inconsistent_expression_checker import InconsistentExpressionChecker print_msg + `` \r\n\r\n '' psql.ofilter ( return_press_1 ) encoding= '' utf-8 '' , unreversed_flattened_res : str = \ def __init__ ( self , psql_args : bytes , stmt_res_list = stmt_res.as_list ( ) Char ( ' ; ' ) def parse_last_stmt ( self , psql : str ) - > str : f.close ( ) import pexpect # should convert \n - > `` '' to avoid `` order_tot al_eur '' `` dbname= '' + self.pg_name magical_return_res = \ detecting new prompt fails . str ( self.supported_psql_versions ) from pyparsing import Literal , Word , ParseException , ParserElement , \ new_output : bytes = `` '' # Strange HAVING clause without GROUP BY res_list = prompt_res.as_list ( ) `` - * > '' , `` * * > '' , `` \ ' * > '' , `` \ '' * > '' , `` $ * > '' , `` ( * > '' , self.tok_rev_prompt_end # Semantic analysis is always done when user presses Return psql = PsqlWrapper ( psql.ofilter ( b'\x08order_total_eur = 0 AND order_total_eur = 1\x1b [ 1P00 ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) res_list = prompt_res.as_list ( ) psql._intercept ( b '' \x1b [ A\rtest_db= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; \x1b [ K\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\r\n\r '' ) sem_router.run_analysis , assert psql.ofilter ( b'\x1b [ ? 2004l\r order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004htest_db= # ' ) == \ assert p.parse_new_prompt ( case_trivial ) == \ self.pg4n_message = self.semantic_analyze ( parsed_sql_query ) `` . '' # To save time , since linebreak prompts are only removed , # Replacing \n 's with `` `` seems to have less edge cases . ParseException , # AND-clause will stop executing after first False . Word ( nums ) new_output = self._replace_prompt ( latest_output ) # Wildcards without LIKE Only one ( static ) class instance is intended for use in program . print ( bytes.decode ( psql_output.before ) ) pg_pass : str , # % x = nothing , * , ! , ? from typing import Optional bytes.decode ( output , `` utf-8 '' ) has_new_prompt = True ) : ... self | Literal ( `` \x08\r\n '' [ : :-1 ] ) and then starting the session . '' '' '' analysis_result = SumDistinctChecker ( except ParseException as e : from .psqlparser import PsqlParser assert p.parse_last_stmt ( case_query_with_newline ) == \ magical_return_res : ParseResults = None psql._intercept ( b'\x1b [ ? 2004htest_db- # ' ) is expected , or otherwise no injection is made . ] SumDistinctChecker ( sanitized_sql , qep_analysis ) .check ( ) with psycopg.connect ( `` host= '' + self.pg_host columns : list [ Column ] = sql_parser.get_query_columns ( sanitized_sql ) potential_future_contents : str = '\n'.join ( if self.pg4n_message ! = `` '' \ if stmt_res is not None : def __init__ ( `` password= '' + self.pg_pass | Literal ( `` \r\n\r\r\n '' [ : :-1 ] ) if len ( res_list ) == 4 : # results include \x1b [ ? 2004l syntax_error = \ ) : multiline_prompt_ends : list [ str ] = \ # either by only having single element , or using Combine to squash sql_parser hook_f : Callable [ [ str ] , str ] , parser : PsqlParser ) : output_filter=self.ofilter ) demultilined_res = demultilined_res.replace ( prompt , `` '' ) match_select_stmt : ParserElement = \ match_psql_conninfo : ParserElement = \ assert p.parse_last_stmt ( case_multiple_queries_and_whitespaces ) == \ Word ( self.prompt_chars ) + \ potential_future_screen_output_sink = \ Opt ( Literal ( ' * ' ) | Literal ( ' ! ' ) | Literal ( ' ? ' ) , `` '' ) def parse_last_found_stmt ( self , psql : str ) - > str : psql.ofilter ( b'FROM ' ) printable.translate ( str.maketrans ( `` '' , `` '' , stmt_end ) ) psql.ofilter ( b'\r\n\x1b [ ? 2004l\r ' ) qep_analysis : QEPAnalysis = QEPParser ( conn=conn ) .parse ( sql_query ) columns : list [ Column ] = sql_parser.get_query_columns ( sanitized_sql ) : returns : an empty list if no presses are found . \ match_rev_magical_returns : ParserElement = \ tok_stmt_end : ParserElement = \ results = magical_return_res.as_list ( ) psql._intercept ( b ' * ' ) assert psql._intercept ( case_query_2_prompt ) == \ conn if conn_info is not None : def parse_new_prompt ( self , psql : str ) - > List [ str ] : def test_parse_last_stmt ( ) - > None : self.match_rev_any_sql_stmt + Word ( self.prompt_chars ) psql._intercept ( b'\x08\x08 ' ) f.write ( '\n'.join ( psql_rev : str = psql [ : :-1 ] # slicing is fastest operation for reverse and self.parser.parse_new_prompt ( psql_output.expect ( pexpect.EOF ) # Psql is not connecting to any database , Opt , # Analysis is always done when user presses Return def parse_new_prompt_and_rest ( self , psql : str ) - > list [ str ] : messages are passed to , and from which corresponding warning messages \ pg_pass : str , self.pg4n_message = self.syntax_analyze ( syntax_error ) psql.ofilter ( case_psql_start ) ) psql.ofilter ( b'\r\n\r\r\n ' ) # `` = > SELECT psql._intercept ( b'SELECT ' ) f.write ( str ( e.explain ( ) ) + `` \n '' ) split_prompt [ 0 ] + `` \r\n '' from typing import List to and from which semantic error messages are received in return . def start ( def _intercept ( results = [ nums : param psql : screenscraped psql string analysis_result = CmpDomainChecker ( # ( Literal ( '- ' ) | Literal ( ' * ' ) | Literal ( '\ '' ) | except Exception : # Matches only program errors ( see flake8 rule E722 ) res_list [ 1 ] [ : :-1 ] pg_host : str , from shutil import get_terminal_size psql = PsqlWrapper ( sys.argv [ 1 ] .encode ( `` utf-8 '' ) , assert psql._intercept ( b'\x1b [ ? 2004htest_db= # ' ) == \ # magic strings related seemingly solely to ctrl-R use are # input does not trigger parsing ( Return is always at least 2 length ) # ORDER BY in subquery version_info = \ # and resulting message is saved until when new prompt comes in # * FROM orders WHERE order_total_eur = 100 ; psql.ofilter ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 10\x1b [ 27m0 ; \x08\x08\x08\x08\x08\x08 '' ) # prompt1 per bin/psql/prompt.c : SubquerySelectChecker ( sanitized_sql , sql_parser ) .check ( ) self.tok_pre_host + self.tok_host psql.ofilter ( b '' '\r ( reverse-i-search ) ` ' : `` ) def main ( ) - > None : if output [ 0:2 ] == b'\r\n ' : psql_rev = psql [ : :-1 ] # slicing is fastest operation for reversing Literal ( `` > = '' ) | Literal ( `` # = '' ) # * FROM orders WHERE order_total_eur = 100 ; '' self.analyze : Callable [ [ str ] , str ] = hook_f self.match_rev_magical_returns.parse_string ( psql_rev ) return analysis_result match_rev_prompt_and_then_rest : ParserElement = \ Word , psql._intercept ( b '' \x08\x08\x08= ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m=\x1b [ 27m 100 ; \x08\x08\x08\x08\x08\x08 '' ) res_list [ 0 ] [ : :-1 ] import sys dimensions= ( self.rows , self.cols ) ParseResults , after most recent query . print ( `` Fatal error : psql connection info could not be parsed\n '' psql._intercept ( b'\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) from typing import Optional psql.ofilter ( b'\r\n ' ) '\n'.join ( line.rstrip ( ) for line in self.pyte_screen.display ) : returns : if output is a fresh prompt . # ^either stops after dbname or includes \x1b [ ? 2004l ... `` -- version '' ) analysis_result = SubqueryOrderByChecker ( reduce ( 5-tuple or None . lambda x , y : x + y [ : :-1 ] , results , `` '' # ORDER BY in subquery psql._intercept ( b'\r\n\r\r\n ' ) `` psql `` + bytes.decode ( self.psql_args ) , `` `` '' # and save resulting message # % / = current database if self.parser.output_has_magical_return ( results = prompt_res.as_list ( ) assert p.parse_last_stmt ( case_trivial ) == \ ( Literal ( '= ' ) | Literal ( '^ ' ) ) `` password= '' + self.pg_pass ) as conn : # reverse string for parsing efficiency `` `` '' def start ( self ) - > None : # multiple elements into one . These are often combined to build functions .replace ( db_name + `` - > '' , `` '' ) \ psql._intercept ( b ' ; ' ) f = open ( `` psqlparser.log '' , `` a '' ) to 2 cells . match_rev_prompt_and_then_rest : ParserElement = ( # ParserElement for these would look this : bytes.decode ( prompt , `` utf-8 '' ) ) return ( `` `` '' Forward output to ` _check_and_act_on_repl_output ` and feed \ # Combine ( debug : bool = False psql._intercept ( b'\r\n\x1b [ ? 2004l\r ' ) # SUM/AVG ( DISTINCT ) `` Pg4n has only been tested on psql versions `` : param psql : screen-scraped psql output . PsqlParser ( ) ) prompt_res = match_rev_prompt_and_then_rest.parse_string ( psql_rev ) child process , initializing semantic analysis and wrapper modules , \ : param hook_syntax_f : is a callback to which scraped syntax error \ elif len ( res_list ) == 4 : # results include \x1b [ ? 2004h .. self.pg_user , psql_args : bytes , `` - ? # '' , `` * ? # '' , `` \ ' ? # '' , `` \ '' ? # '' , `` $ ? # '' , `` ( ? # '' , def run_analysis ( line and then the prompt , to allow easy message injection . # should parse as \n - > `` `` to avoid `` SELECT * FROM .. '' . ZeroOrMore ( Char ( `` \n '' ) | Char ( `` \r '' ) | White ( ) ) + \ else : # ( Literal ( ' # ' ) | Literal ( ' > ' ) ) ) sem_router.run_analysis , from .semanticrouter import SemanticRouter `` `` '' Start psql process and feed hook functions with \ def __init__ ( self , psql.ofilter ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C1 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 1\x1b [ 27m00 ; \x08\x08\x08\x08\x08\x08 '' ) InconsistentExpressionChecker ( sanitized_sql , qep_analysis ) .check ( ) assert psql._intercept ( b'\x1b [ ? 2004l\r order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004htest_db= # ' ) == \ Literal ( `` \r\n\x1b [ ? 2004l\r '' [ : :-1 ] ) \ tok_stmt_end ) self.pg_host , # Comparing different domains Literal ( `` psql ( PostgreSQL ) `` ) `` `` '' Start psql process and then start feeding hook function with \ Literal ( `` ? [ \x1b '' ) # in this case control code parameter : returns : an empty string if current version has been tested , \ analysis_result = ImpliedExpressionChecker ( received in return . ZeroOrMore ( White ( ) ) return lambda syntax_error_analysis : `` '' , against versions pg4n is tested with . psql.ofilter ( b'\x1b [ ? 2004l\r\x1b [ ? 2004htest_db- # ' ) def test_intercept ( ) - > None : | Literal ( `` \x08\r\n '' [ : :-1 ] ) # tok , or token , is parsing element with only single element output , match_rev_magical_returns : ParserElement = ( psql.ofilter ( b '' \x1b [ A\rtest_db= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; \x1b [ K\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\r\n\r '' ) # see how the screen would look like , but still allow injecting assert p.parse_new_prompt ( case_mixed_results ) == \ self.tok_rev_prompt_end + \ # SQL parser , QEP parser , or an analysis module exploded : Control is only returned after psql process exits . ParserElement.setDefaultWhitespaceChars ( `` '' ) tok_rev_prompt_end : ParserElement = \ new_output : bytes = self.check_and_act_on_repl_output ( output ) `` dbname= '' + self.pg_name return unreversed_flattened_res psql.start ( ) prompt = db_name + multiline_prompt_end # for optimization reasons , check output only if len ( ) > 1 , so most intercepted output . '' '' '' # breaks , because both of these work right in straight psql . See : from .psqlparser import PsqlParser psql._intercept ( b '' '\r ( reverse-i-search ) ` ' : `` ) with . results = [ res_list [ 3 ] [ : :-1 ] , # possibly provide a message to be included in next new prompt . psql.ofilter ( b'\x1b [ ? 2004htest_db- # ' ) demultilined_res = no_newlines_res\ return has_new_prompt def get ( self ) - > ( str , str , str , str , str ) : return bytes ( print ( e.explain ( ) ) : param input : user input characters . assert p.parse_last_found_stmt ( case_multiple_queries_and_whitespaces ) == \ : param psql_args : are the command-line arguments pg4n has been called \ assert p.parse_last_found_stmt ( case_multiline_query ) == \ psql.ofilter ( b ' * ' ) # SUM/AVG ( DISTINCT ) assert psql.ofilter ( case_query_2_prompt ) == \ from copy import deepcopy","['src/pg4n/main.py', 'src/pg4n/psqlconninfo.py', 'src/pg4n/psqlparser.py', 'src/pg4n/psqlwrapper.py', 'src/pg4n/semanticrouter.py', 'src/pg4n/test/test_psqlparser.py', 'src/pg4n/test/test_psqlwrapper.py']",2022-11-22 11:13:31+00:00,2022-12-12 12:47:04+00:00,2022-12-12 14:47:03+02:00
92,ff25e18f8bfefbf98a4f27a1eccaf633c8313844,1.043188058247324e-05,1,"Run ` SELECT * FROM albums ; ` or ` SELECT * FROM orders ; ` on customer-provided test database . Does n't crash without QEP parser , or without semantic router loaded , so seems like SQL parser is at fault . ` = # SELECT * FROM albums ; unable to convert from internal type 'boolean ' to declared type `",SQL parser crashes when querying database_generate.sql,Merge pull request # 93 from Project-C-SQL/fix/sqlparser-typeconv,"cur.execute ( self , match : re.Match , type_name_prefix : str ) - > PostgreSQLDataType : f '' unrecognized number ' { num_groups } ' of arguments for numeric ( ) column type '' , def _eval_opt_precission_field_match ( converted_types.append ( PostgreSQLDataType ( `` MACADDR '' , None , None ) ) type_int8 , type_numeric83 NUMERIC ( 8,3 ) , type_bit20 BIT ( 20 ) , elif match.group ( 1 ) is not None and match.group ( 2 ) is not None : NESTED_WHERE = \ type_box , elif match : = real_matcher.match ( type_name ) : import re 'character20 ' , type_char , type_char CHAR , column_expression ) type_timestamp_with_time_zone , type_numeric , type_serial2 SERIAL2 , ' ( ( -1 , -1 ) , ( 1 , 1 ) ) ' : :lseg , type_float8 FLOAT8 , path_matcher = re.compile ( r '' ^ ( ? : path ) $ '' ) def test_datatypes ( sql_parser_datatypedb : sqlparser.SqlParser ) : '08:05:06.789+02 ' , type_timestamp_without_time_zone , tsquery_matcher = re.compile ( r '' ^ ( ? : tsquery ) $ '' ) type_text , ) smallint_matcher = re.compile ( r '' ^ ( ? : smallint|int2 ) $ '' , re.IGNORECASE ) elif match : = timestamptz_matcher.match ( type_name ) : type_double_precision DOUBLE PRECISION , type_bool , bool_matcher = re.compile ( r '' ^ ( ? : boolean|bool ) $ '' ) type_timestamp4_with_time_zone , self._eval_opt_precission_field_match ( match , `` BIT '' ) type_bytea BYTEA , type_bigserial BIGSERIAL , type_time4_without_time_zone TIME ( 4 ) WITHOUT TIME ZONE , BORING_STATEMENT = \ r '' ^ ( ? : numeric|decimal ) \s * \ ( \s * ( \d+ ) ( ? : \s * , \s * ( \d+ ) ) ? \s * \ ) $ '' # type_date , type_circle , json_matcher = re.compile ( r '' ^ ( ? : json ) $ '' ) f '' '' '' # print ( f '' type_names : { type_names } '' ) elif match : = inet_matcher.match ( type_name ) : type_time_with_time_zone TIME WITH TIME ZONE , type_timetz TIMETZ , converted_types.append ( PostgreSQLDataType ( `` INTERVAL '' , None , None ) ) converted_types.append ( PostgreSQLDataType ( `` POINT '' , None , None ) ) type_bit20 , type_varchar VARCHAR , import sqlglot.expressions as exp ) type_timestamptz , type_tsvector TSVECTOR , except Exception as e : type_character20 CHARACTER ( 20 ) , type_bitvarying BIT VARYING , xml_matcher = re.compile ( r '' ^ ( ? : xml ) $ '' ) '10.1.2.3/32 ' , ' ( ( -1 , -1 ) , ( -1 , 1 ) , ( 0 , 1 ) ) ' : :path , type_polygon , macaddr8_matcher = re.compile ( r '' ^ ( ? : macaddr8 ) $ '' ) f '' DECIMAL ( { match.group ( 1 ) } ) '' , int ( match.group ( 1 ) ) , None type_date DATE , r '' ^timestamp ( ? : \ ( \s * ( \d+ ) \s * \ ) ) ? ( ? : without time zone ) ? $ '' from psycopg import Connection type_varchar20 VARCHAR ( 20 ) , type_bitvarying20 BIT VARYING ( 20 ) , '1999-01-08 ' , ) # | OPT_PRECISSION_MATCHERS | type_time4 TIME ( 4 ) , parser = sql_parser_datatypedb self._eval_opt_precission_field_match ( match , `` VARBIT '' ) type_point , 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11 ' : :uuid , f '' CHAR ( { match.group ( 1 ) } ) '' , int ( match.group ( 1 ) ) , None CHECK_CONSTRAINT = `` '' '' converted_types.append ( PostgreSQLDataType ( `` MACADDR8 '' , None , None ) ) type_int8 INT8 , assert False , f '' exception : { e } '' timestamp_matcher = re.compile ( type_varchar20 , SINGLE_TABLE_STATEMENT = f '' '' '' import psycopg type_varbit VARBIT , type_int , type_money MONEY , elif match : = timetz_matcher.match ( type_name ) : bit_matcher = re.compile ( r '' ^ ( ? : bit ) ( ? : \ ( \s * ( \d+ ) \s * \ ) ) ? $ '' ) test_type_id INT , type_smallint , time_matcher = re.compile ( r '' ^time ( ? : \ ( \s * ( \d+ ) \s * \ ) ) ? ( ? : without time zone ) ? $ '' ) elif type_name == `` char '' : '08-00-2b-01-02-03 ' , where p is optional precission field and returns a converted type used CHECK_CONSTRAINT = \ type_charactervarying20 , FALSE , converted_types.append ( PostgreSQLDataType ( `` UUID '' , None , None ) ) type_float8 , type_interval INTERVAL , load= [ load_datatypedb ] , '0101 ' , type_cidr , type_time , converted_types.append ( PostgreSQLDataType ( `` LSEG '' , None , None ) ) assert type ( parser.get_root_node ( self._eval_opt_precission_field_match ( match , `` CHAR '' ) varbit_matcher = re.compile ( r '' ^ ( ? : ( ? : bit varying ) |varbit ) ( ? : \ ( \s * ( \d+ ) \s * \ ) ) ? $ '' ) type_integer INTEGER , def sql_parser_datatypedb ( datatypedb : Connection ) : elif match : = bytea_matcher.match ( type_name ) : Evaluates a internal type of the form : ' < typename > [ ( p ) ] ' converted_types.append ( PostgreSQLDataType ( `` TSQUERY '' , None , None ) ) type_bitvarying , converted_types.append ( PostgreSQLDataType ( `` INET '' , None , None ) ) type_json JSON , conn.commit ( ) 'varchar20 ' , converted_types.append ( PostgreSQLDataType ( `` PATH '' , None , None ) ) elif match : = json_matcher.match ( type_name ) : type_timestamp , type_bool BOOL , int_matcher = re.compile ( r '' ^ ( ? : int|integer|int4 ) $ '' , re.IGNORECASE ) elif match : = lseg_matcher.match ( type_name ) : self._eval_opt_precission_field_match ( match , `` VARCHAR '' ) elif match : = varbit_matcher.match ( type_name ) : type_int4 INT4 , if match.group ( 1 ) is None : type_timetz4 TIMETZ ( 4 ) , parsed_sql = parser.parse_one ( SELECT_STATEMENT ) 'text ' , type_timestamp4_with_time_zone TIMESTAMP ( 4 ) WITH TIME ZONE , money_matcher = re.compile ( r '' ^ ( ? : money ) $ '' ) elif match : = point_matcher.match ( type_name ) : elif match : = path_matcher.match ( type_name ) : type_lseg LSEG , type_boolean , name = f '' NUMERIC ( { match.group ( 1 ) } , { match.group ( 2 ) } ) '' columns = parser.get_query_columns ( parsed_sql ) type_character CHARACTER , IMPOSSIBLE_STATEMENT = `` '' '' elif match : = text_matcher.match ( type_name ) : text_matcher = re.compile ( r '' ^ ( ? : text ) $ '' ) import psycopg ) ; '' '' '' type_charactervarying CHARACTER VARYING , parsed_sql.find ( exp.Identifier ) ) ) == exp.Select if num_groups == 1 : type_macaddr , if type_name == `` integer '' : 'character varying20 ' , type_macaddr8 , type_time TIME , type_xml ) elif match : = box_matcher.match ( type_name ) : type_cidr CIDR , type_decimal83 DECIMAL ( 8,3 ) , converted_types.append ( PostgreSQLDataType ( `` SMALLINT '' , None , None ) ) # pylint : disable=line-too-long type_jsonb JSONB , type_timestamp4_without_time_zone TIMESTAMP ( 4 ) WITHOUT TIME ZONE , box_matcher = re.compile ( r '' ^ ( ? : box ) $ '' ) type_bit BIT , circle_matcher = re.compile ( r '' ^ ( ? : circle ) $ '' ) converted_types.append ( PostgreSQLDataType ( `` DATE '' , None , None ) ) converted_types.append ( PostgreSQLDataType ( `` CHAR '' , None , None ) ) elif match : = timestamp_matcher.match ( type_name ) : type_timestamp4 TIMESTAMP ( 4 ) , insert into e31_test_table_orders ( order_id , order_total_eur , customer_id ) values ( 250 , 367.56 , 214 ) ; '' '' '' ) bigint_matcher = re.compile ( r '' ^ ( ? : bigint|int8 ) $ '' , re.IGNORECASE ) # | TRIVIAL_MATCHERS | '08:05:06.789 ' , current_timestamp , test_type_id , @ pytest.fixture SELECT * '11:05:06.7891+02 ' , datatypedb = factories.postgresql ( `` datatypedb_factory '' ) converted_types.append ( PostgreSQLDataType ( `` POLYGON '' , None , None ) ) type_boolean BOOLEAN , converted_types.append ( PostgreSQLDataType ( `` MONEY '' , None , None ) ) type_timetz4 , type_macaddr MACADDR , 'varchar ' , '04:05:06.7891 ' , type_varbit20 , ' a fat cat sat on a mat and ate a fat rat ' : :tsvector , INSERT INTO { TYPE_TEST_TABLE_NAME } ( FROM { TYPE_TEST_TABLE_NAME } ; '' '' '' type_bytea , lseg_matcher = re.compile ( r '' ^ ( ? : lseg ) $ '' ) interval_matcher = re.compile ( r '' ^ ( ? : interval ) $ '' ) f '' { type_name_prefix } ( { match.group ( 1 ) } ) '' , int ( match.group ( 1 ) ) , None THREE_TABLE_STATEMENT = f '' '' '' type_time4_with_time_zone , type_smallserial SMALLSERIAL , elif match : = date_matcher.match ( type_name ) : 18 , `` `` '' COMPLEX_COLUMNS_QUERY = \ type_smallint SMALLINT , ' ( ( 0 , 0 ) , ( 1 , 1 ) ) ' : :box , r '' ^ ( ? : ( ? : character varying ) |varchar ) ( ? : \ ( \s * ( \d+ ) \s * \ ) ) ? $ '' try : ' < foo > bar < /foo > ' : :xml elif match : = bit_matcher.match ( type_name ) : r '' ^ ( ? : time|timetz ) ( ? : \ ( \s * ( \d+ ) \s * \ ) ) ? ( ? : with time zone ) ? $ '' converted_types.append ( PostgreSQLDataType ( `` JSONB '' , None , None ) ) bytea_matcher = re.compile ( r '' ^ ( ? : bytea ) $ '' ) '12.8 ' : :money , # inet_matcher = re.compile ( r '' ^ ( ? : inet ) $ '' ) 200.54321 , tsvector_matcher = re.compile ( r '' ^ ( ? : tsvector ) $ '' ) converted_types.append ( conv_type ) type_timestamp4_without_time_zone , timestamptz_matcher = re.compile ( type_charactervarying , parsed_sql = parser.parse_one ( SIMPLE_STATEMENT ) character_matcher = re.compile ( r '' ^ ( ? : character|char ) \ ( \s * ( \d+ ) \s * \ ) $ '' ) 100.12345 , type_uuid UUID , elif match : = tsquery_matcher.match ( type_name ) : # scope= '' function '' weakens pytest magic PostgreSQLDataType ( `` DOUBLE_PRECISSION '' , None , None ) '127.0.0.1 ' , type_timestamp_with_time_zone TIMESTAMP WITH TIME ZONE , from os import getenv type_inet , type_time_without_time_zone TIME WITHOUT TIME ZONE , type_inet INET , '01010101010101010101 ' , 12 , type_bitvarying20 , import sqlglot.expressions as exp type_real , '08002b:0102030405 ' , elif match.group ( 1 ) is not None and match.group ( 2 ) is None : SELECT ( 1,2,3 ) ; '' '' '' COMPLEX_COLUMNS_QUERY = f '' '' '' VALUES ( DROP TABLE IF EXISTS { TYPE_TEST_TABLE_NAME } ; elif match : = circle_matcher.match ( type_name ) : elif type_name == `` character '' : type_box BOX , macaddr_matcher = re.compile ( r '' ^ ( ? : macaddr ) $ '' ) converted_types.append ( PostgreSQLDataType ( `` CIDR '' , None , None ) ) type_line LINE , import sqlglot elif match : = bigint_matcher.match ( type_name ) : '08:05:06.7891 ' , ' c ' , self._eval_opt_precission_field_match ( match , `` TIMETZ '' ) elif num_groups == 2 : polygon_matcher = re.compile ( r '' ^ ( ? : polygon ) $ '' ) converted_types.append ( PostgreSQLDataType ( `` TEXT '' , None , None ) ) ' ( ( 0 , 1 ) , ( -1 , -1 ) , ( -1 , 1 ) ) ' : :polygon , 'fat & rat ' : :tsquery , type_decimal , ZERO_TABLE_STATEMENT = `` '' '' return sqlparser.SqlParser ( db_connection=datatypedb ) 10 , return PostgreSQLDataType ( elif match : = bool_matcher.match ( type_name ) : type_circle CIRCLE , # | TRIVIAL_CASES | elif match : = tsvector_matcher.match ( type_name ) : SELECT_STATEMENT = f '' '' '' num_groups = len ( match.groups ( ) ) assert type ( parser.get_root_node ( parsed_sql.find ( exp.Identifier ) ) ) == exp.Select elif match : = jsonb_matcher.match ( type_name ) : CREATE TABLE { TYPE_TEST_TABLE_NAME } ( double_precission_matcher = re.compile ( r '' ^ ( ? : ( ? : double precision ) |float8 ) $ '' ) BORING_STATEMENT = `` '' '' type_time4_with_time_zone TIME ( 4 ) WITH TIME ZONE , type_timestamp_without_time_zone TIMESTAMP WITHOUT TIME ZONE , type_macaddr8 MACADDR8 , 2.2 , r '' ^ ( ? : timestamp|timestamptz ) ( ? : \ ( \s * ( \d+ ) \s * \ ) ) ? ( ? : with time zone ) ? $ '' SIMPLE_STATEMENT = f '' '' '' type_character , timetz_matcher = re.compile ( type_time4_without_time_zone , type_char20 CHAR ( 20 ) , type_timestamp4 , datatypedb_factory = factories.postgresql_proc ( type_bigint BIGINT , '\\000 ' : :bytea , elif match : = uuid_matcher.match ( type_name ) : type_charactervarying20 CHARACTER VARYING ( 20 ) , ' C ' , ' 1 year 2 months 3 days 4 hours 5 minutes 6 seconds ' , 38.001 , converted_types.append ( PostgreSQLDataType ( `` BYTEA '' , None , None ) ) `` `` '' type_decimal DECIMAL , type_real REAL , # | COMPLEX_MATCHERS | type_serial8 SERIAL8 , converted_types.append ( PostgreSQLDataType ( `` CIRCLE '' , None , None ) ) name = f '' DECIMAL ( { match.group ( 1 ) } , { match.group ( 2 ) } ) '' type_time4 , insert into e31_test_table_orders ( order_id , order_total_eur , customer_id ) values ( 250 , 367.56 , 214 ) ; '' '' '' 1000000000000 , type_time_without_time_zone , converted_types.append ( PostgreSQLDataType ( `` BIGINT '' , None , None ) ) def load_datatypedb ( * * kwargs ) : ' { { \ '' foo\ '' : [ \ '' bar\ '' , \ '' baz\ '' , false , 0.0 ] } } ' , type_float4 , `` `` '' type_int INT , f '' unrecognized number type format ' { type_name } ' for numeric ( ) column type '' , type_serial SERIAL , ) ; ' 1 ' , 12.1 , conn : Connection = psycopg.connect ( * * kwargs ) column_name = parser.get_column_name_from_column_expression ( column_expression ) converted_types.append ( elif match : = xml_matcher.match ( type_name ) : jsonb_matcher = re.compile ( r '' ^ ( ? : jsonb ) $ '' ) converted_types.append ( PostgreSQLDataType ( `` BOX '' , None , None ) ) '11:05:06.789+02 ' , elif match : = macaddr8_matcher.match ( type_name ) : uuid_matcher = re.compile ( r '' ^ ( ? : uuid ) $ '' ) type_uuid , 2 , type_numeric83 , type_polygon POLYGON , converted_types.append ( PostgreSQLDataType ( `` TSVECTOR '' , None , None ) ) type_int4 , type_xml XML , TYPE_TEST_TABLE_NAME = `` sqlparser_datatype_test_table '' type_tsquery TSQUERY , type_tsvector , type_path , type_timestamptz4 , type_double_precision , converted_types.append ( PostgreSQLDataType ( `` BOOL '' , None , None ) ) type_timetz , TRUE , elif match : = macaddr_matcher.match ( type_name ) : type_lseg , IMPOSSIBLE_STATEMENT = \ f '' NUMERIC ( { match.group ( 1 ) } ) '' , int ( match.group ( 1 ) ) , None converted_types.append ( PostgreSQLDataType ( `` XML '' , None , None ) ) type_timestamptz4 TIMESTAMPTZ ( 4 ) , type_time_with_time_zone , type_json , converted_types.append ( conv_type ) 0.01 , type_numeric NUMERIC , type_decimal83 , elif match : = polygon_matcher.match ( type_name ) : type_bit , r '' ^ ( ? : numeric|decimal ) ( ? : \ ( \s * ( \d+ ) ( ? : \s * , \s * ( \d+ ) ) ? \s * \ ) ) ? $ '' '1010 ' , import re # | COMPLEX_CASES | converted_types.append ( PostgreSQLDataType ( `` REAL '' , None , None ) ) assert type ( parser.get_root_node ( parsed_sql.find ( exp.Select ) ) ) == exp.Select elif match : = time_matcher.match ( type_name ) : type_tsquery , parsed_sql.find ( exp.Select ) ) ) == exp.Select '00000000111000000000 ' , elif match : = interval_matcher.match ( type_name ) : conv_type = PostgreSQLDataType ( `` DECIMAL '' , None , None ) ' ( ( 0 , 0 ) , 1 ) ' : :circle , f '' VARCHAR ( { match.group ( 1 ) } ) '' , int ( match.group ( 1 ) ) , None converted_types.append ( PostgreSQLDataType ( `` JSON '' , None , None ) ) real_matcher = re.compile ( r '' ^ ( ? : real|float4 ) $ '' ) # print ( f '' column_names : { column_names } '' ) elif match : = money_matcher.match ( type_name ) : r '' ^ ( ? : ( ? : character varying ) |varchar ) \ ( \s * ( \d+ ) \s * \ ) $ '' self._eval_opt_precission_field_match ( match , `` TIMESTAMP '' ) type_character20 , '08:05:06.7891+02 ' , # | OPT_PRECISSION_CASES | from psycopg import Connection type_int2 , converted_types.append ( PostgreSQLDataType ( `` LINE '' , None , None ) ) 0.04 , f '' '' '' PRIMARY KEY ( test_type_id ) type_timestamptz TIMESTAMPTZ , cidr_matcher = re.compile ( r '' ^ ( ? : cidr ) $ '' ) with conn.cursor ( ) as cur : '10101010101010101010 ' , elif match : = double_precission_matcher.match ( type_name ) : type_point POINT , self._eval_opt_precission_field_match ( match , `` TIMESTAMPTZ '' ) 12.4 , type_path PATH , ' { { 1 , 1 , 2 } } ' : :line , ' [ 1 , 2 , 3 ] ' : :jsonb , SINGLE_TABLE_STATEMENT = \ ' ( 0 , 0 ) ' : :point , type_integer , type_timestamp TIMESTAMP , point_matcher = re.compile ( r '' ^ ( ? : point ) $ '' ) column_name = parser.get_column_name_from_column_expression ( 'char20 ' , self._eval_opt_precission_field_match ( match , `` TIME '' ) if match : = int_matcher.match ( type_name ) : type_varbit , type_serial4 SERIAL4 , character_matcher = re.compile ( r '' ^ ( ? : character|char ) ( ? : \ ( \s * ( \d+ ) \s * \ ) ) ? $ '' ) type_varchar , type_char20 , '04:05:06.789 ' , type_text TEXT , type_varbit20 VARBIT ( 20 ) , elif match : = line_matcher.match ( type_name ) : type_bigint , date_matcher = re.compile ( r '' ^ ( ? : date ) $ '' ) ZERO_TABLE_STATEMENT = \ `` normalized '' in the context of this program 's conventions . 'character varying ' , THREE_TABLE_STATEMENT = \ type_money , elif match : = smallint_matcher.match ( type_name ) : conv_type = PostgreSQLDataType ( type_interval , return PostgreSQLDataType ( `` TIMESTAMPTZ '' , None , None ) type_line , 14 , elif match : = cidr_matcher.match ( type_name ) : line_matcher = re.compile ( r '' ^ ( ? : line ) $ '' ) converted_types.append ( conv_type ) type_jsonb , type_float4 FLOAT4 , type_int2 INT2 , NESTED_WHERE = `` '' '' if match.group ( 1 ) is None and match.group ( 2 ) is None :","['src/pg4n/sqlparser.py', 'src/pg4n/test/test_sqlparser.py']",2022-11-30 12:25:04+00:00,2022-12-02 17:51:34+00:00,2022-12-02 19:51:33+02:00
