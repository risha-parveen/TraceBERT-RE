issue_id,commit_id,p_x,l_x,issue_desc,issue_comments,summary,diff,files,created_at,closed_at,commit_time
10,672575a8e3f414ce9ffa1f47b1e18b13d13fb9eb,0.0012883744202554,0,"See # 22 . Given SQL statement by the wrapper , produce a QEP wrapped in a data format ( classically a tree graph , but simpler format like list probably works here too ) that can be efficiently examined in semantic analysis . QEPs can be fetched in roughly following way :",Basic QEP parser module,Merge pull request # 44 from Project-C-SQL/feat/improve-qeps,"`` `` '' Finds nodes matching the predicate , recursively . stmt = f '' explain ( format json , analyze , verbose ) { stmt.strip ( ) .rstrip ( ' ; ' ) } ; '' stmt.strip ( ) .rstrip ( ' ; ' ) + `` ; '' assert len ( qep.root.rfindval ( `` Node Type '' , `` Bitmap Index Scan '' ) ) == 4 : param node_ : the node to wrap '' '' '' return map ( QEPNode , self._node.get ( `` Plans '' , [ ] ) ) To install all dependencies and the application , type ` poetry install ` . After installation , if the Python scripts folder is in your PATH , you should be able to invoke ` main.main ( ) ` with ` pg4n ` . assert qep.root.findval ( `` Relation Name '' , `` comments '' ) == [ qep.plan ] assert qep.root.findval ( `` Relation Name '' , `` users '' ) == [ qep.plan ] password=getenv ( `` PGPASSWORD '' , `` postgres '' ) ) cur.execute ( `` set constraint_exclusion = on ; '' ) qep = parser ( `` select * from stories '' ) `` `` '' Test that the QEP rfind ( recursive find ) method works as expected . '' '' '' assert qep.root.findval ( `` Actual Rows '' , 1 ) == [ qep.plan ] assert qep.root.findval ( `` Node Type '' , `` Seq Scan '' ) == [ qep.plan ] qep = parser ( `` select * from users where id = 1 '' ) return list ( filter ( pred , self._node [ `` Plans '' ] ) ) | ` PGDBNAME ` | ` test_database ` | Database name . | : param recursive : if True , search recursively , otherwise only search password=getenv ( `` PGPASSWORD '' ) , `` `` '' Finds nodes with the given key and value , recursively . self._ref = not not conn `` `` '' Finds nodes matching the predicate . qep = parser ( `` select * from users '' ) Having PostgreSQL running on port 5432 , do ` poetry run pytest ` . qep = parser ( `` select * from stories where id = 1 '' ) self._ref = bool ( conn ) assert qep.root.findval ( `` Alias '' , `` users '' ) == [ qep.plan ] | ` PGUSER ` | ` postgres ` | The user that will be used to manage the test database . | assert qep.root.findval ( `` Actual Rows '' , 4 ) == [ qep.plan ] from itertools import chain def find ( self , pred : Callable [ [ node ] , bool ] ) - > list [ node ] : qep = parser ( `` select * from comments '' ) To get a similar PostgreSQL instance as with GitHub Actions workflow : < br > | -- -- -- -- -- -- | -- -- -- -- -- -- -- - | -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - | : param pred : a function that takes a node and returns True if it matches list ( chain.from_iterable ( x.find ( pr , True ) for x in iter ( self ) ) ) return self._node.get ( `` Plans '' , [ ] ) `` `` '' Get the child node at the given index . : param pr : a function that takes a node and returns True if it matches | ` PGPORT ` | ` 5432 ` | Port to an active PostgreSQL instance . | return self.find ( lambda x : x.get ( key ) == val , recursive ) def test_qep_find ( parser : qepparser.QEPParser ) : assert qep.root.findval ( `` Relation Name '' , `` stories '' ) == [ qep.plan ] | ` PGHOST ` | ` 127.0.0.1 ` | Hostname of the PostgreSQL server . | def findval ( self , key : str , val : object , recursive=False ) - > list [ node ] : | ` PGPASSWORD ` | | Password , in case password authentication is used . | : param key : the key to search for def rfind ( self , pred : Callable [ [ node ] , bool ] ) - > list [ node ] : To install all dependencies and the application , type ` poetry install ` . After installation , if the Python scripts folder is in your PATH , you should be able to invoke ` main.main ( ) ` with ` pg4n ` . `` `` '' Test that the QEP find method works as expected . '' '' '' this+children `` `` '' Finds nodes with the given key and value . assert qep.root.findval ( `` Actual Rows '' , 2 ) == [ qep.plan ] qep = parser ( `` select * from users where id = 1 or id = 2 '' ) assert qep.root.findval ( `` Node Type '' , `` Index Scan '' ) == [ qep.plan ] | Variable | Default value | Description | `` `` '' Get the child node at the given index . '' '' '' with self._conn.cursor ( ) as cur : assert qep.root.findval ( `` Alias '' , `` stories '' ) == [ qep.plan ] return self.find ( pr ) + \ For example , if PostgreSQL is on port 5433 , just do ` PGPORT=5433 poetry run pytest ` ( Bash syntax ) . Having PostgreSQL running on port 5432 , do ` poetry run pytest ` ( or , if on port x , just do ` PGPORT=x poetry run pytest ` ) . qep = parser ( `` select * from comments where id = 1 or id = 2 '' ) return self.findval ( key , val , recursive=True ) stmt = `` explain ( format json , analyze , verbose ) '' + \ return list ( filter ( pr , chain ( ( self._node , ) , self.plans ) ) ) return self._node [ `` Plans '' ] assert len ( qep.root.rfindval ( `` Node Type '' , `` Bitmap Heap Scan '' ) ) == 1 qep = parser ( `` select * from stories where id = 1 or id = 2 '' ) self._conn.commit ( ) def test_gep_rfind ( parser : qepparser.QEPParser ) : You may need to provide environment variables that match your config : `` `` '' Find nodes matching the predicate . '' '' '' `` `` '' Create a new QEPNode . return map ( QEPNode , self._node [ `` Plans '' ] ) To get a similar instance as with GitHub Actions workflow : < br > return self.find ( pred , recursive=True ) : returns : the child node at the given index assert qep.root.findval ( `` Alias '' , `` comments '' ) == [ qep.plan ] if recursive : : returns : a list of matching nodes assert len ( qep.root.rfindval ( `` Node Type '' , `` BitmapOr '' ) ) == 2 dbname=getenv ( `` PGDBNAME '' , `` test_database '' ) ) qep = parser ( `` select * from comments where id = 1 '' ) recursive=False ) - > list [ node ] : def rfindval ( self , key : str , val : object ) - > list [ node ] : `` `` '' : param val : the value to search for : param key : the index of the child node to get # use constraint_exclusion to avoid unnecessary index scans def find ( self , pr : Callable [ [ node ] , bool ] ,","['README.md', 'src/pg4n/qepparser.py', 'src/pg4n/test/test_qepparser.py']",2022-09-23 11:52:46+00:00,2022-10-11 14:32:31+00:00,2022-11-05 13:28:47+02:00
11,aebf426ab3350d922e78442db19398914f4610aa,6.921126623637974e-05,0,Integrate python-sqlparse for turning the SQL statement string into a data structure for efficient semantic analysis .,Basic SQL parser,Merge pull request # 53 from Project-C-SQL/feat/semantic-router,"PsqlParser ( ) ) identbodychars , nums def new_psqlwrapper ( ) : pexpect_conninfo.expect ( pexpect.EOF ) running all the modules on all queries . For now , it is dumb brute return `` '' # No semantic errors found Literal ( `` \ '' . '' ) self.tok_pre_host + self.tok_host + \ def test_ofilter ( ) - > None : tok_user : ParserElement = \ self.tok_pre_database + self.tok_database + \ `` port= '' + self.pg_port def _replace_prompt ( self , prompt : bytes ) : to initialize connection info . '' '' '' lambda x : `` Helpful message '' , print ( e.explain ( ) ) sem_router = SemanticRouter ( * conn_info ) # asterisk unpacks the 5-tuple print_msg = self.pg4n_message.replace ( `` \n '' , `` \r\n '' ) `` `` '' Run analysis modules on SQL query string and get an insightful \ ParseException , ParserElement , \ conninfo_res = \ results = [ res_list [ 3 ] [ : :-1 ] , ( StringEnd ( ) | ( Literal ( `` ? [ \x1b '' ) + \ self.pg_name ) tok_end : ParserElement = \ tok_pre_port : ParserElement = \ pexpect_conninfo = pexpect.spawn ( `` psql -c \ '' \\conninfo\ '' `` + psql_args ) self.tok_end self.pg_user , Literal , Word , \ res_list [ 0 ] [ : :-1 ] psql : psqlwrapper.PsqlWrapper = new_psqlwrapper ( ) print ( `` Fatal error : psql connection info could not be parsed\n '' name . '' '' '' `` dbname= '' + self.pg_name Semantic router ( some day ) implements basic heuristics to avoid def test_ofilter ( ) : self.pg_name = conninfo_res [ 1 ] tok_pre_host : ParserElement = \ def start ( self ) - > None : self.pg_host = conninfo_res [ 5 ] res_list [ 2 ] [ : :-1 ] psql by supplying same arguments as the original psql process . This \ p = PsqlParser ( ) ] pg_port : str , tok_pre_database : ParserElement = \ `` `` '' Initialize Postgres connection with given paramaters . '' '' '' from sqlglot import exp def __init__ ( self , print ( f '' { os.path.basename ( sys.executable ) } main.py < database name > '' ) force router . self.pg_pass : str = pg_pass `` `` '' Get 5-tuple that has the PostgreSQL host , port , user , pass , and db \ `` `` '' Use psql child process with exact same command-line arguments \ sanitized_sql : exp.Expression = sql_parser.parse_one ( sql_query ) Literal ( `` \ '' at port \ '' '' ) match_psql_conninfo : ParserElement = \ lambda x : `` Test '' , self.pg_port = conninfo_res [ 7 ] psql = psqlwrapper.PsqlWrapper ( `` '' , tok_database : ParserElement = \ results = [ res_list [ 3 ] [ : :-1 ] , from .semanticrouter import SemanticRouter ) .get ( ) message in return . def __init__ ( self , psql_args : str ) : ... + StringEnd ( ) ) ) Literal ( `` You are connected to database \ '' '' ) self.pg_user = conninfo_res [ 3 ] p = psqlparser.PsqlParser ( ) ] `` password= '' + self.pg_pass ) as conn : pg_name : str # Comparing different domains sem_router.run_analysis , return ( self.pg_host , elif len ( res_list ) == 2 : # stops right after database name self.pg_host : str = pg_host : returns : an insightful message that might include vt100-compatible \ import psycopg class PsqlConnInfo : match_psql_conninfo.parse_string ( conninfo_str ) .as_list ( ) from functools import reduce psql : PsqlWrapper = new_psqlwrapper ( ) pass from .. psqlwrapper import PsqlWrapper from .. import psqlparser def test_parse_last_found_stmt ( ) : psql = psqlwrapper.PsqlWrapper ( sys.argv [ 1 ] .encode ( `` utf-8 '' ) , def test_parse_new_prompt ( ) - > None : def test_parse_magical_return ( ) - > None : res_list [ 1 ] [ : :-1 ] Literal ( `` \ '' as user \ '' '' ) if analysis_result is not None : res_list [ 0 ] [ : :-1 ] def test_parse_new_prompt ( ) : conn_info = PsqlConnInfo ( def test_parse_magical_return ( ) : try : `` `` '' Get PostgreSQL server address , port , database name , and user via \ from .. import psqlwrapper main.py [ psql arguments ] < database name > '' ) from .. psqlparser import PsqlParser self.pg_name : str = pg_name from .psqlparser import PsqlParser Word ( self.prompt_chars ) + Literal ( `` ? [ \x1b '' ) + \ : param sql_query : is a single well-formed query to run analytics on . Word ( self.prompt_chars ) + \ conninfo_str = bytes.decode ( pexpect_conninfo.before ) psqlparser.PsqlParser ( ) ) pg_pass : str , def test_parse_new_prompt_and_rest ( ) - > None : psql = PsqlWrapper ( `` '' , self.tok_pre_port + self.tok_port + \ self.pg_port , way we can avoid writing a command-line argument parser . '' '' '' psqlparser.PsqlParser ( ) ) with psycopg.connect ( `` host= '' + self.pg_host reduce ( lambda x , y : x + y , sys.argv [ 1 : ] , `` '' ) # concat arguments columns : list [ Column ] = sql_parser.get_query_columns ( sanitized_sql ) pg_host : str , def main ( ) - > None : sql_parser : SqlParser = SqlParser ( conn ) def test_parse_new_prompt_and_rest ( ) : `` user= '' + self.pg_user # analysis modules res_list [ 2 ] [ : :-1 ] self.pg_user : str = pg_user self.pg_port : str = pg_port def run_analysis ( self , sql_query : str ) - > str : print_msg + `` \r\n\r\n '' def new_psqlwrapper ( ) - > PsqlWrapper : from .psqlwrapper import PsqlWrapper res_list [ 1 ] [ : :-1 ] from .sqlparser import SqlParser , Column Word ( identbodychars + `` / . '' ) control codes . \n is newline ( carriage return \r will be added by \ pg_user : str , tok_host : ParserElement = \ def get ( self ) - > ( str , str , str , str , str ) : self.pg4n_message + `` \r\n\r\n '' `` `` '' Analyze given SQL queries via a plethora of analysis modules . '' '' '' # ^either stops after dbname or includes \x1b [ ? 2004l ... Literal ( `` \ '' via socket in \ '' '' ) tok_pre_user : ParserElement = \ wrapper ) . def _replace_prompt ( self , prompt : bytes ) - > bytes : def start ( self ) : import pexpect from . import psqlparser results = [ `` , from .cmp_domain_checker import CmpDomainChecker class SemanticRouter : from .psqlconninfo import PsqlConnInfo analysis_result = CmpDomainChecker ( sanitized_sql , columns ) .check ( ) self.tok_pre_user + self.tok_user + \ Literal ( `` \ '' on host \ '' '' ) | \ Word ( nums ) from typing import Optional except ParseException as e : ... + StringEnd ( ) from . import psqlwrapper self.pg_pass = `` '' tok_port : ParserElement = \ Word ( identbodychars ) self.pg_pass , print ( f '' { os.path.basename ( sys.executable ) } \ from pyparsing import \ def main ( ) : return analysis_result if len ( res_list ) == 4 : # includes \x1b [ ? 2004l lambda x : `` Test '' , ) : e.explain ( ) ) `` `` '' psql = PsqlWrapper ( sys.argv [ 1 ] .encode ( `` utf-8 '' ) , PsqlParser ( ) ) analysis_result : Optional [ str ] = None def test_parse_last_found_stmt ( ) - > None :","['src/pg4n/main.py', 'src/pg4n/psqlconninfo.py', 'src/pg4n/psqlparser.py', 'src/pg4n/psqlwrapper.py', 'src/pg4n/semanticrouter.py', 'src/pg4n/test/test_psqlparser.py', 'src/pg4n/test/test_psqlwrapper.py']",2022-09-23 11:55:17+00:00,2022-10-26 09:21:21+00:00,2022-11-07 20:09:02+02:00
12,6c5e663747462817aa670b59addb191b618c5eb9,0.0091631393879652,0,"Turn an SQL statement , its results , and a QEP into an insightful message to the user . # 6 # 7 # 8 # 9",Basic semantic analysis,Merge pull request # 29 from Project-C-SQL/feat/qep-parser,"return QEPNode ( self._qep [ `` Plan '' ] ) assert qep.root [ 0 ] .plan [ `` Node Type '' ] == `` Index Scan '' assert qep.plan [ `` Alias '' ] == `` stories '' load= [ load_database ] , class QEPAnalysis : def __call__ ( self , stmt : str , * args , * * kwargs ) - > QEPAnalysis : if ( n : = len ( res [ 0 ] [ 0 ] ) ) ! = 1 : drop table if exists users ; with conn.cursor ( ) as cur : `` `` '' The root node of the query execution plan . '' '' '' if ( n : = len ( res ) ) ! = 1 : # TODO : break into variants discriminated by Node Type def qep ( self ) - > qep : def find ( self , pred : Callable [ [ node ] , bool ] ) - > list [ node ] : `` `` '' A node in a query execution plan . '' '' '' qep = parser ( `` select * from stories '' ) `` Actual Startup Time '' : float , import qepparser self._ref = not not conn qep = parser ( `` select * from users where id = 1 '' ) story_id integer references stories ( id ) on delete cascade , return self._node.__repr__ ( ) password=getenv ( `` POSTGRES_PASSWORD '' , `` postgres '' ) ) `` Actual Total Time '' : float , self._conn : connection = conn or psycopg2.connect ( * args , * * kwargs ) qep = parser ( `` select * from users '' ) stmt : The query to execute . `` `` '' Performs analyses on given queries , returning resultant QEPAnalysis . '' '' '' qep = parser ( `` select * from stories where id = 1 '' ) return map ( QEPNode , self._node [ `` Plans '' ] ) } ) self._conn.rollback ( ) `` Index Cond '' : str , qep = parser ( `` select * from comments '' ) def __iter__ ( self ) - > Iterable [ `` QEPNode '' ] : return self._qep.__repr__ ( ) import psycopg2 `` `` '' A dict of the node 's properties . '' '' '' insert into users ( name ) values ( 'user1 ' ) ; def __len__ ( self ) - > int : return list ( filter ( pred , self._node [ `` Plans '' ] ) ) insert into stories ( name ) values ( 'story2 ' ) ; postgresql_in_docker = factories.postgresql_noproc ( `` Plan Width '' : int , `` Actual Loops '' : int , insert into users ( name ) values ( 'user2 ' ) ; from typing import Callable , Iterable , List , TypedDict assert qep.plan [ `` Actual Rows '' ] == 1 def __init__ ( self , * args , conn=None , * * kwargs ) : return self._node create table stories ( id serial primary key , name varchar ) ; `` `` '' Get the child node at the given index . '' '' '' return self._qep [ `` Plan '' ] `` `` '' Represents the result of EXPLAIN ANALYZE . '' '' '' return QEPNode ( self._node [ `` Plans '' ] [ key ] ) comment varchar ) ; from pytest_postgresql import factories return self._qep `` Actual Rows '' : int , def __del__ ( self ) : from os import getenv `` Scan Direction '' : str , `` Total Runtime '' : float , `` `` '' Test that the QEP structure is as expected . '' '' '' return QEPAnalysis ( res [ 0 ] [ 0 ] [ 0 ] ) A dictionary representing the query execution plan . insert into comments ( story_id , user_id , comment ) values ( 1 , 1 , 'comment1 ' ) ; postgresql = factories.postgresql ( `` postgresql_in_docker '' ) drop table if exists comments ; `` Plan Rows '' : int , def plan ( self ) - > node : qep = parser ( `` select * from stories where id = 1 or id = 2 '' ) Parameters : assert qep.root [ 0 ] .plan [ `` Relation Name '' ] == `` users '' qep = parser ( `` select * from comments where id = 1 and id = 2 '' ) conn.commit ( ) assert qep.root [ 0 ] .plan [ `` Relation Name '' ] == `` stories '' raise ValueError ( f '' Expected dict in column , got { t } '' ) self._qep = qep_ qep = parser ( `` select * from comments where id = 1 '' ) demonstrates relational data assert qep.root [ 0 ] .plan [ `` Alias '' ] == `` users '' `` Plans '' : List [ `` node '' ] , insert into comments ( story_id , user_id , comment ) values ( 2 , 2 , 'comment4 ' ) ; def __getitem__ ( self , key : int ) - > `` QEPNode '' : `` `` '' A dict of the root node 's properties . '' '' '' `` `` '' Iterate over child nodes . '' '' '' assert qep.plan [ `` Node Type '' ] == `` Index Scan '' # are available for each node type `` Filter '' : str , assert qep.root [ 0 ] .plan [ `` Actual Rows '' ] == 0 assert qep.plan [ `` Alias '' ] == `` users '' def __init__ ( self , node_ : node ) : assert qep.plan [ `` Relation Name '' ] == `` users '' return self ( stmt , * args , * * kwargs ) def test_qep_structure ( parser : qepparser.QEPParser ) : return len ( self._node [ `` Plans '' ] ) * * kwargs : Keyword arguments to pass to cursor.execute ( ) . return self._node [ `` Plans '' ] class QEPNode : assert qep.plan [ `` Relation Name '' ] == `` comments '' import pytest `` Triggers '' : list [ str ] , `` Execution Time '' : float , node = TypedDict ( `` Plan '' , { assert qep.plan [ `` Node Type '' ] == `` Result '' insert into comments ( story_id , user_id , comment ) values ( 1 , 2 , 'comment2 ' ) ; user_id integer references users ( id ) on delete cascade , def parser ( postgresql : connection ) : assert qep.root [ 0 ] .plan [ `` Alias '' ] == `` stories '' create table comments ( assert qep.plan [ `` Node Type '' ] == `` Seq Scan '' qep = parser ( `` select * from users where id = 1 and id = 2 '' ) def __str__ ( self ) : assert qep.plan [ `` Relation Name '' ] == `` stories '' raise ValueError ( f '' Expected 1 column , got { n } '' ) self._node = node_ def plans ( self ) - > list [ node ] : populate with sample data Returns : stmt = f '' explain ( format json , analyze , verbose ) { stmt.strip ( ) .rstrip ( ' ; ' ) } ; '' `` Planning Time '' : float , user=getenv ( `` POSTGRES_USER '' , `` postgres '' ) , Executes a query and returns the query execution plan as a dictionary . `` `` '' A list of the node 's children . '' '' '' `` Node Type '' : str , # right now , the interface is n't safe to use because it 's not clear what fields drop table if exists stories ; `` `` '' ) self._conn.close ( ) raise ValueError ( f '' Expected 1 item in column , got { n } '' ) def root ( self ) - > QEPNode : for copy-and-pasting insert into stories ( name ) values ( 'story1 ' ) ; conn : connection = psycopg2.connect ( * * kwargs ) `` Relation Name '' : str , id serial primary key , `` `` '' Get the number of child nodes . '' '' '' assert qep.root [ 0 ] .plan [ `` Relation Name '' ] == `` comments '' `` Parent Relationship '' : str , return self._node.__str__ ( ) res = cur.fetchall ( ) qep = parser ( `` select * from users where id = 1 or id = 2 '' ) with self._conn.cursor ( ) as cur : from psycopg2.extensions import connection `` Index Name '' : str , `` `` '' A dict of the query execution plan 's properties . '' '' '' `` Plan '' : node , cur.execute ( stmt , * args , * * kwargs ) cur.execute ( `` '' '' `` Total Cost '' : float , if ( n : = len ( res [ 0 ] ) ) ! = 1 : `` `` '' Find nodes matching the predicate . '' '' '' raise ValueError ( f '' Expected 1 row , got { n } '' ) assert qep.plan [ `` Actual Rows '' ] == 2 if ( t : = type ( res [ 0 ] [ 0 ] [ 0 ] ) ) ! = dict : `` Alias '' : str , '' 'Alias for __call__ '' ' def __repr__ ( self ) : def __init__ ( self , qep_ : qep ) : if not self._ref : assert qep.plan [ `` Node Type '' ] == `` Bitmap Heap Scan '' qep = TypedDict ( `` QEP '' , { def load_database ( * * kwargs ) : assert qep.root [ 0 ] .plan [ `` Alias '' ] == `` comments '' assert qep.plan [ `` Actual Rows '' ] == 4 * text=auto qep = parser ( `` select * from stories where id = 1 and id = 2 '' ) * args : Positional arguments to pass to cursor.execute ( ) . return qepparser.QEPParser ( conn=postgresql ) create table users ( id serial primary key , name varchar ) ; assert qep.plan [ `` Alias '' ] == `` comments '' def parse ( self , stmt : str , * args , * * kwargs ) - > QEPAnalysis : return self._qep.__str__ ( ) `` Startup Cost '' : float , `` `` '' class QEPParser : insert into comments ( story_id , user_id , comment ) values ( 2 , 1 , 'comment3 ' ) ;","['.gitattributes', 'qepparser.py', 'test_qepparser.py']",2022-09-23 11:57:31+00:00,2022-10-13 10:28:11+00:00,2022-10-11 17:32:29+03:00
12,672575a8e3f414ce9ffa1f47b1e18b13d13fb9eb,0.0148499486967921,0,"Turn an SQL statement , its results , and a QEP into an insightful message to the user . # 6 # 7 # 8 # 9",Basic semantic analysis,Merge pull request # 44 from Project-C-SQL/feat/improve-qeps,"`` `` '' Finds nodes matching the predicate , recursively . stmt = f '' explain ( format json , analyze , verbose ) { stmt.strip ( ) .rstrip ( ' ; ' ) } ; '' stmt.strip ( ) .rstrip ( ' ; ' ) + `` ; '' assert len ( qep.root.rfindval ( `` Node Type '' , `` Bitmap Index Scan '' ) ) == 4 : param node_ : the node to wrap '' '' '' return map ( QEPNode , self._node.get ( `` Plans '' , [ ] ) ) To install all dependencies and the application , type ` poetry install ` . After installation , if the Python scripts folder is in your PATH , you should be able to invoke ` main.main ( ) ` with ` pg4n ` . assert qep.root.findval ( `` Relation Name '' , `` comments '' ) == [ qep.plan ] assert qep.root.findval ( `` Relation Name '' , `` users '' ) == [ qep.plan ] password=getenv ( `` PGPASSWORD '' , `` postgres '' ) ) cur.execute ( `` set constraint_exclusion = on ; '' ) qep = parser ( `` select * from stories '' ) `` `` '' Test that the QEP rfind ( recursive find ) method works as expected . '' '' '' assert qep.root.findval ( `` Actual Rows '' , 1 ) == [ qep.plan ] assert qep.root.findval ( `` Node Type '' , `` Seq Scan '' ) == [ qep.plan ] qep = parser ( `` select * from users where id = 1 '' ) return list ( filter ( pred , self._node [ `` Plans '' ] ) ) | ` PGDBNAME ` | ` test_database ` | Database name . | : param recursive : if True , search recursively , otherwise only search password=getenv ( `` PGPASSWORD '' ) , `` `` '' Finds nodes with the given key and value , recursively . self._ref = not not conn `` `` '' Finds nodes matching the predicate . qep = parser ( `` select * from users '' ) Having PostgreSQL running on port 5432 , do ` poetry run pytest ` . qep = parser ( `` select * from stories where id = 1 '' ) self._ref = bool ( conn ) assert qep.root.findval ( `` Alias '' , `` users '' ) == [ qep.plan ] | ` PGUSER ` | ` postgres ` | The user that will be used to manage the test database . | assert qep.root.findval ( `` Actual Rows '' , 4 ) == [ qep.plan ] from itertools import chain def find ( self , pred : Callable [ [ node ] , bool ] ) - > list [ node ] : qep = parser ( `` select * from comments '' ) To get a similar PostgreSQL instance as with GitHub Actions workflow : < br > | -- -- -- -- -- -- | -- -- -- -- -- -- -- - | -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - | : param pred : a function that takes a node and returns True if it matches list ( chain.from_iterable ( x.find ( pr , True ) for x in iter ( self ) ) ) return self._node.get ( `` Plans '' , [ ] ) `` `` '' Get the child node at the given index . : param pr : a function that takes a node and returns True if it matches | ` PGPORT ` | ` 5432 ` | Port to an active PostgreSQL instance . | return self.find ( lambda x : x.get ( key ) == val , recursive ) def test_qep_find ( parser : qepparser.QEPParser ) : assert qep.root.findval ( `` Relation Name '' , `` stories '' ) == [ qep.plan ] | ` PGHOST ` | ` 127.0.0.1 ` | Hostname of the PostgreSQL server . | def findval ( self , key : str , val : object , recursive=False ) - > list [ node ] : | ` PGPASSWORD ` | | Password , in case password authentication is used . | : param key : the key to search for def rfind ( self , pred : Callable [ [ node ] , bool ] ) - > list [ node ] : To install all dependencies and the application , type ` poetry install ` . After installation , if the Python scripts folder is in your PATH , you should be able to invoke ` main.main ( ) ` with ` pg4n ` . `` `` '' Test that the QEP find method works as expected . '' '' '' this+children `` `` '' Finds nodes with the given key and value . assert qep.root.findval ( `` Actual Rows '' , 2 ) == [ qep.plan ] qep = parser ( `` select * from users where id = 1 or id = 2 '' ) assert qep.root.findval ( `` Node Type '' , `` Index Scan '' ) == [ qep.plan ] | Variable | Default value | Description | `` `` '' Get the child node at the given index . '' '' '' with self._conn.cursor ( ) as cur : assert qep.root.findval ( `` Alias '' , `` stories '' ) == [ qep.plan ] return self.find ( pr ) + \ For example , if PostgreSQL is on port 5433 , just do ` PGPORT=5433 poetry run pytest ` ( Bash syntax ) . Having PostgreSQL running on port 5432 , do ` poetry run pytest ` ( or , if on port x , just do ` PGPORT=x poetry run pytest ` ) . qep = parser ( `` select * from comments where id = 1 or id = 2 '' ) return self.findval ( key , val , recursive=True ) stmt = `` explain ( format json , analyze , verbose ) '' + \ return list ( filter ( pr , chain ( ( self._node , ) , self.plans ) ) ) return self._node [ `` Plans '' ] assert len ( qep.root.rfindval ( `` Node Type '' , `` Bitmap Heap Scan '' ) ) == 1 qep = parser ( `` select * from stories where id = 1 or id = 2 '' ) self._conn.commit ( ) def test_gep_rfind ( parser : qepparser.QEPParser ) : You may need to provide environment variables that match your config : `` `` '' Find nodes matching the predicate . '' '' '' `` `` '' Create a new QEPNode . return map ( QEPNode , self._node [ `` Plans '' ] ) To get a similar instance as with GitHub Actions workflow : < br > return self.find ( pred , recursive=True ) : returns : the child node at the given index assert qep.root.findval ( `` Alias '' , `` comments '' ) == [ qep.plan ] if recursive : : returns : a list of matching nodes assert len ( qep.root.rfindval ( `` Node Type '' , `` BitmapOr '' ) ) == 2 dbname=getenv ( `` PGDBNAME '' , `` test_database '' ) ) qep = parser ( `` select * from comments where id = 1 '' ) recursive=False ) - > list [ node ] : def rfindval ( self , key : str , val : object ) - > list [ node ] : `` `` '' : param val : the value to search for : param key : the index of the child node to get # use constraint_exclusion to avoid unnecessary index scans def find ( self , pr : Callable [ [ node ] , bool ] ,","['README.md', 'src/pg4n/qepparser.py', 'src/pg4n/test/test_qepparser.py']",2022-09-23 11:57:31+00:00,2022-10-13 10:28:11+00:00,2022-11-05 13:28:47+02:00
12,535fdf800713ce7b74f1e330e9c02af0bb981db2,0.00357292057015,0,"Turn an SQL statement , its results , and a QEP into an insightful message to the user . # 6 # 7 # 8 # 9",Basic semantic analysis,Merge pull request # 95 from Project-C-SQL/feat/error-handling-and-syntax-error-detection,"def parse_new_prompt_and_rest ( self , psql : str ) - > list [ str ] : prompt_res = match_rev_prompt_end.parse_string ( psql_rev ) Literal ( `` psql ( PostgreSQL ) `` ) + Combine ( Word ( nums ) + ' . ' + Word ( nums ) ) SubquerySelectChecker ( sanitized_sql , sql_parser ) .check ( ) from pyparsing import ( prompt_res = match_rev_prompt_end.parse_string ( psql_rev ) # Licensed under MIT . self.tok_rev_prompt_end psql_args : str # Semantic analysis is always done when user presses Return after most recent query . pg_user : str , # Comparing different domains Char ( ' ; ' ) from shutil import get_terminal_size psql.ofilter ( b'\r\n\r\r\n ' ) self , analysis_result = SubquerySelectChecker ( if output [ 0:2 ] == b'\r\n ' : qep_analysis def test_parse_last_stmt ( ) - > None : except Exception : # Matches only program errors ( see flake8 rule E722 ) ) - > bytes : # Opt ( Literal ( ' * ' ) | Literal ( ' ! ' ) | Literal ( ' ? ' ) , `` '' ) psql.ofilter ( b'\x1b [ ? 2004htest_db- # ' ) except ParseException : psql.ofilter ( b '' '\r ( reverse-i-search ) ` ' : `` ) assert p.output_has_new_prompt ( case_mixed_results ) # SUM/AVG ( DISTINCT ) def parse_new_prompt ( self , psql : str ) - > List [ str ] : def _check_and_act_on_repl_output ( # AND-clause will stop executing after first False . match_rev_magical_returns.parse_string ( psql_rev ) analysis_result = CmpDomainChecker ( sanitized_sql , columns ) .check ( ) self.tok_pre_database + self.tok_database assert p.parse_last_stmt ( case_trivial ) == \ pg_user : str , `` `` '' line and then the prompt , to allow easy message injection . res_list [ 1 ] [ : :-1 ] # see how the screen would look like , but still allow injecting to pick up relevant SQL statements and syntax errors for hook functions . '' '' '' if self.parser.output_has_magical_return ( res_list [ 2 ] [ : :-1 ] Word , assert p.parse_last_found_stmt ( case_multiline_query ) == \ psql_rev : str = psql [ : :-1 ] if magical_return_res : if self.pg4n_message ! = `` '' \ def test_output_has_new_prompt ( ) - > None : # Literal ( `` ERROR : '' ) return input reduce ( lambda x , y : x + y [ : :-1 ] , results , `` '' ) psql._intercept ( b'\r\n\r\r\n ' ) # Wildcards without LIKE `` `` '' if output [ 0:2 ] == b '' \r\n '' : ) : analysis_result : Optional [ str ] = None def test_output_has_magical_return ( ) - > None : return self.pg_tuple psql.start ( ) intercepted queries and syntax errors . psql._intercept ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 100\x1b [ 27m ; \x08\x08\x08\x08\x08\x08 '' ) # Turn on verbose output to psqlparser.log file in working directory from pyparsing import Literal , Word , ParseException , ParserElement , \ `` psql `` + bytes.decode ( self.psql_args ) , prompt_res : Optional [ ParseResults ] = None : returns : an empty list if no prompt found . Otherwise has [ ' > = ' ] or \ unreversed_flattened_res : str = reduce ( def test_parse_magical_return ( ) - > None : # SQL parser , QEP parser , or an analysis module exploded : # Since latest_output contains error details , we will have to bytes.decode ( latest_output ) # `` = > SELECT psql.ofilter ( b'\r\n\x1b [ ? 2004l\r ' ) `` - ! > '' , `` * ! > '' , `` \ ' ! > '' , `` \ '' ! > '' , `` $ ! > '' , `` ( ! > '' , pg_host : str , return bytes ( line and then the prompt , to allow easy message injection . sql_parser : SqlParser = SqlParser ( conn ) assert psql._intercept ( fresh_prompt_1 ) == \ self.tok_pre_database + self.tok_database + \ match_rev_magical_returns : ParserElement = \ psql = PsqlWrapper ( sys.argv [ 1 ] .encode ( `` utf-8 '' ) , `` `` '' Start psql process and feed hook functions with \ encoding= '' utf-8 '' , assert psql._intercept ( case_query_2_prompt ) == \ main.py [ psql arguments ] < database name > '' ) def check_psql_version ( self ) - > str : self.tok_pre_user + self.tok_user Literal , def parse_new_prompt_and_rest ( self , psql : str ) - > List [ str ] : # for optimization reasons , check output only if len ( ) > 1 , so most psql._intercept ( case_query_1 ) `` `` '' Check for weird Return presses . self.parser.parse_new_prompt_and_rest ( tok_stmt_end psql.ofilter ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C1 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 1\x1b [ 27m00 ; \x08\x08\x08\x08\x08\x08 '' ) .replace ( db_name + `` - > '' , `` '' ) \ and self.parser.parse_new_prompt ( tok_rev_error : ParserElement = Literal ( `` : RORRE '' ) res_list [ 2 ] [ : :-1 ] + res_list [ 1 ] [ : :-1 ] + res_list [ 0 ] [ : :-1 ] try : self.tok_rev_prompt_end def test_parse_new_prompt ( ) - > None : if len ( res_list ) == 4 : # results include \x1b [ ? 2004l # prompt1 per bin/psql/prompt.c : match_rev_last_stmt : ParserElement = ( split_prompt [ 1 ] , assert psql.ofilter ( fresh_prompt_1 ) == \ print ( f '' { os.path.basename ( sys.executable ) } \ results = [ : returns : a two-part list with everything before the prompt \ assert p.parse_last_stmt ( case_select_then_select ) == \ match_rev_last_stmt : ParserElement = \ ' . ' def test_ofilter ( ) - > None : StringEnd , self.pg_tuple = ( if prompt_res : ( Literal ( ' # ' ) | Literal ( ' > ' ) ) are received . `` port= '' + self.pg_port no_newlines_res = unreversed_flattened_res.replace ( '\n ' , ' ' ) def check_and_act_on_repl_output ( self , latest_output : bytes ) - > bytes : Literal ( `` psql ( PostgreSQL ) `` ) psql_rev = psql [ : :-1 ] # slicing is fastest operation for reversing # prompt : analysis_result = CmpDomainChecker ( bytes.decode ( prompt , `` utf-8 '' ) ) return has_magical_return # rev means reversed , these are for performance reasons . from typing import Optional , Tuple return `` Pg4n has only been tested on psql versions `` + \ analysis_result = EqWildcardChecker ( print_msg + `` \r\n\r\n '' if self.parser.output_has_new_prompt ( self.tok_rev_prompt_end def __init__ ( self , psql_args : str ) : SumDistinctChecker ( sanitized_sql , qep_analysis ) .check ( ) CaselessLiteral , to pick up relevant SQL statements for the hook function . potential_future_contents : str = '\n'.join ( # If we have a semantic error message waiting and there is a fresh `` user= '' + self.pg_user `` `` '' Parse for syntax error output . self.tok_pre_host + self.tok_host + \ conn ) .check ( ) : returns : syntax error message from 'ERROR : ' to last '^ ' . self.pg4n_message = self.semantic_analyze ( parsed_sql_query ) qep_analysis : QEPAnalysis = QEPParser ( conn=conn ) .parse ( sql_query ) version_info = \ `` - ? > '' , `` * ? > '' , `` \ ' ? > '' , `` \ '' ? > '' , `` $ ? > '' , `` ( ? > '' ] : returns : an empty string if current version has been tested , \ `` dbname= '' + self.pg_name psql.ofilter ( b'SELECT ' ) bytes.decode ( latest_output ) ) ! = [ ] : # there is new prompt self.match_rev_any_sql_stmt + Word ( self.prompt_chars ) psql.ofilter ( b'\r\x1b [ C ' ) # ( Return is always at least 2 length ) psql.ofilter ( b'\r\x1b [ K\x1b > \x1b [ r\x1b [ ? 1049l ' ) reversed_flattened_res : str = \ # input does not trigger parsing ( Return is always at least 2 length ) psql._intercept ( b'orders ' ) potential_future_screen = \ results = [ res_list [ 3 ] [ : :-1 ] , potential_future_screen_output_sink.feed ( psql.ofilter ( b'SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; ' ) import sys psql._intercept ( b'\r\x1b [ K\x1b > \x1b [ r\x1b [ ? 1049l ' ) : returns : if output is a fresh prompt . ImpliedExpressionChecker ( sanitized_sql , sql_query , if version == `` '' : c.interact ( input_filter=lambda x : x , output_filter=self._intercept ) latest_output : bytes : param prompt : is where the message is injected . A fresh prompt is \ sanitized_sql : exp.Expression = sql_parser.parse_one ( sql_query ) # debug creates pyte.screen ( current screenscraping context ) and Opt ( Literal ( ' * ' ) | Literal ( ' ! ' ) | Literal ( ' ? ' ) , `` '' ) stmt_res = match_error_statement.parse_string ( psql_rev ) pexpect.spawn ( `` psql `` + bytes.decode ( self.psql_args ) psql.ofilter ( b'\x08\x08 ' ) psql.ofilter ( b'\r\n ' ) def ofilter ( self , output : bytes ) - > bytes : : returns : a prompt with injected message , or unchanged if \ `` `` '' Forward output to ` _check_and_act_on_repl_output ` and feed \ StrangeHavingChecker ( sanitized_sql , qep_analysis ) .check ( ) def parse_syntax_error ( self , psql : str ) - > str : # magic strings ( related at least to ctrl-R use ) are lambda x , y : x + y [ : :-1 ] , results , `` '' else : from pyparsing import \ ) - > None : `` `` '' Detect when psql query evaluation has ended by parsing for a new prompt . psql._intercept ( b'\x1b [ ? 2004htest_db- # ' ) psql._intercept ( b ' ; ' ) assert p.parse_last_stmt ( case_empirical_1 ) == \ # from .inconsistent_expression_checker import InconsistentExpressionChecker `` `` '' Forward output to ` check_and_act_on_repl_output ( ) ` and feed \ with . CaselessLiteral , Char , Combine , Literal , ParseException , \ # and resulting message is saved here until when new prompt comes in # Inconsistent expression from functools import reduce # just match against a list of all possible combinations hook_semantic_f : Callable [ [ str ] , str ] , `` user= '' + self.pg_user # % / % R % x % # per postgres bin/psql/settings.h except ParseException as e : : returns : if user has indeed hit return . sql_query : str if len ( res_list ) == 2 : # parsing stops right after database name # replacing \n 's with `` '' maybe has less edge cases . Or actually more . sanitized_sql , `` SELECT * FROM orders WHERE order_total_eur = 100 ; '' # tok_multiline_prompt_end : ParserElement = \ `` `` '' Initiate session by getting psql connection parameters via psql \ # % / = current database psql_rev : str = psql [ : :-1 ] # slicing is fastest operation for reverse self.parser.parse_last_found_stmt ( screen ) self.pg_name `` psql `` + bytes.decode ( self.psql_args ) + `` -- version '' | Literal ( `` \x08\r\n '' [ : :-1 ] ) demultilined_res : str = no_newlines_res psql._intercept ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C1 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 1\x1b [ 27m00 ; \x08\x08\x08\x08\x08\x08 '' ) # e.g . `` pg4n -- help '' is being run . # should parse as \n - > `` `` to avoid `` SELECT * FROM .. '' . print ( `` pg4n [ psql arguments ] < database name > '' ) # get terminal screen contents # superusers have = # prompt # Literal ( '\ '' ' ) | Literal ( ' $ ' ) | Literal ( ' ( ' ) ) # multiple elements into one . These are often combined to build functions elif len ( res_list ) == 2 : # parsing stops right after database name # Analysis is always done when user presses Return [ `` # = '' ] self.pg_pass , Literal ( `` > = '' ) | Literal ( `` # = '' ) with psycopg.connect ( `` host= '' + self.pg_host def start ( # SELECT in subquery Word ( nums ) # Inconsistent expression InconsistentExpressionChecker ( sanitized_sql , qep_analysis ) .check ( ) psql.ofilter ( b'orders ' ) # possibly provide a message to be included in next new prompt . stmt_chars : str = \ Control is only returned after psql process exits . tok_marker_caret : ParserElement = Literal ( `` ^ '' ) ZeroOrMore ( White ( ) ) from typing import List control codes . \n is newline ( carriage return \r will be added by \ multiline_prompt_ends : list [ str ] = \ assert p.parse_last_stmt ( case_query_with_newline ) == \ [ `` - # '' , `` * # '' , `` \ ' # '' , `` \ '' # '' , `` $ # '' , `` ( # '' , `` SELECT * FROM orders WHERE order_total_eur = 100 ; '' ZeroOrMore ( Char ( `` \n '' ) | Char ( `` \r '' ) | White ( ) ) debug : bool = False match_rev_prompt_and_then_rest : ParserElement = ( psql.ofilter ( case_psql_start ) stmt_res : Optional [ ParseResults ] = None assert p.parse_last_found_stmt ( case_multiple_queries_and_whitespaces ) == \ respectively . self `` `` '' Parse for a fresh prompt and everything preceding it into 2-length \ f.write ( '\n'.join ( line.rstrip ( ) for line in self.pyte_screen.display ) # and resulting message is saved until when new prompt comes in bytes.decode ( output , `` utf-8 '' ) output_filter=self.ofilter ) `` -- version '' ) stmt_chars : str = printable.translate ( str.maketrans ( `` '' , `` '' , stmt_end ) ) ) sql_parser : returns : unchanged input . SubqueryOrderByChecker ( sanitized_sql , qep_analysis ) .check ( ) psql._intercept ( b ' * ' ) `` - ! # '' , `` * ! # '' , `` \ ' ! # '' , `` \ '' ! # '' , `` $ ! # '' , `` ( ! # '' , messages are passed to , and from which corresponding warning messages \ detecting new prompt fails . sem_router = SemanticRouter ( * conn_info ) # asterisk unpacks the 5-tuple pg_name : str return assert p.parse_new_prompt ( case_trivial ) == \ `` utf-8 '' print_msg + `` \r\n\r\n '' : param input : user input characters . stmt_res_list [ 1 ] ] # `` pgdb= > SELECT def test_parse_last_found_stmt ( ) - > None : : param prompt : is output where message is injected to . A fresh prompt \ ) .check ( ) ] # * FROM orders WHERE order_total_eur = 100 ; c.interact ( input_filter=self.ifilter , psql._intercept ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 10\x1b [ 27m0 ; \x08\x08\x08\x08\x08\x08 '' ) analysis_result = StrangeHavingChecker ( `` utf-8 '' ) psql._intercept ( b'\r\n ' ) res_list [ 3 ] [ : :-1 ] , def parse_magical_return ( self , psql : str ) - > List [ str ] : return bytes ( split_prompt [ 0 ] + `` \r\n '' split_prompt : List [ str ] = self.parser.parse_new_prompt_and_rest ( tok_stmt_end : ParserElement = Char ( ' ; ' ) sql_parser : SqlParser = SqlParser ( conn ) `` Pg4n has only been tested on psql versions `` `` `` '' Handle semantic analysis modules . '' '' '' psql._intercept ( b '' \r\n\x1b [ ? 2004l\r '' ) `` . '' elif len ( res_list ) == 4 : # results include \x1b [ ? 2004h .. EqWildcardChecker ( sanitized_sql , qep_analysis ) .check ( ) # reverse string for parsing efficiency syntax_error = \ def test_intercept ( ) - > None : if analysis_result is not None : sem_router.run_analysis , psql._intercept ( b'\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) # magic strings related seemingly solely to ctrl-R use are bytes.decode ( output , `` utf-8 '' ) ) ! = [ ] : `` - * # '' , `` * * # '' , `` \ ' * # '' , `` \ '' * # '' , `` $ * # '' , `` ( * # '' , parsed_sql_query : str = self.parser.parse_last_stmt ( screen ) results : List [ str ] = [ ] ParseException , ParserElement , \ psql_output = pexpect.spawn ( # `` \r\n\x1b [ ? 2004l\r '' , `` \r\n\r\r\n '' and `` \x08\r\n '' . encoding= '' utf-8 '' , psql_output.expect ( pexpect.EOF ) self.pg4n_message = `` '' # Strange HAVING clause without GROUP BY self.pg4n_message = self.syntax_analyze ( syntax_error ) psql._intercept ( b'\x1b [ ? 2004l\r\x1b [ ? 2004htest_db- # ' ) assert psql.ofilter ( b'\x1b [ ? 2004l\r order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004htest_db= # ' ) == \ def main ( ) - > None : str ( self.supported_psql_versions ) + `` . '' if magical_return_res : assert p.parse_last_found_stmt ( case_trivial ) == \ # This will match against `` % R % x % # `` , e.g `` = > `` . # Strange HAVING clause without GROUP BY line.rstrip ( ) for line in self.pyte_screen.display ) parsed_sql_query : str = \ if stmt_res : def start ( self ) - > None : self : param db_name_parameter : is name of database we are connecting to . # % R = - , * , ' , `` ; also $ , ( if syntax_error ! = `` '' : return analysis_result : param psql : screenscraped psql string with only whitespace \ list , facilitating easy message injection . `` - > '' , `` * > '' , `` \ ' > '' , `` \ '' > '' , `` $ > '' , `` ( > '' , `` host= '' + self.pg_host self.tok_pre_port + self.tok_port + \ psql.ofilter ( b '' \r\n\x1b [ ? 2004l\r '' ) # no syntax error analysis : psql.ofilter ( b ' ; ' ) match_rev_prompt_end : ParserElement = self.tok_rev_prompt_end return has_new_prompt assert p.parse_last_found_stmt ( case_query_with_newline ) == \ pg_pass : str , assert psql._intercept ( b'\x1b [ ? 2004l\r order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004htest_db= # ' ) == \ psql.ofilter ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 100\x1b [ 27m ; \x08\x08\x08\x08\x08\x08 '' ) name . psql._intercept ( b '' \x1b [ A\rtest_db= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; \x1b [ K\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\r\n\r '' ) psql.ofilter ( b'\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) psql._intercept ( b'FROM ' ) f.write ( str ( e.explain ( ) ) + `` \n '' ) columns def ifilter ( self , input : bytes ) - > bytes : from typing import Optional except ParseException as e : | ( # or continue \x1b [ ? .. [ ' # = ' ] . def __init__ ( new_output : bytes = self._replace_prompt ( latest_output ) # as interesting things usually are at end of a long string . printable.translate ( str.maketrans ( `` '' , `` '' , stmt_end ) ) ) - > str : StringEnd ( ) from typing import Optional psql._intercept ( b'\x08\x08 ' ) def parse_last_found_stmt ( self , psql : str ) - > str : deepcopy ( self.pyte_screen ) ) self.parser.parse_syntax_error ( potential_future_contents ) # cheaper and easier to reverse & start from the end # % # = # , > from .psqlconninfo import PsqlConnInfo : param hook_semantic_f : is a callback to which scraped SQL queries are\ # for optimization reasons , check output only if len ( ) > 1 , so keyboard psql._intercept ( b'SELECT ' ) [ `` > = '' ] from copy import deepcopy assert p.parse_last_stmt ( case_select_then_insert ) == \ Word ( nums ) psql.ofilter ( case_query_1 ) from .psqlparser import PsqlParser evaluation has ended . ) if self.debug : : returns : an empty list if no presses are found . \ # This will match against `` % R % x % # `` , e.g `` - > `` . # SELECT in subquery Char , res_list = prompt_res.as_list ( ) output : bytes pg_port : str , from functools import reduce return ( # * FROM orders WHERE order_total_eur = 100 ; '' # % x = nothing , * , ! , ? c = pexpect.spawn ( `` psql `` + bytes.decode ( self.psql_args ) , # ( Literal ( '- ' ) | Literal ( ' * ' ) | Literal ( '\ '' ) | # semantic analysis : from .psqlconninfo import PsqlConnInfo split_prompt [ 1 ] , assert psql.ofilter ( case_query_2_prompt ) == \ psql._intercept ( b '' '\r ( reverse-i-search ) ` ' : `` ) | Literal ( `` \x08\r\n '' [ : :-1 ] ) results = magical_return_res.as_list ( ) tok_rev_prompt_end : ParserElement = Combine ( match_select_stmt : ParserElement = ( demultilined_res = no_newlines_res\ self.pg_port , new_output : bytes = self._check_and_act_on_repl_output ( output ) return `` '' # No semantic errors found ZeroOrMore , assert p.parse_new_prompt ( case_mixed_results ) == \ # should convert \n - > `` `` to avoid `` SELECT * FROM .. '' . hook_f : Callable [ [ str ] , str ] , parser : PsqlParser ) : e.explain ( ) ) Literal ( `` \r\n\x1b [ ? 2004l\r '' [ : :-1 ] ) : param psql : screenscraped psql string res_list [ 0 ] [ : :-1 ] def _check_psql_version ( self ) - > str : # Replacing \n 's with `` `` seems to have less edge cases . self.pg_host , `` `` '' Check PostgreSQL version via psql child process and match \ stmt_res_list [ length - 4 ] ) : stmt_res_list [ length - 4 ] ] return new_output match_rev_any_sql_stmt : ParserElement = \ c = pexpect.spawn ( passed to , and from which corresponding semantic warning messages are \ self.pg_user , wrapper ) . `` psql `` assert p.output_has_new_prompt ( case_trivial ) split_prompt [ 0 ] + `` \r\n '' otherwise a warning message . # `` pgdb= > SELECT * FROM orders WHERE order_tot # either by only having single element , or using Combine to squash ) # should parse as \n - > `` '' psql._intercept ( b'\x1b [ ? 2004l\r\x1b [ ? 1049h\x1b=\r order_id | order_total_eur | customer_id \x1b [ m\r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\x1b [ m\r\n 1 | 535.36 | 111\x1b [ m\r\n 2 | 409.80 | 217\x1b [ m\r\n 3 | 189.43 | 19\x1b [ m\r\n 4 | 144.14 | 157\x1b [ m\r\n 5 | 582.52 | 172\x1b [ m\r\n 6 | 132.85 | 206\x1b [ m\r\n 7 | 183.92 | 236\x1b [ m\r\n 8 | 424.80 | 244\x1b [ m\r\n 9 | 519.43 | 175\x1b [ m\r\n 10 | 414.55 | 234\x1b [ m\r\n 11 | 88.19 | 50\x1b [ m\r\n 12 | 591.72 | 143\x1b [ m\r\n 13 | 503.52 | 216\x1b [ m\r\n 14 | 586.06 | 181\x1b [ m\r\n 15 | 47.79 | 248\x1b [ m\r\n 16 | 330.92 | 130\x1b [ m\r\n 17 | 302.31 | 225\x1b [ m\r\n 18 | 438.38 | 26\x1b [ m\r\n 19 | 107.53 | 94\x1b [ m\r\n 20 | ' self.tok_pre_host + self.tok_host ParseResults , return prompt # prompt is malformed and is returned as-is . line.rstrip ( ) for line in self.pyte_screen.display ) ) assert p.parse_magical_return ( case_long_return ) == \ stmt_res_list [ 2 ] , psql._intercept ( case_psql_start ) ParserElement.setDefaultWhitespaceChars ( `` ) to and from which semantic error messages are received in return . `` `` '' Parse for an empty prompt , to detect when a query \ from .psqlwrapper import PsqlWrapper has_new_prompt : bool = False # asterisk unpacks the 5-tuple match_psql_conninfo : ParserElement = ( match_rev_prompt_end : ParserElement = \ stmt_res : ParseResults = None `` `` '' Parse for an empty prompt and everything preceding it \ # should convert \n - > `` '' to avoid `` order_tot al_eur '' # Implied expression ParseException , def output_has_new_prompt ( self , psql : str ) - > bool : : returns : if user has hit return . .replace ( db_name + `` - # '' , `` '' ) psql._intercept ( b'\x08\x08\x08\x08\x08\x08 ' ) `` - ? # '' , `` * ? # '' , `` \ ' ? # '' , `` \ '' ? # '' , `` $ ? # '' , `` ( ? # '' , results = [ `` , match_version_stmt : ParserElement = ( debug : bool = False if stmt_res is not None : analysis_result = \ assert p.output_has_magical_return ( case_long_return ) # ORDER BY in subquery : param hook_f : is a callback to which scraped SQL queries are passed \ output to pyte screen for future screen-scraping . `` `` '' User input filter function for pexpect.interact : not used . Stream ( potential_future_screen ) stmt_res_list [ length - 3 ] , Word ( self.prompt_chars ) + \ magical_return_res = \ Literal ( `` ? [ \x1b '' ) # in this case control code parameter self.pg_pass , ( StringEnd ( ) # output may stop at end of db name , return results match_rev_any_sql_stmt [ `` \rl4002 ? [ \x1b\n\r '' ] is expected , or otherwise no injection is made . match_select_stmt : ParserElement = \ Literal , Word , \ results = [ stmt_res_list [ 3 ] , analysis_result = ImpliedExpressionChecker ( psql.ofilter ( b'\x08order_total_eur = 0 AND order_total_eur = 10\x1b [ C\x1b [ 1P ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) `` port= '' + self.pg_port Opt , conn White , def main ( ) - > None : lambda syntax_error_analysis : `` '' , psql._intercept ( b'\r\x1b [ C ' ) with psycopg.connect ( results = [ stmt_res_list [ length - 3 ] , intercepted output . '' '' '' str ( self.supported_psql_versions ) sem_router = SemanticRouter ( * conn_info ) version_msg = self._check_psql_version ( ) def output_has_magical_return ( self , psql : str ) - > bool : identbodychars , nums psql._intercept ( b'\r\n\x1b [ ? 2004l\r ' ) # feed query to semantic analysis hook function # save a potential warning to be included in before next fresh prompt . # breaks , because both of these work right in straight psql . See : # ORDER BY in subquery ParseResults , ParserElement , StringEnd , White , Word , ZeroOrMore , \ # tok , or token , is parsing element with only single element output , psql._intercept ( b'\x08order_total_eur = 0 AND order_total_eur = 1\x1b [ 1P00 ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) self.match_rev_magical_returns.parse_string ( psql_rev ) new_output = self._replace_prompt ( latest_output ) lambda x , y : x + y , sys.argv [ 1 : ] , `` '' ... : returns : if output has a weird Return press . ) : print ( e.explain ( ) ) ZeroOrMore ( White ( ) ) + CaselessLiteral ( `` SELECT '' ) match_psql_conninfo : ParserElement = \ self.pg_user , CaselessLiteral ( `` SELECT '' ) PsqlParser ( ) self.semantic_analyze : Callable [ [ str ] , str ] = hook_semantic_f Literal ( `` \r\n\x1b [ ? 2004l\r '' [ : :-1 ] ) \ from shutil import get_terminal_size # Parsing functions common to more than 1 parsing functions are listed here # TODO ( ? ) : We may have to match for errors def get ( self ) - > ( str , str , str , str , str ) : results = [ ) unreversed_flattened_res : str = \ # If there is a fresh prompt : tok_rev_prompt_end : ParserElement = \ # for simplicity , just use pexpect here prompt_res : ParseResults = None psql._intercept ( b'\x08order_total_eur = 0 AND order_total_eur = 10\x1b [ C\x1b [ 1P ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) qep_analysis : QEPAnalysis = QEPParser ( conn=conn ) .parse ( sql_query ) # Wildcards without LIKE if self.pg4n_message ! = `` '' : # Implied expression Only one ( static ) class instance is intended for use in program . demultilined_res = demultilined_res.replace ( prompt , `` '' ) output to pyte screen for screenscraping . # keyboard input does not trigger parsing f = open ( `` psqlparser.log '' , `` a '' ) psql.ofilter ( b '' \x08\x08\x08= ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m=\x1b [ 27m 100 ; \x08\x08\x08\x08\x08\x08 '' ) self.analyze : Callable [ [ str ] , str ] = hook_f psql._intercept ( return_press_1 ) psql = PsqlWrapper ( assert p.parse_last_stmt ( case_multiple_queries_and_whitespaces ) == \ # command-line arguments prevent interactive sessions ( e.g pg4n -- help ) if prompt_res : # To save time , since linebreak prompts are only removed , match_rev_any_sql_stmt : ParserElement = ( psql._intercept ( b'SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; ' ) analysis_result = SubqueryOrderByChecker ( sys.argv [ 1 ] .encode ( `` utf-8 '' ) , `` password= '' + self.pg_pass psql.ofilter ( b '' \x1b [ A\rtest_db= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; \x1b [ K\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\r\n\r '' ) ParserElement , tok_stmt_end : ParserElement = \ and then starting the session . '' '' '' psql.ofilter ( b'\x08order_total_eur = 0 AND order_total_eur = 1\x1b [ 1P00 ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) psql.ofilter ( b'FROM ' ) print ( e.explain ( ) ) from .semanticrouter import SemanticRouter psql.ofilter ( return_press_1 ) Combine , dimensions= ( self.rows , self.cols ) ( StringEnd ( ) | ( Literal ( `` ? [ \x1b '' ) self.pg_tuple : Optional [ Tuple [ str , str , str , str , str ] ] = None : returns : a prompt with injected message . ) as conn : self.syntax_analyze : Callable [ [ str ] , str ] = hook_syntax_f sanitized_sql : exp.Expression = sql_parser.parse_one ( sql_query ) ( Literal ( '= ' ) | Literal ( '^ ' ) ) has_new_prompt = True child process , initializing semantic analysis and wrapper modules , \ def run_analysis ( self , sql_query : str ) - > str : # Comparing different domains return `` '' # No semantic errors found def run_analysis ( psql.ofilter ( b'\x1b [ ? 2004l\r\x1b [ ? 2004htest_db- # ' ) analysis_result : Optional [ str ] = None List is empty if no fresh prompt was found . Combine ( res_list [ 1 ] [ : :-1 ] + res_list [ 0 ] [ : :-1 ] split_prompt : List [ str ] = \ potential_future_screen_output_sink = \ version_msg = self.check_psql_version ( ) return `` '' # ( Literal ( ' # ' ) | Literal ( ' > ' ) ) ) expected . # and save resulting message bytes.decode ( prompt , `` utf-8 '' ) ) - > Optional [ Tuple [ str , str , str , str , str ] ] : | Literal ( `` \r\n\r\r\n '' [ : :-1 ] ) self.pg_port , : returns : a two-part list with everything before the prompt \ f.close ( ) psql.ofilter ( b ' * ' ) sem_router.run_analysis , tok_rev_error self.pg4n_message = `` '' tok_marker_caret parser : PsqlParser # an insightful syntax error message from the syntax analysis . tok_rev_prompt_end if conn_info is not None : return unreversed_flattened_res against versions pg4n is tested with . prompt = db_name + multiline_prompt_end `` password= '' + self.pg_pass ) as conn : f.write ( '\n'.join ( ... + StringEnd ( ) ) ) ] reduce ( # Combine ( psql.start ( ) match_rev_magical_returns : ParserElement = ( ] pg_port : str , : param hook_syntax_f : is a callback to which scraped syntax error \ `` `` '' Start psql process and then start feeding hook function with \ # ^either stops after dbname or includes \x1b [ ? 2004l ... if self.parser.parse_magical_return ( identbodychars , has_magical_return : bool = False hook_syntax_f : Callable [ [ str ] , str ] , nums # for matching . # match_error : ParserElement = \ : param psql_args : are the command-line arguments pg4n has been called \ def get ( # TODO/BUG : removing \n 's is a tough problem , see : prompt_res = match_rev_prompt_and_then_rest.parse_string ( psql_rev ) # ParserElement for these would look this : dimensions= ( self.rows , self.cols ) ) # prompt2 per bin/psql/prompt.c : new_output : bytes = self.check_and_act_on_repl_output ( output ) ZeroOrMore ( Char ( `` \n '' ) | Char ( `` \r '' ) | White ( ) ) + \ # Reversing happens for performance reasons , self.tok_pre_port + self.tok_port assert p.parse_last_found_stmt ( case_empirical_1 ) == \ 5-tuple or None . psql_args : bytes , # feed query to hook function and save resulting message # Psql is not connecting to any database , psql._intercept ( b'\x08\x08\x08\x08 ' ) def _intercept ( # `` \r\n\x1b [ ? 2004l\r '' , `` \r\n\r\r\n '' and `` \x08\r\n '' . # If we have a semantic error message waiting def __init__ ( self , def parse_last_stmt ( self , psql : str ) - > str : # from functools import reduce assert p.parse_last_found_stmt ( case_select_then_select ) == \ # Replacing \n 's has some edge cases where wrapper transparency Word ( self.prompt_chars ) `` - * > '' , `` * * > '' , `` \ ' * > '' , `` \ '' * > '' , `` $ * > '' , `` ( * > '' , magical_return_res : ParseResults = None `` dbname= '' + self.pg_name '' , pg_host : str , assert p.parse_last_stmt ( case_multiline_query ) == \ PsqlParser ( ) ) psql.ofilter ( b'\x08\x08\x08\x08 ' ) columns : list [ Column ] = sql_parser.get_query_columns ( sanitized_sql ) return ( self.pg_host , magical_return_res = \ from .psqlparser import PsqlParser sql_query , ) line.rstrip ( ) for line in potential_future_screen.display pg_pass : str , magical_return_res : Optional [ ParseResults ] = None | Literal ( `` \r\n\r\r\n '' [ : :-1 ] ) \ analysis_result = InconsistentExpressionChecker ( # `` = > SELECT * FROM orders WHERE order_tot reduce ( lambda x , y : x + y [ : :-1 ] , results , `` '' ) ParserElement.setDefaultWhitespaceChars ( `` '' ) # % R = = , ^ assert psql.ofilter ( b'\x1b [ ? 2004htest_db= # ' ) == \ # Based on exploratory testing , screen : str = '\n'.join ( if split_prompt == [ ] : name . '' '' '' assert p.parse_last_found_stmt ( case_select_then_insert ) == \ pg_name : str if analysis_result is not None : ZeroOrMore ( White ( ) ) + tok_stmt_end + ... + \ no_newlines_res = reversed_flattened_res.replace ( '\n ' , ' ' ) columns : list [ Column ] = sql_parser.get_query_columns ( sanitized_sql ) from .psqlwrapper import PsqlWrapper import sys psql.ofilter ( b'\x08\x08\x08\x08\x08\x08 ' ) self.tok_rev_prompt_end + \ print ( bytes.decode ( psql_output.before ) ) new_output : bytes = `` '' results = prompt_res.as_list ( ) stmt_res_list = stmt_res.as_list ( ) # SUM/AVG ( DISTINCT ) import pexpect psql._intercept ( b '' \x08\x08\x08= ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m=\x1b [ 27m 100 ; \x08\x08\x08\x08\x08\x08 '' ) ... # has already been parsed as prompt_chars prompt_res = match_rev_prompt_and_then_rest.parse_string ( psql_rev ) import os Opt ( White ( ) ) ... control codes and newlines ( without carriage returns ) . from .semanticrouter import SemanticRouter def __init__ ( self , psql_args : bytes , screen : str = \ return new_output has_magical_return = True for multiline_prompt_end in self.multiline_prompt_ends : match_version_stmt : ParserElement = \ lambda x : `` '' , assert psql._intercept ( b'\x1b [ ? 2004htest_db= # ' ) == \ : returns : ( hostname , port , user , password , database name ) \ match_rev_prompt_and_then_rest : ParserElement = \ self.pg4n_message = self.analyze ( parsed_sql_query ) `` `` '' Parse for weird Return presses . res_list = prompt_res.as_list ( ) # optimization : do not spend time parsing if there is no message : # 'rev ' in variable names is shorthand for reversed . Otherwise has newline text . received in return . print ( `` Fatal error : psql connection info could not be parsed\n '' to 2 cells . psql_rev = psql [ : :-1 ] psql.ofilter ( b'\x1b [ ? 2004l\r\x1b [ ? 1049h\x1b=\r order_id | order_total_eur | customer_id \x1b [ m\r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\x1b [ m\r\n 1 | 535.36 | 111\x1b [ m\r\n 2 | 409.80 | 217\x1b [ m\r\n 3 | 189.43 | 19\x1b [ m\r\n 4 | 144.14 | 157\x1b [ m\r\n 5 | 582.52 | 172\x1b [ m\r\n 6 | 132.85 | 206\x1b [ m\r\n 7 | 183.92 | 236\x1b [ m\r\n 8 | 424.80 | 244\x1b [ m\r\n 9 | 519.43 | 175\x1b [ m\r\n 10 | 414.55 | 234\x1b [ m\r\n 11 | 88.19 | 50\x1b [ m\r\n 12 | 591.72 | 143\x1b [ m\r\n 13 | 503.52 | 216\x1b [ m\r\n 14 | 586.06 | 181\x1b [ m\r\n 15 | 47.79 | 248\x1b [ m\r\n 16 | 330.92 | 130\x1b [ m\r\n 17 | 302.31 | 225\x1b [ m\r\n 18 | 438.38 | 26\x1b [ m\r\n 19 | 107.53 | 94\x1b [ m\r\n 20 | ' analysis_result = SumDistinctChecker ( match_error_statement : ParserElement = ( version_info = pexpect.spawn ( `` `` '' psql.ofilter ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 10\x1b [ 27m0 ; \x08\x08\x08\x08\x08\x08 '' ) : param psql : screen-scraped psql output . # psqlwrapper.log ( capturing terminal stream ) in working directory return analysis_result self.pg_name ) self.tok_pre_user + self.tok_user + \ results : list [ str ] = [ ]","['src/pg4n/main.py', 'src/pg4n/psqlconninfo.py', 'src/pg4n/psqlparser.py', 'src/pg4n/psqlwrapper.py', 'src/pg4n/semanticrouter.py', 'src/pg4n/test/test_psqlparser.py', 'src/pg4n/test/test_psqlwrapper.py']",2022-09-23 11:57:31+00:00,2022-10-13 10:28:11+00:00,2022-12-12 14:47:03+02:00
17,4fa9eda88b8e6a94c4e6662a86f87da7bc41d060,8.23076261440292e-05,0,Developer wants to detect implied ( enforce by database rules ) expressions # 6 . Accessing schemas is required,Get table/database schema assertions ( for e.g detecting implied expressions ),Merge pull request # 59 from Project-C-SQL/feat/implied-expression,"insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 29 , 217.18 , 124 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 104 , 97.04 , 11 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 88 , 210.95 , 158 ) ; SqlParser , insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 1 , 535.36 , 111 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 202 , 'Sonja ' , 'Pentycross ' , ' B ' , 'Carthaette ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 172 , 15.3 , 30 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 207 , 'Elise ' , 'Kamenar ' , ' C ' , 'Caswell ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 41 , 158.78 , 145 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 12 , 'Tiffi ' , 'Riolfo ' , ' C ' , 'Ada ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 205 , 'Orlan ' , 'Kynder ' , ' C ' , 'Cassandra ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 248 , 321.97 , 195 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 242 , 356.69 , 244 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 210 , 332.45 , 47 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 79 , 94.87 , 194 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 118 , 23.96 , 195 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 1 , 'Josi ' , 'Grimsell ' , ' B ' , 'Aaron ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 68 , 73.27 , 189 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 117 , 23.13 , 46 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 155 , 274.14 , 151 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 60 , 'Sibyl ' , 'Thoms ' , ' C ' , 'Almira ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 197 , 'Missie ' , 'Fealty ' , ' C ' , 'Carol ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 42 , 561.85 , 222 ) ; parsed_sql = sql_parser.parse_one ( sql_statement ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 112 , 38.97 , 239 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 187 , 271.52 , 242 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 83 , 451.45 , 203 ) ; , PRIMARY KEY ( order_id ) import sqlglot.expressions as exp insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 27 , 'Callean ' , 'Werlock ' , ' C ' , 'Aileen ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 183 , 546.08 , 88 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 36 , 'Bendite ' , 'Morfett ' , ' B ' , 'Aleksandr ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 198 , 'Kellby ' , 'Threlfall ' , ' C ' , 'Carolann ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 201 , 411.07 , 202 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 20 , 'Robbi ' , ' O '' Caherny ' , ' B ' , 'Adelphia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 179 , 'Daphne ' , 'Kells ' , ' C ' , 'Broderick ' ) ; assert checker ! = None insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 248 , 'Norby ' , 'Biernacki ' , ' C ' , 'Clementine ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 173 , 297.4 , 85 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 166 , 95.01 , 189 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 97 , 'Germain ' , 'Haly ' , ' B ' , 'Archilles ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 96 , 'Tiertza ' , 'Bunford ' , ' C ' , 'Archibald ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 119 , 579.12 , 43 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 97 , 313.39 , 241 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 135 , 574.1 , 222 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 169 , 'Elsbeth ' , 'Nucciotti ' , ' B ' , 'Bradley ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 174 , 'Carolyn ' , 'Quinlan ' , ' C ' , 'Brian ' ) ; from pytest_postgresql import factories insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 110 , 144.28 , 59 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 80 , 17.1 , 21 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 227 , 189.25 , 230 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 198 , 120.47 , 95 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 4 , 'Nancey ' , 'Fawlkes ' , ' C ' , 'Abel ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 152 , 'Towny ' , 'Middell ' , ' B ' , 'Bert ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 56 , 'Kaitlin ' , 'Payle ' , ' B ' , 'Allyson ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 194 , 'Corilla ' , 'Aldwinckle ' , ' C ' , 'Carmellia ' ) ; import copy insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 222 , 416.65 , 59 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 223 , 200.44 , 47 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 114 , 339.9 , 108 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 2 , 'Tomlin ' , 'Nozzolinii ' , ' B ' , 'Abbigail ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 90 , 169.25 , 30 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 11 , 'Amby ' , 'Ligoe ' , ' C ' , 'Absalom ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 63 , 'Gratia ' , 'Moss ' , ' B ' , 'Althea ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 70 , 'Carmela ' , 'Sedgeworth ' , ' C ' , 'Amos ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 104 , 'Timofei ' , 'Grene ' , ' B ' , 'Armena ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 115 , 351.68 , 153 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 171 , 175.72 , 249 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 47 , 'Tracey ' , 'Sauvan ' , ' B ' , 'Alice ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 102 , 158.53 , 220 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 63 , 542.48 , 52 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 76 , 281.92 , 183 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 62 , 418.98 , 60 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 134 , 296.72 , 222 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 120 , 454.18 , 214 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 239 , 327.06 , 34 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 25 , 83.54 , 79 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 40 , 33.89 , 23 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 195 , 504.28 , 117 ) ; SELECT ( 1 , 2 , 3 ) ; '' '' '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 34 , 64.76 , 13 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 109 , 'Marquita ' , 'Impy ' , ' B ' , 'Aron ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 151 , 'Prentiss ' , 'Filby ' , ' B ' , 'Berney ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 216 , 'Elsbeth ' , 'MacGaughie ' , ' B ' , 'Charles ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 225 , 'Egbert ' , 'Vasyunin ' , ' B ' , 'Chloe ' ) ; WHERE sname > fname ; '' '' '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 241 , 296.03 , 169 ) ; Column , insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 111 , 490.85 , 191 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 69 , 'Maryjo ' , 'Pink ' , ' C ' , 'Amelia ' ) ; SQL_SIMPLE = \ insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 161 , 184.39 , 94 ) ; self._conn.commit ( ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 72 , 539.87 , 62 ) ; self.db_connection : Connection = db_connection insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 195 , 'Dewey ' , 'Bottom ' , ' C ' , 'Carmelo ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 80 , 'Petey ' , 'Colloby ' , ' B ' , 'Ann ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 222 , 'Hazel ' , 'Rushforth ' , ' C ' , 'Chester ' ) ; qep_parser_with_constraint_exclusion.parse ( self.sql_statement ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 238 , 448.86 , 16 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 53 , 'Riva ' , 'Scawen ' , ' C ' , 'Allen ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 145 , 112.51 , 162 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 58 , 'Lettie ' , 'Coffin ' , ' B ' , 'Almena ' ) ; with self._conn.cursor ( ) as cur : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 73 , 144.33 , 52 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 59 , 'Lin ' , 'Race ' , ' B ' , 'Almina ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 209 , 203.86 , 244 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 203 , 545.33 , 116 ) ; , PRIMARY KEY ( customer_id ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 127 , 451.77 , 17 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 113 , 'Dania ' , 'Foxton ' , ' C ' , 'Arthusa ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 146 , 184.13 , 22 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 170 , 539.11 , 92 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 94 , 'Halimeda ' , 'Freak ' , ' B ' , 'Arabelle ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 148 , 'Lidia ' , 'Quinane ' , ' C ' , 'Benjamin ' ) ; , nickname VARCHAR ( 20 ) NOT NULL insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 100 , 424.83 , 50 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 81 , 'Sharline ' , 'Rosenwald ' , ' B ' , 'Anna ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 213 , 329.78 , 105 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 137 , 417.16 , 215 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 231 , 'Calhoun ' , 'BoHlingolsen ' , ' C ' , 'Christina ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 31 , 394.48 , 62 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 15 , 47.79 , 248 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 167 , 'Ninnette ' , 'Steere ' , ' C ' , 'Brad ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 17 , 'Carlyle ' , 'Zimek ' , ' B ' , 'Adelbert ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 235 , 'Justus ' , 'Barthrup ' , ' B ' , 'Christy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 142 , 509.25 , 190 ) ; from .sqlparser import ( conn : Connection = psycopg.connect ( * * kwargs ) if constraint_exclusion : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 220 , 367.15 , 163 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 220 , 'Kylen ' , 'Bewicke ' , ' B ' , 'Cheryl ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 180 , 'Leonelle ' , 'Chiommienti ' , ' B ' , 'Caitlin ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 52 , 81.47 , 212 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 90 , 'Forest ' , 'Trim ' , ' B ' , 'Appoline ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 221 , 'Cassondra ' , 'Mattingson ' , ' B ' , 'Chesley ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 8 , 424.8 , 244 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 229 , 89.34 , 147 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 21 , 'Nady ' , 'Lempertz ' , ' B ' , 'Adolphus ' ) ; def test_check ( sql_parser : SqlParser , db_connection : Connection ) : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 67 , 550.21 , 63 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 103 , 'Ede ' , 'Golden of Ireland ' , ' C ' , 'Armanda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 89 , 556.68 , 74 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 162 , 168.92 , 27 ) ; CHECK ( type IN ( ' C ' , ' B ' ) ) -- C = customer , B = business from .. implied_expression_checker import ImpliedExpressionChecker insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 76 , 'Ardys ' , 'Currm ' , ' B ' , 'Andriane ' ) ; cur.execute ( insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 247 , 'Dulcie ' , 'Crutchley ' , ' B ' , 'Clement ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 163 , 61.42 , 69 ) ; SELECT * def load_database ( * * kwargs ) : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 182 , 'Sasha ' , 'Stiffkins ' , ' C ' , 'Caldonia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 49 , 'Theodosia ' , 'Rosson ' , ' B ' , 'Aline ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 55 , 'Terrill ' , 'Syde ' , ' B ' , 'Allison ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 5 , 'Callida ' , 'Tomasello ' , ' B ' , 'Abiel ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 154 , 291.52 , 54 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 191 , 'Frankie ' , 'Canny ' , ' B ' , 'Candace ' ) ; SQL_CHECK_CONSTRAINT_VIOLATION = \ self._conn.commit ( ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 10 , 'Sonnie ' , 'Kelling ' , ' B ' , 'Abram ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 68 , 'Leisha ' , 'Darlington ' , ' C ' , 'Ambrose ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 212 , 179.55 , 180 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 226 , 212.04 , 28 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 229 , 'Melessa ' , 'MacAleese ' , ' C ' , 'Christiana ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 140 , 'Suki ' , 'Flinn ' , ' B ' , 'Bea ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 88 , 'Sansone ' , 'Copsey ' , ' C ' , 'Antonia ' ) ; else : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 224 , 293.35 , 186 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 50 , 'Anne-marie ' , 'Mounsie ' , ' B ' , 'Alison ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 204 , 'Cassy ' , 'Pearcehouse ' , ' C ' , 'Casper ' ) ; load= [ load_database ] , insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 188 , 'Ferguson ' , 'Mackriell ' , ' B ' , 'Cameron ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 48 , 'Marve ' , 'Eykel ' , ' C ' , 'Alicia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 208 , 'Legra ' , 'Drought ' , ' C ' , 'Catherine ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 249 , 'Rhoda ' , 'Leheude ' , ' C ' , 'Cliff ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 77 , 'Maegan ' , 'Wheldon ' , ' C ' , 'Angela ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 181 , 'Daria ' , 'Wistance ' , ' C ' , 'Caitlyn ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 156 , 'Allistir ' , 'Frary ' , ' C ' , 'Beth ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 72 , 'Nadiya ' , 'Gingles ' , ' B ' , 'Anderson ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 7 , 183.92 , 236 ) ; has_onetime_filter_with_constraint_exclusion and \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 7 , 'Lorin ' , 'Dollimore ' , ' C ' , 'Abijah ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 79 , 'Preston ' , 'Groves ' , ' B ' , 'Angelina ' ) ; QEPAnalysis , insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 144 , 504.73 , 154 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 219 , 594.84 , 121 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 141 , 183.27 , 44 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 217 , 'Lucy ' , 'Durtnell ' , ' C ' , 'Charlie ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 140 , 297.41 , 101 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 215 , 'Nollie ' , 'Jemmett ' , ' B ' , 'Charity ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 85 , 404.96 , 79 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 27 , 137.86 , 21 ) ; return node.get ( `` One-Time Filter '' ) ! = None insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 240 , 384.87 , 107 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 115 , 'Shirl ' , 'Pilpovic ' , ' C ' , 'Asahel ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 96 , 311.78 , 173 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 206 , 226.62 , 228 ) ; Returns warning_msg if implied expression is detected , otherwise None . insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 155 , 'Murdock ' , 'Dix ' , ' C ' , 'Bess ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 38 , 366.31 , 59 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 19 , 107.53 , 94 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 138 , 'Ainsley ' , 'Wraighte ' , ' C ' , 'Barticus ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 176 , 'Marylou ' , 'Guilloton ' , ' C ' , 'Bridget ' ) ; sql_statement = SQL_SIMPLE insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 233 , 87.21 , 179 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 177 , 334.0 , 167 ) ; CREATE TABLE { ORDERS_TABLE_NAME } ( parsed_sql , sql_statement , db_connection ) f '' '' '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 178 , 563.08 , 161 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 30 , 'Colin ' , 'Jansie ' , ' C ' , 'Alastair ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 160 , 144.6 , 82 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 153 , 'Alfy ' , 'McCahill ' , ' B ' , 'Bertha ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 124 , 552.02 , 191 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 114 , 'Fara ' , 'Arkil ' , ' B ' , 'Arzada ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 206 , 'Ardyth ' , 'Conningham ' , ' B ' , 'Cassidy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 108 , 294.25 , 131 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 46 , 362.72 , 240 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 29 , 'Dawna ' , 'Knipe ' , ' C ' , 'Alanson ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 111 , 'Torey ' , 'Sessuns ' , ' B ' , 'Artemus ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 2 , 409.8 , 217 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 112 , 'Nanci ' , 'Byrd ' , ' C ' , 'Arthur ' ) ; ORDERS_TABLE_NAME = `` implied_expression_test_table_orders '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 126 , 384.61 , 226 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 182 , 478.47 , 70 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 81 , 490.65 , 41 ) ; cur.execute ( `` set constraint_exclusion = on ; '' ) QEPNode , SQL_NO_IMPLIED_EXPRESSION = \ insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 197 , 529.63 , 46 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 232 , 'Maritsa ' , 'Cowpland ' , ' C ' , 'Christine ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 230 , 'Cordell ' , 'Bineham ' , ' B ' , 'Christiano ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 168 , 137.02 , 109 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 11 , 88.19 , 50 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 130 , 'Rora ' , 'Adcock ' , ' C ' , 'Babs ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 122 , 'Myrlene ' , 'Worcs ' , ' B ' , 'Augusta ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 217 , 302.24 , 189 ) ; db_connection : Connection ) : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 151 , 221.16 , 212 ) ; CREATE TABLE { CUSTOMERS_TABLE_NAME } ( insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 60 , 473.05 , 208 ) ; warning_msg = checker.check ( ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 23 , 236.48 , 51 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 200 , 'Fanni ' , 'Iacopetti ' , ' C ' , 'Carolyn ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 250 , 367.56 , 214 ) ; '' '' '' ) qep_parser_without_constraint_exclusion.parse ( self.sql_statement ) def __init__ ( self , parsed_sql : exp.Expression , sql_statement : str , checker = ImpliedExpressionChecker ( insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 235 , 230.72 , 168 ) ; sql_statement = SQL_NO_IMPLIED_EXPRESSION insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 185 , 'Tanitansy ' , 'Headington ' , ' C ' , 'Calista ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 53 , 592.15 , 207 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 211 , 399.2 , 138 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 131 , 'Ive ' , 'Matches ' , ' B ' , 'Barbara ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 26 , 'Jenica ' , 'Martina ' , ' C ' , 'Agnes ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 202 , 99.52 , 171 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 3 , 189.43 , 19 ) ; import psycopg insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 211 , 'Jobi ' , 'Bails ' , ' B ' , 'Cecilia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 226 , 'Emelina ' , 'Ayliff ' , ' B ' , 'Chris ' ) ; warning_msg = `` Warning : Found impossible comparison due to column/table constraints [ pg4n : :ImpliedExpression ] '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 121 , 'Clywd ' , 'Stokey ' , ' B ' , 'August ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 107 , 'Celisse ' , 'Rubra ' , ' B ' , 'Arminta ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 149 , 'Erik ' , 'Cushe ' , ' B ' , 'Benjy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 44 , 537.56 , 2 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 239 , 'Atalanta ' , 'Girdler ' , ' C ' , 'Claire ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 56 , 501.06 , 129 ) ; , customer_id INT NOT NULL insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 31 , 'Dario ' , 'Siehard ' , ' C ' , 'Alazama ' ) ; from .qepparser import ( , FOREIGN KEY ( customer_id ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 61 , 343.91 , 223 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 42 , 'Pyotr ' , 'Feldhorn ' , ' C ' , 'Alexis ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 203 , 'Rory ' , 'Hallatt ' , ' C ' , 'Casey ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 228 , 'Rudd ' , 'Ames ' , ' B ' , 'Christian ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 61 , 'Blisse ' , 'Dillway ' , ' C ' , 'Alonzo ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 164 , 'Abel ' , 'Bezants ' , ' C ' , 'Bob ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 65 , 318.64 , 6 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 136 , 'Aretha ' , 'Arias ' , ' C ' , 'Bart ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 152 , 291.54 , 10 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 69 , 266.3 , 39 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 196 , 'Louisa ' , 'Matasov ' , ' B ' , 'Carmon ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 160 , 'Patti ' , 'Louis ' , ' C ' , 'Biddie ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 48 , 199.52 , 234 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 236 , 485.18 , 167 ) ; has_onetime_filter_without_constraint_exclusion = \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 214 , 'Chalmers ' , 'Britton ' , ' C ' , 'Celinda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 189 , 164.91 , 68 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 210 , 'Pamelina ' , 'Vittery ' , ' C ' , 'Cathy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 101 , 328.66 , 189 ) ; , fname VARCHAR ( 50 ) NOT NULL insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 62 , 'Seline ' , 'McGray ' , ' B ' , 'Alphinias ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 65 , 'Glenna ' , 'Alastair ' , ' C ' , 'Alyssa ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 75 , 'Erma ' , 'Cranstone ' , ' B ' , 'Andrew ' ) ; sql_statement = SQL_CHECK_CONSTRAINT_VIOLATION insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 231 , 51.77 , 118 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 129 , 426.3 , 136 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 66 , 'Sadella ' , 'Boxhall ' , ' B ' , 'Alzada ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 37 , 'Talbot ' , 'Keddey ' , ' B ' , 'Aleva ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 98 , 177.22 , 86 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 122 , 406.1 , 80 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 204 , 212.04 , 203 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 227 , 'Jeralee ' , 'Atwill ' , ' C ' , 'Christa ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 221 , 487.39 , 227 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 186 , 'Chloette ' , 'Ratt ' , ' B ' , 'Calpurnia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 209 , 'Dulcea ' , 'Akister ' , ' C ' , 'Cathleen ' ) ; def db_connection ( postgresql : Connection ) : from typing import Optional insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 4 , 144.14 , 157 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 71 , 175.29 , 115 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 218 , 389.51 , 177 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 183 , 'Harvey ' , 'Skinn ' , ' B ' , 'Caleb ' ) ; postgresql = factories.postgresql ( `` factory '' ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 119 , 'Gregg ' , 'Lazenbury ' , ' B ' , 'Aubrey ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 18 , 'Odie ' , 'Rowling ' , ' C ' , 'Adele ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 236 , 'Garnette ' , 'Tabrett ' , ' C ' , 'Cicely ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 146 , 'Dunstan ' , 'Cressey ' , ' B ' , 'Bella ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 118 , 'Hermy ' , 'Whieldon ' , ' B ' , 'Ashley ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 237 , 293.23 , 140 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 224 , 'Dayle ' , 'Eirwin ' , ' B ' , 'Chick ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 199 , 376.5 , 53 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 28 , 87.44 , 1 ) ; len ( qep_analysis_with_constraint_exclusion.root.rfind ( finder ) ) > 0 insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 106 , 236.57 , 4 ) ; def __init__ ( self , * args , conn=None , constraint_exclusion=True , * * kwargs ) : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 16 , 330.92 , 130 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 131 , 255.66 , 127 ) ; return postgresql with conn.cursor ( ) as cur : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 93 , 'Sashenka ' , 'Fedorski ' , ' C ' , 'Arabella ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 103 , 14.83 , 183 ) ; QEPParser ( conn=self.db_connection , constraint_exclusion=False ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 232 , 330.85 , 204 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 94 , 406.59 , 129 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 161 , 'Barron ' , 'Dishmon ' , ' B ' , 'Bill ' ) ; return None insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 10 , 414.55 , 234 ) ; WHERE sname IS NULL ; '' '' '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 200 , 592.16 , 137 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 71 , 'Cynthie ' , 'Rouby ' , ' B ' , 'Anastasia ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 249 , 491.05 , 63 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 116 , 'Annmarie ' , 'Errichelli ' , ' B ' , 'Asaph ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 143 , 239.98 , 109 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 244 , 273.35 , 153 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 194 , 328.76 , 41 ) ; return warning_msg insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 245 , 327.9 , 212 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 133 , 499.73 , 235 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 142 , 'Elfrieda ' , 'Cleary ' , ' C ' , 'Becca ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 64 , 'Dyan ' , 'Crosbie ' , ' B ' , 'Alverta ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 67 , 'Zsazsa ' , 'Bellocht ' , ' C ' , 'Amanda ' ) ; cur.execute ( `` set constraint_exclusion = on ; '' ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 201 , 'Arv ' , 'Spawforth ' , ' B ' , 'Carrie ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 134 , 'Georgetta ' , 'Crossley ' , ' B ' , 'Barnabas ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 101 , 'Hamilton ' , 'Pellew ' , ' B ' , 'Arizona ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 243 , 209.34 , 31 ) ; DROP TABLE IF EXISTS { CUSTOMERS_TABLE_NAME } ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 123 , 'Lyon ' , 'Nolleau ' , ' C ' , 'Augustina ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 43 , 'Belle ' , 'Barsham ' , ' B ' , 'Alfonse ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 205 , 508.59 , 59 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 17 , 302.31 , 225 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 99 , 354.37 , 66 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 176 , 22.8 , 175 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 3 , 'Christen ' , 'Culley ' , ' C ' , 'Abednego ' ) ; , type CHAR ( 1 ) NOT NULL insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 141 , 'Jacinta ' , 'Villiers ' , ' B ' , 'Beatrice ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 167 , 547.07 , 197 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 159 , 281.36 , 198 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 102 , 'Ricca ' , 'Rupprecht ' , ' B ' , 'Arlene ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 175 , 'Davy ' , 'Blomefield ' , ' B ' , 'Brianna ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 120 , 'Corinna ' , 'Pyburn ' , ' B ' , 'Audrey ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 162 , 'Jessee ' , 'List ' , ' B ' , 'Billy ' ) ; assert warning_msg == None insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 157 , 477.53 , 205 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 52 , 'Gerrilee ' , 'Ackland ' , ' B ' , 'Allan ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 126 , 'Lilllie ' , 'Annis ' , ' C ' , 'Aurelia ' ) ; def sql_parser ( postgresql : Connection ) : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 109 , 170.82 , 206 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 24 , 'Jacinthe ' , 'Kleeman ' , ' B ' , 'Adrienne ' ) ; f '' '' '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 91 , 'Bobby ' , 'Fortesquieu ' , ' B ' , 'Aquilla ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 38 , 'Web ' , 'Catterill ' , ' B ' , 'Alex ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 51 , 244.27 , 119 ) ; cur.execute ( `` set constraint_exclusion = off ; '' ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 75 , 238.65 , 203 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 184 , 'Louise ' , 'Jansey ' , ' C ' , 'California ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 54 , 'Malchy ' , 'Hearty ' , ' B ' , 'Allisandra ' ) ; WHERE type = ' A ' ; '' '' '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 208 , 344.91 , 150 ) ; ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 137 , 'Lucilia ' , 'Bentick ' , ' C ' , 'Bartholomew ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 25 , 'Neely ' , 'Merrydew ' , ' B ' , 'Agatha ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 41 , 'Reilly ' , 'Kennler ' , ' B ' , 'Alexandria ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 93 , 452.63 , 115 ) ; qep_parser_without_constraint_exclusion = \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 240 , 'Britte ' , 'Muge ' , ' B ' , 'Clara ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 121 , 132.25 , 50 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 230 , 389.39 , 247 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 154 , 'Conney ' , 'Riteley ' , ' C ' , 'Bertram ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 132 , 'Olympe ' , 'Faber ' , ' B ' , 'Barbery ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 241 , 'Sigismund ' , 'Mowsdill ' , ' B ' , 'Clare ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 106 , 'Merrily ' , 'Coundley ' , ' C ' , 'Arminda ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 242 , 'Brenden ' , 'Simmons ' , ' B ' , 'Clarence ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 218 , 'Raffarty ' , 'Sweeney ' , ' C ' , 'Charlotte ' ) ; return SqlParser ( db_connection=postgresql ) CUSTOMERS_TABLE_NAME = `` implied_expression_orderby_test_table_customers '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 173 , 'Kristopher ' , 'Mackelworth ' , ' B ' , 'Brenda ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 187 , 'Donall ' , 'Casolla ' , ' B ' , 'Calvin ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 107 , 23.63 , 179 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 186 , 561.85 , 156 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 172 , 'Pammi ' , 'Codling ' , ' B ' , 'Breeanna ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 14 , 586.06 , 181 ) ; qep_analysis_with_constraint_exclusion = \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 83 , 'Wolf ' , 'Brenton ' , ' B ' , 'Annette ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 98 , 'Elfreda ' , 'Tome ' , ' C ' , 'Ariadne ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 223 , 'Annice ' , 'Haynes ' , ' B ' , 'Chet ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 147 , 180.39 , 2 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 57 , 349.14 , 58 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 129 , 'Ashla ' , 'De-Ville ' , ' C ' , 'Bab ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 45 , 46.05 , 177 ) ; len ( qep_analysis_without_constraint_exclusion.root.rfind ( finder ) ) > 0 SQL_NOT_NULL_CONSTRAINT_VIOLATION = \ qep_analysis_without_constraint_exclusion = \ , sname VARCHAR ( 50 ) NOT NULL insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 78 , 'Matilde ' , 'Froome ' , ' B ' , 'Angelica ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 212 , 'Annecorinne ' , 'Soles ' , ' B ' , 'Cedric ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 87 , 441.16 , 191 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 145 , 'Adena ' , 'Wenham ' , ' C ' , 'Belinda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 91 , 331.76 , 115 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 84 , 396.02 , 111 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 138 , 223.81 , 183 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 139 , 'Kelsi ' , 'Suddell ' , ' C ' , 'Bazaleel ' ) ; if not has_implied_expression : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 54 , 591.44 , 145 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 33 , 'Amble ' , 'Jewes ' , ' B ' , 'Alberta ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 117 , 'Marysa ' , 'Wadman ' , ' C ' , 'Asenath ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 32 , 331.93 , 144 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 234 , 'Cayla ' , 'Statter ' , ' B ' , 'Christopher ' ) ; QEPParser , def finder ( node : QEPNode ) - > bool : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 123 , 370.87 , 115 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 165 , 84.61 , 1 ) ; QEPParser ( conn=self.db_connection , constraint_exclusion=True ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 39 , 42.62 , 95 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 188 , 495.68 , 39 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 215 , 515.79 , 96 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 192 , 'Dudley ' , 'Vesco ' , ' B ' , 'Carlotta ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 13 , 'Marion ' , 'Penelli ' , ' B ' , 'Adaline ' ) ; ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 105 , 107.29 , 12 ) ; `` One-Time Filter '' : str , insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 125 , 'Leo ' , 'Creaney ' , ' B ' , 'Augustus ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 18 , 438.38 , 26 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 247 , 123.55 , 179 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 163 , 'Gerhardt ' , 'Simcock ' , ' B ' , 'Blanche ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 30 , 435.57 , 105 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 214 , 520.52 , 98 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 150 , 'Agnesse ' , 'Liebmann ' , ' B ' , 'Bernard ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 33 , 140.92 , 236 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 21 , 471.12 , 179 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 28 , 'Nanice ' , 'MacMaster ' , ' B ' , 'Alan ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 144 , 'Ange ' , 'Pasterfield ' , ' C ' , 'Bedelia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 95 , 'Amandie ' , 'Botham ' , ' B ' , 'Araminta ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 128 , 415.86 , 243 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 159 , 'Carilyn ' , 'Vinecombe ' , ' B ' , 'Bezaleel ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 193 , 449.91 , 213 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 191 , 183.55 , 142 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 113 , 305.06 , 123 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 6 , 'Daisey ' , 'Hamill ' , ' B ' , 'Abigail ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 87 , 'Nanette ' , 'McElwee ' , ' B ' , 'Antoinette ' ) ; DROP TABLE IF EXISTS { ORDERS_TABLE_NAME } ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 238 , 'Gregor ' , 'Crinion ' , ' B ' , 'Cindy ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 110 , 'Donall ' , 'Labrenz ' , ' B ' , 'Artelepsa ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 12 , 591.72 , 143 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 174 , 597.34 , 184 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 136 , 411.87 , 10 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 99 , 'Phineas ' , 'Yuryaev ' , ' B ' , 'Arielle ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 179 , 453.95 , 43 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 14 , 'Davon ' , 'Burris ' , ' C ' , 'Addison ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 130 , 575.58 , 235 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 193 , 'Brucie ' , 'Coning ' , ' C ' , 'Carlton ' ) ; sql_statement = SQL_NOT_NULL_CONSTRAINT_VIOLATION FROM { CUSTOMERS_TABLE_NAME } self.sql_statement : str = sql_statement insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 58 , 10.24 , 74 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 156 , 130.63 , 188 ) ; with self._conn.cursor ( ) as cur : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 9 , 'Lester ' , 'Markus ' , ' C ' , 'Abraham ' ) ; class ImpliedExpressionChecker : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 150 , 439.75 , 18 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 250 , 'Langston ' , 'Prosser ' , ' C ' , 'Clifford ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 77 , 335.23 , 149 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 125 , 170.66 , 131 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 149 , 340.62 , 215 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 177 , 'Genvieve ' , 'Marthen ' , ' B ' , 'Brittany ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 23 , 'Jeanette ' , 'Fincher ' , ' B ' , 'Adriane ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 20 , 207.6 , 9 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 92 , 156.72 , 192 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 24 , 538.88 , 38 ) ; customer_id INT insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 233 , 'Tibold ' , 'Sleigh ' , ' C ' , 'Christoph ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 153 , 350.78 , 247 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 171 , 'Fredrick ' , 'Matuszynski ' , ' C ' , 'Breanna ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 127 , 'Rhoda ' , 'Kurton ' , ' C ' , 'Avarilla ' ) ; from .. sqlparser import SqlParser not has_onetime_filter_without_constraint_exclusion assert warning_msg ! = None insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 148 , 203.36 , 180 ) ; factory = factories.postgresql_proc ( insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 189 , 'Merle ' , 'Erridge ' , ' C ' , 'Camille ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 57 , 'Vita ' , 'Dunnett ' , ' B ' , 'Allyssa ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 181 , 150.37 , 69 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 243 , 'Hannah ' , 'Mattheis ' , ' C ' , 'Clarinda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 139 , 441.16 , 97 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 9 , 519.43 , 175 ) ; self.parsed_sql : exp.Expression = parsed_sql order_id INT insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 132 , 488.95 , 234 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 199 , 'Matilda ' , 'Malenoir ' , ' C ' , 'Caroline ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 44 , 'Buffy ' , ' O '' Cridigan ' , ' B ' , 'Alfred ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 225 , 26.43 , 228 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 185 , 505.7 , 49 ) ; conn.commit ( ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 108 , 'Janene ' , 'Motten ' , ' C ' , 'Arnold ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 178 , 'Rogers ' , 'Plose ' , ' B ' , 'Brittney ' ) ; def __init__ ( self , * args , conn=None , * * kwargs ) : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 5 , 582.52 , 172 ) ; print ( warning_msg ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 175 , 161.61 , 58 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 45 , 'Seymour ' , 'Mayer ' , ' B ' , 'Alfreda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 158 , 65.82 , 201 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 135 , 'Janenna ' , 'McCamish ' , ' C ' , 'Barney ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 47 , 163.79 , 141 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 37 , 322.11 , 41 ) ; has_onetime_filter_with_constraint_exclusion = \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 168 , 'Melicent ' , 'Cheston ' , ' B ' , 'Bradford ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 35 , 389.81 , 218 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 43 , 133.73 , 196 ) ; import pytest insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 180 , 452.67 , 234 ) ; from psycopg import Connection insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 92 , 'Raven ' , 'Eilles ' , ' C ' , 'Ara ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 234 , 254.56 , 98 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 190 , 'Kara ' , 'Backs ' , ' B ' , 'Campbell ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 124 , 'Penelope ' , 'Quadling ' , ' C ' , 'Augustine ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 237 , 'Jeramie ' , 'Gallehock ' , ' C ' , 'Cinderella ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 184 , 380.46 , 98 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 19 , 'Daphne ' , 'Bullen ' , ' B ' , 'Adeline ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 147 , 'Wilmer ' , 'MacWhan ' , ' B ' , 'Benedict ' ) ; REFERENCES { CUSTOMERS_TABLE_NAME } ( customer_id ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 219 , 'Adriane ' , 'Ccomini ' , ' B ' , 'Chauncey ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 244 , 'Katrine ' , 'Janiak ' , ' B ' , 'Clarissa ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 133 , 'Clementia ' , 'Fergusson ' , ' B ' , 'Barbie ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 46 , 'Mechelle ' , 'Vinick ' , ' B ' , 'Algernon ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 246 , 'Albert ' , 'Heimann ' , ' B ' , 'Cleatus ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 213 , 'Rubin ' , 'Lunney ' , ' B ' , 'Celeste ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 32 , 'Aubrie ' , 'Lockitt ' , ' C ' , 'Albert ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 22 , 193.12 , 6 ) ; qep_parser_with_constraint_exclusion = \ insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 95 , 367.31 , 48 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 59 , 141.8 , 118 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 39 , 'Tabbie ' , 'Glison ' , ' B ' , 'Alexander ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 216 , 388.15 , 142 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 86 , 537.64 , 201 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 26 , 590.52 , 50 ) ; SELECT customer_id , fname , sname insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 70 , 596.2 , 221 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 128 , 'Jere ' , 'Cometti ' , ' B ' , 'Azariah ' ) ; def check ( self ) - > Optional [ str ] : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 64 , 534.3 , 108 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 165 , 'Angele ' , 'Wildbore ' , ' C ' , 'Bobby ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 16 , 'Augustin ' , 'Blaxall ' , ' C ' , 'Adelaide ' ) ; , order_total_eur DECIMAL ( 6,2 ) NOT NULL insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 34 , 'Lorens ' , 'Buzin ' , ' C ' , 'Aldo ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 13 , 503.52 , 216 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 49 , 376.9 , 89 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 192 , 206.39 , 151 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 22 , 'Grazia ' , 'Syne ' , ' C ' , 'Adrian ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 74 , 'Giffy ' , 'Cottee ' , ' C ' , 'Andrea ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 164 , 193.39 , 169 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 6 , 132.85 , 206 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 116 , 292.86 , 97 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 86 , 'Lauren ' , 'Tolworth ' , ' B ' , 'Anthony ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 50 , 306.71 , 235 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 166 , 'Angelo ' , 'Vanstone ' , ' C ' , 'Boetius ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 35 , 'Lainey ' , 'Davidow ' , ' C ' , 'Aldrich ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 143 , 'Sasha ' , 'Eunson ' , ' C ' , 'Beck ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 100 , 'Gypsy ' , 'Bottrell ' , ' C ' , 'Aristotle ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 74 , 63.02 , 117 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 73 , 'Seymour ' , 'Maffioletti ' , ' B ' , 'Andre ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 170 , 'Bard ' , 'Shaw ' , ' C ' , 'Brady ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 84 , 'Birk ' , 'Malling ' , ' C ' , 'Annie ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 89 , 'Nickie ' , 'Bloss ' , ' C ' , 'Antonio ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 36 , 225.6 , 136 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 190 , 401.19 , 88 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 85 , 'Brig ' , 'Triswell ' , ' C ' , 'Anselm ' ) ; has_implied_expression = \ insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 246 , 510.74 , 188 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 245 , 'Holly ' , 'Roy ' , ' C ' , 'Claudia ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 228 , 542.3 , 42 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 15 , 'Zachary ' , 'Faloon ' , ' C ' , 'Adela ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 158 , 'Anett ' , 'Hercules ' , ' B ' , 'Beverly ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 8 , 'Gasparo ' , 'Bohlje ' , ' C ' , 'Abner ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 169 , 552.88 , 241 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 207 , 205.25 , 199 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 105 , 'Cary ' , 'Sells ' , ' C ' , 'Armilda ' ) ; `` `` '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 51 , 'Kennan ' , 'Burstowe ' , ' B ' , 'Alixandra ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 78 , 569.4 , 99 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 196 , 259.0 , 244 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 82 , 106.39 , 237 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 157 , 'Noach ' , 'MacRitchie ' , ' C ' , 'Bethena ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 82 , 'Abey ' , 'Darridon ' , ' C ' , 'Anne ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 66 , 454.41 , 11 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 55 , 391.93 , 128 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 40 , 'Olva ' , 'Leborgne ' , ' C ' , 'Alexandra ' ) ;","['src/pg4n/implied_expression_checker.py', 'src/pg4n/qepparser.py', 'src/pg4n/test/test_implied_expression_checker.py']",2022-09-29 09:50:51+00:00,2022-11-08 08:09:34+00:00,2022-11-08 10:09:32+02:00
19,6c5e663747462817aa670b59addb191b618c5eb9,0.0001145571950473,0,Design required classes and interfaces according to SOLID principles and potentially GoF design patterns . Document them in wiki .,Document architecture and interfaces for QEP parser,Merge pull request # 29 from Project-C-SQL/feat/qep-parser,"return QEPNode ( self._qep [ `` Plan '' ] ) assert qep.root [ 0 ] .plan [ `` Node Type '' ] == `` Index Scan '' assert qep.plan [ `` Alias '' ] == `` stories '' load= [ load_database ] , class QEPAnalysis : def __call__ ( self , stmt : str , * args , * * kwargs ) - > QEPAnalysis : if ( n : = len ( res [ 0 ] [ 0 ] ) ) ! = 1 : drop table if exists users ; with conn.cursor ( ) as cur : `` `` '' The root node of the query execution plan . '' '' '' if ( n : = len ( res ) ) ! = 1 : # TODO : break into variants discriminated by Node Type def qep ( self ) - > qep : def find ( self , pred : Callable [ [ node ] , bool ] ) - > list [ node ] : `` `` '' A node in a query execution plan . '' '' '' qep = parser ( `` select * from stories '' ) `` Actual Startup Time '' : float , import qepparser self._ref = not not conn qep = parser ( `` select * from users where id = 1 '' ) story_id integer references stories ( id ) on delete cascade , return self._node.__repr__ ( ) password=getenv ( `` POSTGRES_PASSWORD '' , `` postgres '' ) ) `` Actual Total Time '' : float , self._conn : connection = conn or psycopg2.connect ( * args , * * kwargs ) qep = parser ( `` select * from users '' ) stmt : The query to execute . `` `` '' Performs analyses on given queries , returning resultant QEPAnalysis . '' '' '' qep = parser ( `` select * from stories where id = 1 '' ) return map ( QEPNode , self._node [ `` Plans '' ] ) } ) self._conn.rollback ( ) `` Index Cond '' : str , qep = parser ( `` select * from comments '' ) def __iter__ ( self ) - > Iterable [ `` QEPNode '' ] : return self._qep.__repr__ ( ) import psycopg2 `` `` '' A dict of the node 's properties . '' '' '' insert into users ( name ) values ( 'user1 ' ) ; def __len__ ( self ) - > int : return list ( filter ( pred , self._node [ `` Plans '' ] ) ) insert into stories ( name ) values ( 'story2 ' ) ; postgresql_in_docker = factories.postgresql_noproc ( `` Plan Width '' : int , `` Actual Loops '' : int , insert into users ( name ) values ( 'user2 ' ) ; from typing import Callable , Iterable , List , TypedDict assert qep.plan [ `` Actual Rows '' ] == 1 def __init__ ( self , * args , conn=None , * * kwargs ) : return self._node create table stories ( id serial primary key , name varchar ) ; `` `` '' Get the child node at the given index . '' '' '' return self._qep [ `` Plan '' ] `` `` '' Represents the result of EXPLAIN ANALYZE . '' '' '' return QEPNode ( self._node [ `` Plans '' ] [ key ] ) comment varchar ) ; from pytest_postgresql import factories return self._qep `` Actual Rows '' : int , def __del__ ( self ) : from os import getenv `` Scan Direction '' : str , `` Total Runtime '' : float , `` `` '' Test that the QEP structure is as expected . '' '' '' return QEPAnalysis ( res [ 0 ] [ 0 ] [ 0 ] ) A dictionary representing the query execution plan . insert into comments ( story_id , user_id , comment ) values ( 1 , 1 , 'comment1 ' ) ; postgresql = factories.postgresql ( `` postgresql_in_docker '' ) drop table if exists comments ; `` Plan Rows '' : int , def plan ( self ) - > node : qep = parser ( `` select * from stories where id = 1 or id = 2 '' ) Parameters : assert qep.root [ 0 ] .plan [ `` Relation Name '' ] == `` users '' qep = parser ( `` select * from comments where id = 1 and id = 2 '' ) conn.commit ( ) assert qep.root [ 0 ] .plan [ `` Relation Name '' ] == `` stories '' raise ValueError ( f '' Expected dict in column , got { t } '' ) self._qep = qep_ qep = parser ( `` select * from comments where id = 1 '' ) demonstrates relational data assert qep.root [ 0 ] .plan [ `` Alias '' ] == `` users '' `` Plans '' : List [ `` node '' ] , insert into comments ( story_id , user_id , comment ) values ( 2 , 2 , 'comment4 ' ) ; def __getitem__ ( self , key : int ) - > `` QEPNode '' : `` `` '' A dict of the root node 's properties . '' '' '' `` `` '' Iterate over child nodes . '' '' '' assert qep.plan [ `` Node Type '' ] == `` Index Scan '' # are available for each node type `` Filter '' : str , assert qep.root [ 0 ] .plan [ `` Actual Rows '' ] == 0 assert qep.plan [ `` Alias '' ] == `` users '' def __init__ ( self , node_ : node ) : assert qep.plan [ `` Relation Name '' ] == `` users '' return self ( stmt , * args , * * kwargs ) def test_qep_structure ( parser : qepparser.QEPParser ) : return len ( self._node [ `` Plans '' ] ) * * kwargs : Keyword arguments to pass to cursor.execute ( ) . return self._node [ `` Plans '' ] class QEPNode : assert qep.plan [ `` Relation Name '' ] == `` comments '' import pytest `` Triggers '' : list [ str ] , `` Execution Time '' : float , node = TypedDict ( `` Plan '' , { assert qep.plan [ `` Node Type '' ] == `` Result '' insert into comments ( story_id , user_id , comment ) values ( 1 , 2 , 'comment2 ' ) ; user_id integer references users ( id ) on delete cascade , def parser ( postgresql : connection ) : assert qep.root [ 0 ] .plan [ `` Alias '' ] == `` stories '' create table comments ( assert qep.plan [ `` Node Type '' ] == `` Seq Scan '' qep = parser ( `` select * from users where id = 1 and id = 2 '' ) def __str__ ( self ) : assert qep.plan [ `` Relation Name '' ] == `` stories '' raise ValueError ( f '' Expected 1 column , got { n } '' ) self._node = node_ def plans ( self ) - > list [ node ] : populate with sample data Returns : stmt = f '' explain ( format json , analyze , verbose ) { stmt.strip ( ) .rstrip ( ' ; ' ) } ; '' `` Planning Time '' : float , user=getenv ( `` POSTGRES_USER '' , `` postgres '' ) , Executes a query and returns the query execution plan as a dictionary . `` `` '' A list of the node 's children . '' '' '' `` Node Type '' : str , # right now , the interface is n't safe to use because it 's not clear what fields drop table if exists stories ; `` `` '' ) self._conn.close ( ) raise ValueError ( f '' Expected 1 item in column , got { n } '' ) def root ( self ) - > QEPNode : for copy-and-pasting insert into stories ( name ) values ( 'story1 ' ) ; conn : connection = psycopg2.connect ( * * kwargs ) `` Relation Name '' : str , id serial primary key , `` `` '' Get the number of child nodes . '' '' '' assert qep.root [ 0 ] .plan [ `` Relation Name '' ] == `` comments '' `` Parent Relationship '' : str , return self._node.__str__ ( ) res = cur.fetchall ( ) qep = parser ( `` select * from users where id = 1 or id = 2 '' ) with self._conn.cursor ( ) as cur : from psycopg2.extensions import connection `` Index Name '' : str , `` `` '' A dict of the query execution plan 's properties . '' '' '' `` Plan '' : node , cur.execute ( stmt , * args , * * kwargs ) cur.execute ( `` '' '' `` Total Cost '' : float , if ( n : = len ( res [ 0 ] ) ) ! = 1 : `` `` '' Find nodes matching the predicate . '' '' '' raise ValueError ( f '' Expected 1 row , got { n } '' ) assert qep.plan [ `` Actual Rows '' ] == 2 if ( t : = type ( res [ 0 ] [ 0 ] [ 0 ] ) ) ! = dict : `` Alias '' : str , '' 'Alias for __call__ '' ' def __repr__ ( self ) : def __init__ ( self , qep_ : qep ) : if not self._ref : assert qep.plan [ `` Node Type '' ] == `` Bitmap Heap Scan '' qep = TypedDict ( `` QEP '' , { def load_database ( * * kwargs ) : assert qep.root [ 0 ] .plan [ `` Alias '' ] == `` comments '' assert qep.plan [ `` Actual Rows '' ] == 4 * text=auto qep = parser ( `` select * from stories where id = 1 and id = 2 '' ) * args : Positional arguments to pass to cursor.execute ( ) . return qepparser.QEPParser ( conn=postgresql ) create table users ( id serial primary key , name varchar ) ; assert qep.plan [ `` Alias '' ] == `` comments '' def parse ( self , stmt : str , * args , * * kwargs ) - > QEPAnalysis : return self._qep.__str__ ( ) `` Startup Cost '' : float , `` `` '' class QEPParser : insert into comments ( story_id , user_id , comment ) values ( 2 , 1 , 'comment3 ' ) ;","['.gitattributes', 'qepparser.py', 'test_qepparser.py']",2022-09-29 09:56:52+00:00,2022-11-10 10:38:31+00:00,2022-10-11 17:32:29+03:00
22,6c5e663747462817aa670b59addb191b618c5eb9,0.0581310950219631,0,See # 10 Look into psql output given ` explain analyze ` with potential machine-readable formatting options .,Analyze QEP format,Merge pull request # 29 from Project-C-SQL/feat/qep-parser,"return QEPNode ( self._qep [ `` Plan '' ] ) assert qep.root [ 0 ] .plan [ `` Node Type '' ] == `` Index Scan '' assert qep.plan [ `` Alias '' ] == `` stories '' load= [ load_database ] , class QEPAnalysis : def __call__ ( self , stmt : str , * args , * * kwargs ) - > QEPAnalysis : if ( n : = len ( res [ 0 ] [ 0 ] ) ) ! = 1 : drop table if exists users ; with conn.cursor ( ) as cur : `` `` '' The root node of the query execution plan . '' '' '' if ( n : = len ( res ) ) ! = 1 : # TODO : break into variants discriminated by Node Type def qep ( self ) - > qep : def find ( self , pred : Callable [ [ node ] , bool ] ) - > list [ node ] : `` `` '' A node in a query execution plan . '' '' '' qep = parser ( `` select * from stories '' ) `` Actual Startup Time '' : float , import qepparser self._ref = not not conn qep = parser ( `` select * from users where id = 1 '' ) story_id integer references stories ( id ) on delete cascade , return self._node.__repr__ ( ) password=getenv ( `` POSTGRES_PASSWORD '' , `` postgres '' ) ) `` Actual Total Time '' : float , self._conn : connection = conn or psycopg2.connect ( * args , * * kwargs ) qep = parser ( `` select * from users '' ) stmt : The query to execute . `` `` '' Performs analyses on given queries , returning resultant QEPAnalysis . '' '' '' qep = parser ( `` select * from stories where id = 1 '' ) return map ( QEPNode , self._node [ `` Plans '' ] ) } ) self._conn.rollback ( ) `` Index Cond '' : str , qep = parser ( `` select * from comments '' ) def __iter__ ( self ) - > Iterable [ `` QEPNode '' ] : return self._qep.__repr__ ( ) import psycopg2 `` `` '' A dict of the node 's properties . '' '' '' insert into users ( name ) values ( 'user1 ' ) ; def __len__ ( self ) - > int : return list ( filter ( pred , self._node [ `` Plans '' ] ) ) insert into stories ( name ) values ( 'story2 ' ) ; postgresql_in_docker = factories.postgresql_noproc ( `` Plan Width '' : int , `` Actual Loops '' : int , insert into users ( name ) values ( 'user2 ' ) ; from typing import Callable , Iterable , List , TypedDict assert qep.plan [ `` Actual Rows '' ] == 1 def __init__ ( self , * args , conn=None , * * kwargs ) : return self._node create table stories ( id serial primary key , name varchar ) ; `` `` '' Get the child node at the given index . '' '' '' return self._qep [ `` Plan '' ] `` `` '' Represents the result of EXPLAIN ANALYZE . '' '' '' return QEPNode ( self._node [ `` Plans '' ] [ key ] ) comment varchar ) ; from pytest_postgresql import factories return self._qep `` Actual Rows '' : int , def __del__ ( self ) : from os import getenv `` Scan Direction '' : str , `` Total Runtime '' : float , `` `` '' Test that the QEP structure is as expected . '' '' '' return QEPAnalysis ( res [ 0 ] [ 0 ] [ 0 ] ) A dictionary representing the query execution plan . insert into comments ( story_id , user_id , comment ) values ( 1 , 1 , 'comment1 ' ) ; postgresql = factories.postgresql ( `` postgresql_in_docker '' ) drop table if exists comments ; `` Plan Rows '' : int , def plan ( self ) - > node : qep = parser ( `` select * from stories where id = 1 or id = 2 '' ) Parameters : assert qep.root [ 0 ] .plan [ `` Relation Name '' ] == `` users '' qep = parser ( `` select * from comments where id = 1 and id = 2 '' ) conn.commit ( ) assert qep.root [ 0 ] .plan [ `` Relation Name '' ] == `` stories '' raise ValueError ( f '' Expected dict in column , got { t } '' ) self._qep = qep_ qep = parser ( `` select * from comments where id = 1 '' ) demonstrates relational data assert qep.root [ 0 ] .plan [ `` Alias '' ] == `` users '' `` Plans '' : List [ `` node '' ] , insert into comments ( story_id , user_id , comment ) values ( 2 , 2 , 'comment4 ' ) ; def __getitem__ ( self , key : int ) - > `` QEPNode '' : `` `` '' A dict of the root node 's properties . '' '' '' `` `` '' Iterate over child nodes . '' '' '' assert qep.plan [ `` Node Type '' ] == `` Index Scan '' # are available for each node type `` Filter '' : str , assert qep.root [ 0 ] .plan [ `` Actual Rows '' ] == 0 assert qep.plan [ `` Alias '' ] == `` users '' def __init__ ( self , node_ : node ) : assert qep.plan [ `` Relation Name '' ] == `` users '' return self ( stmt , * args , * * kwargs ) def test_qep_structure ( parser : qepparser.QEPParser ) : return len ( self._node [ `` Plans '' ] ) * * kwargs : Keyword arguments to pass to cursor.execute ( ) . return self._node [ `` Plans '' ] class QEPNode : assert qep.plan [ `` Relation Name '' ] == `` comments '' import pytest `` Triggers '' : list [ str ] , `` Execution Time '' : float , node = TypedDict ( `` Plan '' , { assert qep.plan [ `` Node Type '' ] == `` Result '' insert into comments ( story_id , user_id , comment ) values ( 1 , 2 , 'comment2 ' ) ; user_id integer references users ( id ) on delete cascade , def parser ( postgresql : connection ) : assert qep.root [ 0 ] .plan [ `` Alias '' ] == `` stories '' create table comments ( assert qep.plan [ `` Node Type '' ] == `` Seq Scan '' qep = parser ( `` select * from users where id = 1 and id = 2 '' ) def __str__ ( self ) : assert qep.plan [ `` Relation Name '' ] == `` stories '' raise ValueError ( f '' Expected 1 column , got { n } '' ) self._node = node_ def plans ( self ) - > list [ node ] : populate with sample data Returns : stmt = f '' explain ( format json , analyze , verbose ) { stmt.strip ( ) .rstrip ( ' ; ' ) } ; '' `` Planning Time '' : float , user=getenv ( `` POSTGRES_USER '' , `` postgres '' ) , Executes a query and returns the query execution plan as a dictionary . `` `` '' A list of the node 's children . '' '' '' `` Node Type '' : str , # right now , the interface is n't safe to use because it 's not clear what fields drop table if exists stories ; `` `` '' ) self._conn.close ( ) raise ValueError ( f '' Expected 1 item in column , got { n } '' ) def root ( self ) - > QEPNode : for copy-and-pasting insert into stories ( name ) values ( 'story1 ' ) ; conn : connection = psycopg2.connect ( * * kwargs ) `` Relation Name '' : str , id serial primary key , `` `` '' Get the number of child nodes . '' '' '' assert qep.root [ 0 ] .plan [ `` Relation Name '' ] == `` comments '' `` Parent Relationship '' : str , return self._node.__str__ ( ) res = cur.fetchall ( ) qep = parser ( `` select * from users where id = 1 or id = 2 '' ) with self._conn.cursor ( ) as cur : from psycopg2.extensions import connection `` Index Name '' : str , `` `` '' A dict of the query execution plan 's properties . '' '' '' `` Plan '' : node , cur.execute ( stmt , * args , * * kwargs ) cur.execute ( `` '' '' `` Total Cost '' : float , if ( n : = len ( res [ 0 ] ) ) ! = 1 : `` `` '' Find nodes matching the predicate . '' '' '' raise ValueError ( f '' Expected 1 row , got { n } '' ) assert qep.plan [ `` Actual Rows '' ] == 2 if ( t : = type ( res [ 0 ] [ 0 ] [ 0 ] ) ) ! = dict : `` Alias '' : str , '' 'Alias for __call__ '' ' def __repr__ ( self ) : def __init__ ( self , qep_ : qep ) : if not self._ref : assert qep.plan [ `` Node Type '' ] == `` Bitmap Heap Scan '' qep = TypedDict ( `` QEP '' , { def load_database ( * * kwargs ) : assert qep.root [ 0 ] .plan [ `` Alias '' ] == `` comments '' assert qep.plan [ `` Actual Rows '' ] == 4 * text=auto qep = parser ( `` select * from stories where id = 1 and id = 2 '' ) * args : Positional arguments to pass to cursor.execute ( ) . return qepparser.QEPParser ( conn=postgresql ) create table users ( id serial primary key , name varchar ) ; assert qep.plan [ `` Alias '' ] == `` comments '' def parse ( self , stmt : str , * args , * * kwargs ) - > QEPAnalysis : return self._qep.__str__ ( ) `` Startup Cost '' : float , `` `` '' class QEPParser : insert into comments ( story_id , user_id , comment ) values ( 2 , 1 , 'comment3 ' ) ;","['.gitattributes', 'qepparser.py', 'test_qepparser.py']",2022-09-29 10:32:05+00:00,2022-10-11 14:32:31+00:00,2022-10-11 17:32:29+03:00
22,672575a8e3f414ce9ffa1f47b1e18b13d13fb9eb,0.9910495281219482,0,See # 10 Look into psql output given ` explain analyze ` with potential machine-readable formatting options .,Analyze QEP format,Merge pull request # 44 from Project-C-SQL/feat/improve-qeps,"`` `` '' Finds nodes matching the predicate , recursively . stmt = f '' explain ( format json , analyze , verbose ) { stmt.strip ( ) .rstrip ( ' ; ' ) } ; '' stmt.strip ( ) .rstrip ( ' ; ' ) + `` ; '' assert len ( qep.root.rfindval ( `` Node Type '' , `` Bitmap Index Scan '' ) ) == 4 : param node_ : the node to wrap '' '' '' return map ( QEPNode , self._node.get ( `` Plans '' , [ ] ) ) To install all dependencies and the application , type ` poetry install ` . After installation , if the Python scripts folder is in your PATH , you should be able to invoke ` main.main ( ) ` with ` pg4n ` . assert qep.root.findval ( `` Relation Name '' , `` comments '' ) == [ qep.plan ] assert qep.root.findval ( `` Relation Name '' , `` users '' ) == [ qep.plan ] password=getenv ( `` PGPASSWORD '' , `` postgres '' ) ) cur.execute ( `` set constraint_exclusion = on ; '' ) qep = parser ( `` select * from stories '' ) `` `` '' Test that the QEP rfind ( recursive find ) method works as expected . '' '' '' assert qep.root.findval ( `` Actual Rows '' , 1 ) == [ qep.plan ] assert qep.root.findval ( `` Node Type '' , `` Seq Scan '' ) == [ qep.plan ] qep = parser ( `` select * from users where id = 1 '' ) return list ( filter ( pred , self._node [ `` Plans '' ] ) ) | ` PGDBNAME ` | ` test_database ` | Database name . | : param recursive : if True , search recursively , otherwise only search password=getenv ( `` PGPASSWORD '' ) , `` `` '' Finds nodes with the given key and value , recursively . self._ref = not not conn `` `` '' Finds nodes matching the predicate . qep = parser ( `` select * from users '' ) Having PostgreSQL running on port 5432 , do ` poetry run pytest ` . qep = parser ( `` select * from stories where id = 1 '' ) self._ref = bool ( conn ) assert qep.root.findval ( `` Alias '' , `` users '' ) == [ qep.plan ] | ` PGUSER ` | ` postgres ` | The user that will be used to manage the test database . | assert qep.root.findval ( `` Actual Rows '' , 4 ) == [ qep.plan ] from itertools import chain def find ( self , pred : Callable [ [ node ] , bool ] ) - > list [ node ] : qep = parser ( `` select * from comments '' ) To get a similar PostgreSQL instance as with GitHub Actions workflow : < br > | -- -- -- -- -- -- | -- -- -- -- -- -- -- - | -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - | : param pred : a function that takes a node and returns True if it matches list ( chain.from_iterable ( x.find ( pr , True ) for x in iter ( self ) ) ) return self._node.get ( `` Plans '' , [ ] ) `` `` '' Get the child node at the given index . : param pr : a function that takes a node and returns True if it matches | ` PGPORT ` | ` 5432 ` | Port to an active PostgreSQL instance . | return self.find ( lambda x : x.get ( key ) == val , recursive ) def test_qep_find ( parser : qepparser.QEPParser ) : assert qep.root.findval ( `` Relation Name '' , `` stories '' ) == [ qep.plan ] | ` PGHOST ` | ` 127.0.0.1 ` | Hostname of the PostgreSQL server . | def findval ( self , key : str , val : object , recursive=False ) - > list [ node ] : | ` PGPASSWORD ` | | Password , in case password authentication is used . | : param key : the key to search for def rfind ( self , pred : Callable [ [ node ] , bool ] ) - > list [ node ] : To install all dependencies and the application , type ` poetry install ` . After installation , if the Python scripts folder is in your PATH , you should be able to invoke ` main.main ( ) ` with ` pg4n ` . `` `` '' Test that the QEP find method works as expected . '' '' '' this+children `` `` '' Finds nodes with the given key and value . assert qep.root.findval ( `` Actual Rows '' , 2 ) == [ qep.plan ] qep = parser ( `` select * from users where id = 1 or id = 2 '' ) assert qep.root.findval ( `` Node Type '' , `` Index Scan '' ) == [ qep.plan ] | Variable | Default value | Description | `` `` '' Get the child node at the given index . '' '' '' with self._conn.cursor ( ) as cur : assert qep.root.findval ( `` Alias '' , `` stories '' ) == [ qep.plan ] return self.find ( pr ) + \ For example , if PostgreSQL is on port 5433 , just do ` PGPORT=5433 poetry run pytest ` ( Bash syntax ) . Having PostgreSQL running on port 5432 , do ` poetry run pytest ` ( or , if on port x , just do ` PGPORT=x poetry run pytest ` ) . qep = parser ( `` select * from comments where id = 1 or id = 2 '' ) return self.findval ( key , val , recursive=True ) stmt = `` explain ( format json , analyze , verbose ) '' + \ return list ( filter ( pr , chain ( ( self._node , ) , self.plans ) ) ) return self._node [ `` Plans '' ] assert len ( qep.root.rfindval ( `` Node Type '' , `` Bitmap Heap Scan '' ) ) == 1 qep = parser ( `` select * from stories where id = 1 or id = 2 '' ) self._conn.commit ( ) def test_gep_rfind ( parser : qepparser.QEPParser ) : You may need to provide environment variables that match your config : `` `` '' Find nodes matching the predicate . '' '' '' `` `` '' Create a new QEPNode . return map ( QEPNode , self._node [ `` Plans '' ] ) To get a similar instance as with GitHub Actions workflow : < br > return self.find ( pred , recursive=True ) : returns : the child node at the given index assert qep.root.findval ( `` Alias '' , `` comments '' ) == [ qep.plan ] if recursive : : returns : a list of matching nodes assert len ( qep.root.rfindval ( `` Node Type '' , `` BitmapOr '' ) ) == 2 dbname=getenv ( `` PGDBNAME '' , `` test_database '' ) ) qep = parser ( `` select * from comments where id = 1 '' ) recursive=False ) - > list [ node ] : def rfindval ( self , key : str , val : object ) - > list [ node ] : `` `` '' : param val : the value to search for : param key : the index of the child node to get # use constraint_exclusion to avoid unnecessary index scans def find ( self , pr : Callable [ [ node ] , bool ] ,","['README.md', 'src/pg4n/qepparser.py', 'src/pg4n/test/test_qepparser.py']",2022-09-29 10:32:05+00:00,2022-10-11 14:32:31+00:00,2022-11-05 13:28:47+02:00
22,3d6dec83450eb47b7c1c89380c7d32be851a2780,0.0010307795600965,0,See # 10 Look into psql output given ` explain analyze ` with potential machine-readable formatting options .,Analyze QEP format,Merge pull request # 97 from Project-C-SQL/fix/qepparser-crash,"raise ValueError ( f '' Expected 1 row , got { n } '' ) if ( t : = type ( res [ 0 ] [ 0 ] [ 0 ] ) ) ! = dict : return QEPAnalysis ( res [ 0 ] [ 0 ] [ 0 ] ) if ( t : = type ( res [ 0 ] [ 0 ] [ 0 ] ) ) ! = dict : try : stmt = `` explain ( format json , analyze , verbose ) '' + \ self._conn.commit ( ) cur.execute ( `` set constraint_exclusion = on ; '' ) try : if ( n : = len ( res [ 0 ] [ 0 ] ) ) ! = 1 : self._conn.rollback ( ) stmt = `` explain ( format json , analyze , verbose ) `` + \ return None if ( n : = len ( res [ 0 ] [ 0 ] ) ) ! = 1 : raise ValueError ( f '' Expected dict in column , got { t } '' ) return QEPAnalysis ( res [ 0 ] [ 0 ] [ 0 ] ) with self._conn.cursor ( ) as cur : res = cur.fetchall ( ) if ( n : = len ( res ) ) ! = 1 : with self._conn.cursor ( ) as cur : except Exception as e : except psycopg.Error as e : if qep_analysis_without_constraint_exclusion is None : self._conn.rollback ( ) cur.execute ( stmt , * args , * * kwargs ) if ( n : = len ( res [ 0 ] ) ) ! = 1 : raise ValueError ( f '' Expected 1 column , got { n } '' ) if qep_analysis_with_constraint_exclusion is None : if self.qep_analysis is None : cur.execute ( `` set constraint_exclusion = on ; '' ) cur.execute ( `` set constraint_exclusion = off ; '' ) if ( n : = len ( res ) ) ! = 1 : if ( n : = len ( res [ 0 ] ) ) ! = 1 : raise ValueError ( f '' Expected dict in column , got { t } '' ) self._conn.commit ( ) cur.execute ( `` set constraint_exclusion = off ; '' ) raise ValueError ( f '' Expected 1 item in column , got { n } '' ) raise ValueError ( f '' Expected 1 column , got { n } '' ) res = cur.fetchall ( ) cur.execute ( stmt , * args , * * kwargs ) raise ValueError ( f '' Expected 1 row , got { n } '' ) raise ValueError ( f '' Expected 1 item in column , got { n } '' )","['src/pg4n/implied_expression_checker.py', 'src/pg4n/qepparser.py', 'src/pg4n/subquery_order_by_checker.py']",2022-09-29 10:32:05+00:00,2022-10-11 14:32:31+00:00,2022-12-16 13:05:50+02:00
33,6c5e663747462817aa670b59addb191b618c5eb9,0.0029586933087557,0,Allow a visitor ( ? ) pattern for passing custom functions to examine tree structure for semantic analysis,Extend QEPAnalysis interface for easier analysis,Merge pull request # 29 from Project-C-SQL/feat/qep-parser,"return QEPNode ( self._qep [ `` Plan '' ] ) assert qep.root [ 0 ] .plan [ `` Node Type '' ] == `` Index Scan '' assert qep.plan [ `` Alias '' ] == `` stories '' load= [ load_database ] , class QEPAnalysis : def __call__ ( self , stmt : str , * args , * * kwargs ) - > QEPAnalysis : if ( n : = len ( res [ 0 ] [ 0 ] ) ) ! = 1 : drop table if exists users ; with conn.cursor ( ) as cur : `` `` '' The root node of the query execution plan . '' '' '' if ( n : = len ( res ) ) ! = 1 : # TODO : break into variants discriminated by Node Type def qep ( self ) - > qep : def find ( self , pred : Callable [ [ node ] , bool ] ) - > list [ node ] : `` `` '' A node in a query execution plan . '' '' '' qep = parser ( `` select * from stories '' ) `` Actual Startup Time '' : float , import qepparser self._ref = not not conn qep = parser ( `` select * from users where id = 1 '' ) story_id integer references stories ( id ) on delete cascade , return self._node.__repr__ ( ) password=getenv ( `` POSTGRES_PASSWORD '' , `` postgres '' ) ) `` Actual Total Time '' : float , self._conn : connection = conn or psycopg2.connect ( * args , * * kwargs ) qep = parser ( `` select * from users '' ) stmt : The query to execute . `` `` '' Performs analyses on given queries , returning resultant QEPAnalysis . '' '' '' qep = parser ( `` select * from stories where id = 1 '' ) return map ( QEPNode , self._node [ `` Plans '' ] ) } ) self._conn.rollback ( ) `` Index Cond '' : str , qep = parser ( `` select * from comments '' ) def __iter__ ( self ) - > Iterable [ `` QEPNode '' ] : return self._qep.__repr__ ( ) import psycopg2 `` `` '' A dict of the node 's properties . '' '' '' insert into users ( name ) values ( 'user1 ' ) ; def __len__ ( self ) - > int : return list ( filter ( pred , self._node [ `` Plans '' ] ) ) insert into stories ( name ) values ( 'story2 ' ) ; postgresql_in_docker = factories.postgresql_noproc ( `` Plan Width '' : int , `` Actual Loops '' : int , insert into users ( name ) values ( 'user2 ' ) ; from typing import Callable , Iterable , List , TypedDict assert qep.plan [ `` Actual Rows '' ] == 1 def __init__ ( self , * args , conn=None , * * kwargs ) : return self._node create table stories ( id serial primary key , name varchar ) ; `` `` '' Get the child node at the given index . '' '' '' return self._qep [ `` Plan '' ] `` `` '' Represents the result of EXPLAIN ANALYZE . '' '' '' return QEPNode ( self._node [ `` Plans '' ] [ key ] ) comment varchar ) ; from pytest_postgresql import factories return self._qep `` Actual Rows '' : int , def __del__ ( self ) : from os import getenv `` Scan Direction '' : str , `` Total Runtime '' : float , `` `` '' Test that the QEP structure is as expected . '' '' '' return QEPAnalysis ( res [ 0 ] [ 0 ] [ 0 ] ) A dictionary representing the query execution plan . insert into comments ( story_id , user_id , comment ) values ( 1 , 1 , 'comment1 ' ) ; postgresql = factories.postgresql ( `` postgresql_in_docker '' ) drop table if exists comments ; `` Plan Rows '' : int , def plan ( self ) - > node : qep = parser ( `` select * from stories where id = 1 or id = 2 '' ) Parameters : assert qep.root [ 0 ] .plan [ `` Relation Name '' ] == `` users '' qep = parser ( `` select * from comments where id = 1 and id = 2 '' ) conn.commit ( ) assert qep.root [ 0 ] .plan [ `` Relation Name '' ] == `` stories '' raise ValueError ( f '' Expected dict in column , got { t } '' ) self._qep = qep_ qep = parser ( `` select * from comments where id = 1 '' ) demonstrates relational data assert qep.root [ 0 ] .plan [ `` Alias '' ] == `` users '' `` Plans '' : List [ `` node '' ] , insert into comments ( story_id , user_id , comment ) values ( 2 , 2 , 'comment4 ' ) ; def __getitem__ ( self , key : int ) - > `` QEPNode '' : `` `` '' A dict of the root node 's properties . '' '' '' `` `` '' Iterate over child nodes . '' '' '' assert qep.plan [ `` Node Type '' ] == `` Index Scan '' # are available for each node type `` Filter '' : str , assert qep.root [ 0 ] .plan [ `` Actual Rows '' ] == 0 assert qep.plan [ `` Alias '' ] == `` users '' def __init__ ( self , node_ : node ) : assert qep.plan [ `` Relation Name '' ] == `` users '' return self ( stmt , * args , * * kwargs ) def test_qep_structure ( parser : qepparser.QEPParser ) : return len ( self._node [ `` Plans '' ] ) * * kwargs : Keyword arguments to pass to cursor.execute ( ) . return self._node [ `` Plans '' ] class QEPNode : assert qep.plan [ `` Relation Name '' ] == `` comments '' import pytest `` Triggers '' : list [ str ] , `` Execution Time '' : float , node = TypedDict ( `` Plan '' , { assert qep.plan [ `` Node Type '' ] == `` Result '' insert into comments ( story_id , user_id , comment ) values ( 1 , 2 , 'comment2 ' ) ; user_id integer references users ( id ) on delete cascade , def parser ( postgresql : connection ) : assert qep.root [ 0 ] .plan [ `` Alias '' ] == `` stories '' create table comments ( assert qep.plan [ `` Node Type '' ] == `` Seq Scan '' qep = parser ( `` select * from users where id = 1 and id = 2 '' ) def __str__ ( self ) : assert qep.plan [ `` Relation Name '' ] == `` stories '' raise ValueError ( f '' Expected 1 column , got { n } '' ) self._node = node_ def plans ( self ) - > list [ node ] : populate with sample data Returns : stmt = f '' explain ( format json , analyze , verbose ) { stmt.strip ( ) .rstrip ( ' ; ' ) } ; '' `` Planning Time '' : float , user=getenv ( `` POSTGRES_USER '' , `` postgres '' ) , Executes a query and returns the query execution plan as a dictionary . `` `` '' A list of the node 's children . '' '' '' `` Node Type '' : str , # right now , the interface is n't safe to use because it 's not clear what fields drop table if exists stories ; `` `` '' ) self._conn.close ( ) raise ValueError ( f '' Expected 1 item in column , got { n } '' ) def root ( self ) - > QEPNode : for copy-and-pasting insert into stories ( name ) values ( 'story1 ' ) ; conn : connection = psycopg2.connect ( * * kwargs ) `` Relation Name '' : str , id serial primary key , `` `` '' Get the number of child nodes . '' '' '' assert qep.root [ 0 ] .plan [ `` Relation Name '' ] == `` comments '' `` Parent Relationship '' : str , return self._node.__str__ ( ) res = cur.fetchall ( ) qep = parser ( `` select * from users where id = 1 or id = 2 '' ) with self._conn.cursor ( ) as cur : from psycopg2.extensions import connection `` Index Name '' : str , `` `` '' A dict of the query execution plan 's properties . '' '' '' `` Plan '' : node , cur.execute ( stmt , * args , * * kwargs ) cur.execute ( `` '' '' `` Total Cost '' : float , if ( n : = len ( res [ 0 ] ) ) ! = 1 : `` `` '' Find nodes matching the predicate . '' '' '' raise ValueError ( f '' Expected 1 row , got { n } '' ) assert qep.plan [ `` Actual Rows '' ] == 2 if ( t : = type ( res [ 0 ] [ 0 ] [ 0 ] ) ) ! = dict : `` Alias '' : str , '' 'Alias for __call__ '' ' def __repr__ ( self ) : def __init__ ( self , qep_ : qep ) : if not self._ref : assert qep.plan [ `` Node Type '' ] == `` Bitmap Heap Scan '' qep = TypedDict ( `` QEP '' , { def load_database ( * * kwargs ) : assert qep.root [ 0 ] .plan [ `` Alias '' ] == `` comments '' assert qep.plan [ `` Actual Rows '' ] == 4 * text=auto qep = parser ( `` select * from stories where id = 1 and id = 2 '' ) * args : Positional arguments to pass to cursor.execute ( ) . return qepparser.QEPParser ( conn=postgresql ) create table users ( id serial primary key , name varchar ) ; assert qep.plan [ `` Alias '' ] == `` comments '' def parse ( self , stmt : str , * args , * * kwargs ) - > QEPAnalysis : return self._qep.__str__ ( ) `` Startup Cost '' : float , `` `` '' class QEPParser : insert into comments ( story_id , user_id , comment ) values ( 2 , 1 , 'comment3 ' ) ;","['.gitattributes', 'qepparser.py', 'test_qepparser.py']",2022-10-13 10:05:14+00:00,2022-11-10 10:55:29+00:00,2022-10-11 17:32:29+03:00
34,aebf426ab3350d922e78442db19398914f4610aa,0.9904882907867432,0,"A router class that receives a package of parsed QEP , SQL statements , and PSQL connection . Semantic analysis can independently fetch query results and table constraints using the connection if needed . Router then does classification of error types using trivial heuristics , to avoid performance penalty of using every deep analysis method on each query , and then passes the data for further analysis . Gathering the resulting analysis outcomes and associated messages , it passes a select message ( e.g from first positive analysis ) back to the psql interface .",A classification router for semantic analysis,Merge pull request # 53 from Project-C-SQL/feat/semantic-router,"PsqlParser ( ) ) identbodychars , nums def new_psqlwrapper ( ) : pexpect_conninfo.expect ( pexpect.EOF ) running all the modules on all queries . For now , it is dumb brute return `` '' # No semantic errors found Literal ( `` \ '' . '' ) self.tok_pre_host + self.tok_host + \ def test_ofilter ( ) - > None : tok_user : ParserElement = \ self.tok_pre_database + self.tok_database + \ `` port= '' + self.pg_port def _replace_prompt ( self , prompt : bytes ) : to initialize connection info . '' '' '' lambda x : `` Helpful message '' , print ( e.explain ( ) ) sem_router = SemanticRouter ( * conn_info ) # asterisk unpacks the 5-tuple print_msg = self.pg4n_message.replace ( `` \n '' , `` \r\n '' ) `` `` '' Run analysis modules on SQL query string and get an insightful \ ParseException , ParserElement , \ conninfo_res = \ results = [ res_list [ 3 ] [ : :-1 ] , ( StringEnd ( ) | ( Literal ( `` ? [ \x1b '' ) + \ self.pg_name ) tok_end : ParserElement = \ tok_pre_port : ParserElement = \ pexpect_conninfo = pexpect.spawn ( `` psql -c \ '' \\conninfo\ '' `` + psql_args ) self.tok_end self.pg_user , Literal , Word , \ res_list [ 0 ] [ : :-1 ] psql : psqlwrapper.PsqlWrapper = new_psqlwrapper ( ) print ( `` Fatal error : psql connection info could not be parsed\n '' name . '' '' '' `` dbname= '' + self.pg_name Semantic router ( some day ) implements basic heuristics to avoid def test_ofilter ( ) : self.pg_name = conninfo_res [ 1 ] tok_pre_host : ParserElement = \ def start ( self ) - > None : self.pg_host = conninfo_res [ 5 ] res_list [ 2 ] [ : :-1 ] psql by supplying same arguments as the original psql process . This \ p = PsqlParser ( ) ] pg_port : str , tok_pre_database : ParserElement = \ `` `` '' Initialize Postgres connection with given paramaters . '' '' '' from sqlglot import exp def __init__ ( self , print ( f '' { os.path.basename ( sys.executable ) } main.py < database name > '' ) force router . self.pg_pass : str = pg_pass `` `` '' Get 5-tuple that has the PostgreSQL host , port , user , pass , and db \ `` `` '' Use psql child process with exact same command-line arguments \ sanitized_sql : exp.Expression = sql_parser.parse_one ( sql_query ) Literal ( `` \ '' at port \ '' '' ) match_psql_conninfo : ParserElement = \ lambda x : `` Test '' , self.pg_port = conninfo_res [ 7 ] psql = psqlwrapper.PsqlWrapper ( `` '' , tok_database : ParserElement = \ results = [ res_list [ 3 ] [ : :-1 ] , from .semanticrouter import SemanticRouter ) .get ( ) message in return . def __init__ ( self , psql_args : str ) : ... + StringEnd ( ) ) ) Literal ( `` You are connected to database \ '' '' ) self.pg_user = conninfo_res [ 3 ] p = psqlparser.PsqlParser ( ) ] `` password= '' + self.pg_pass ) as conn : pg_name : str # Comparing different domains sem_router.run_analysis , return ( self.pg_host , elif len ( res_list ) == 2 : # stops right after database name self.pg_host : str = pg_host : returns : an insightful message that might include vt100-compatible \ import psycopg class PsqlConnInfo : match_psql_conninfo.parse_string ( conninfo_str ) .as_list ( ) from functools import reduce psql : PsqlWrapper = new_psqlwrapper ( ) pass from .. psqlwrapper import PsqlWrapper from .. import psqlparser def test_parse_last_found_stmt ( ) : psql = psqlwrapper.PsqlWrapper ( sys.argv [ 1 ] .encode ( `` utf-8 '' ) , def test_parse_new_prompt ( ) - > None : def test_parse_magical_return ( ) - > None : res_list [ 1 ] [ : :-1 ] Literal ( `` \ '' as user \ '' '' ) if analysis_result is not None : res_list [ 0 ] [ : :-1 ] def test_parse_new_prompt ( ) : conn_info = PsqlConnInfo ( def test_parse_magical_return ( ) : try : `` `` '' Get PostgreSQL server address , port , database name , and user via \ from .. import psqlwrapper main.py [ psql arguments ] < database name > '' ) from .. psqlparser import PsqlParser self.pg_name : str = pg_name from .psqlparser import PsqlParser Word ( self.prompt_chars ) + Literal ( `` ? [ \x1b '' ) + \ : param sql_query : is a single well-formed query to run analytics on . Word ( self.prompt_chars ) + \ conninfo_str = bytes.decode ( pexpect_conninfo.before ) psqlparser.PsqlParser ( ) ) pg_pass : str , def test_parse_new_prompt_and_rest ( ) - > None : psql = PsqlWrapper ( `` '' , self.tok_pre_port + self.tok_port + \ self.pg_port , way we can avoid writing a command-line argument parser . '' '' '' psqlparser.PsqlParser ( ) ) with psycopg.connect ( `` host= '' + self.pg_host reduce ( lambda x , y : x + y , sys.argv [ 1 : ] , `` '' ) # concat arguments columns : list [ Column ] = sql_parser.get_query_columns ( sanitized_sql ) pg_host : str , def main ( ) - > None : sql_parser : SqlParser = SqlParser ( conn ) def test_parse_new_prompt_and_rest ( ) : `` user= '' + self.pg_user # analysis modules res_list [ 2 ] [ : :-1 ] self.pg_user : str = pg_user self.pg_port : str = pg_port def run_analysis ( self , sql_query : str ) - > str : print_msg + `` \r\n\r\n '' def new_psqlwrapper ( ) - > PsqlWrapper : from .psqlwrapper import PsqlWrapper res_list [ 1 ] [ : :-1 ] from .sqlparser import SqlParser , Column Word ( identbodychars + `` / . '' ) control codes . \n is newline ( carriage return \r will be added by \ pg_user : str , tok_host : ParserElement = \ def get ( self ) - > ( str , str , str , str , str ) : self.pg4n_message + `` \r\n\r\n '' `` `` '' Analyze given SQL queries via a plethora of analysis modules . '' '' '' # ^either stops after dbname or includes \x1b [ ? 2004l ... Literal ( `` \ '' via socket in \ '' '' ) tok_pre_user : ParserElement = \ wrapper ) . def _replace_prompt ( self , prompt : bytes ) - > bytes : def start ( self ) : import pexpect from . import psqlparser results = [ `` , from .cmp_domain_checker import CmpDomainChecker class SemanticRouter : from .psqlconninfo import PsqlConnInfo analysis_result = CmpDomainChecker ( sanitized_sql , columns ) .check ( ) self.tok_pre_user + self.tok_user + \ Literal ( `` \ '' on host \ '' '' ) | \ Word ( nums ) from typing import Optional except ParseException as e : ... + StringEnd ( ) from . import psqlwrapper self.pg_pass = `` '' tok_port : ParserElement = \ Word ( identbodychars ) self.pg_pass , print ( f '' { os.path.basename ( sys.executable ) } \ from pyparsing import \ def main ( ) : return analysis_result if len ( res_list ) == 4 : # includes \x1b [ ? 2004l lambda x : `` Test '' , ) : e.explain ( ) ) `` `` '' psql = PsqlWrapper ( sys.argv [ 1 ] .encode ( `` utf-8 '' ) , PsqlParser ( ) ) analysis_result : Optional [ str ] = None def test_parse_last_found_stmt ( ) - > None :","['src/pg4n/main.py', 'src/pg4n/psqlconninfo.py', 'src/pg4n/psqlparser.py', 'src/pg4n/psqlwrapper.py', 'src/pg4n/semanticrouter.py', 'src/pg4n/test/test_psqlparser.py', 'src/pg4n/test/test_psqlwrapper.py']",2022-10-13 10:10:22+00:00,2022-12-12 12:49:06+00:00,2022-11-07 20:09:02+02:00
37,3d6dec83450eb47b7c1c89380c7d32be851a2780,0.0009172561694867,0,qepparser needs to use SET constraint_exclusion = 'on ' before doing its queries . This makes # 6 trivial search for One-Time Filter 's from the QEP .,constraint_exclusion option for qepparser,Merge pull request # 97 from Project-C-SQL/fix/qepparser-crash,"raise ValueError ( f '' Expected 1 row , got { n } '' ) if ( t : = type ( res [ 0 ] [ 0 ] [ 0 ] ) ) ! = dict : return QEPAnalysis ( res [ 0 ] [ 0 ] [ 0 ] ) if ( t : = type ( res [ 0 ] [ 0 ] [ 0 ] ) ) ! = dict : try : stmt = `` explain ( format json , analyze , verbose ) '' + \ self._conn.commit ( ) cur.execute ( `` set constraint_exclusion = on ; '' ) try : if ( n : = len ( res [ 0 ] [ 0 ] ) ) ! = 1 : self._conn.rollback ( ) stmt = `` explain ( format json , analyze , verbose ) `` + \ return None if ( n : = len ( res [ 0 ] [ 0 ] ) ) ! = 1 : raise ValueError ( f '' Expected dict in column , got { t } '' ) return QEPAnalysis ( res [ 0 ] [ 0 ] [ 0 ] ) with self._conn.cursor ( ) as cur : res = cur.fetchall ( ) if ( n : = len ( res ) ) ! = 1 : with self._conn.cursor ( ) as cur : except Exception as e : except psycopg.Error as e : if qep_analysis_without_constraint_exclusion is None : self._conn.rollback ( ) cur.execute ( stmt , * args , * * kwargs ) if ( n : = len ( res [ 0 ] ) ) ! = 1 : raise ValueError ( f '' Expected 1 column , got { n } '' ) if qep_analysis_with_constraint_exclusion is None : if self.qep_analysis is None : cur.execute ( `` set constraint_exclusion = on ; '' ) cur.execute ( `` set constraint_exclusion = off ; '' ) if ( n : = len ( res ) ) ! = 1 : if ( n : = len ( res [ 0 ] ) ) ! = 1 : raise ValueError ( f '' Expected dict in column , got { t } '' ) self._conn.commit ( ) cur.execute ( `` set constraint_exclusion = off ; '' ) raise ValueError ( f '' Expected 1 item in column , got { n } '' ) raise ValueError ( f '' Expected 1 column , got { n } '' ) res = cur.fetchall ( ) cur.execute ( stmt , * args , * * kwargs ) raise ValueError ( f '' Expected 1 row , got { n } '' ) raise ValueError ( f '' Expected 1 item in column , got { n } '' )","['src/pg4n/implied_expression_checker.py', 'src/pg4n/qepparser.py', 'src/pg4n/subquery_order_by_checker.py']",2022-10-25 08:51:21+00:00,2022-11-05 11:28:49+00:00,2022-12-16 13:05:50+02:00
47,535fdf800713ce7b74f1e330e9c02af0bb981db2,0.0022445975337177,0,,Detect compare different domains error ( e31 per Brass ),Merge pull request # 95 from Project-C-SQL/feat/error-handling-and-syntax-error-detection,"def parse_new_prompt_and_rest ( self , psql : str ) - > list [ str ] : prompt_res = match_rev_prompt_end.parse_string ( psql_rev ) Literal ( `` psql ( PostgreSQL ) `` ) + Combine ( Word ( nums ) + ' . ' + Word ( nums ) ) SubquerySelectChecker ( sanitized_sql , sql_parser ) .check ( ) from pyparsing import ( prompt_res = match_rev_prompt_end.parse_string ( psql_rev ) # Licensed under MIT . self.tok_rev_prompt_end psql_args : str # Semantic analysis is always done when user presses Return after most recent query . pg_user : str , # Comparing different domains Char ( ' ; ' ) from shutil import get_terminal_size psql.ofilter ( b'\r\n\r\r\n ' ) self , analysis_result = SubquerySelectChecker ( if output [ 0:2 ] == b'\r\n ' : qep_analysis def test_parse_last_stmt ( ) - > None : except Exception : # Matches only program errors ( see flake8 rule E722 ) ) - > bytes : # Opt ( Literal ( ' * ' ) | Literal ( ' ! ' ) | Literal ( ' ? ' ) , `` '' ) psql.ofilter ( b'\x1b [ ? 2004htest_db- # ' ) except ParseException : psql.ofilter ( b '' '\r ( reverse-i-search ) ` ' : `` ) assert p.output_has_new_prompt ( case_mixed_results ) # SUM/AVG ( DISTINCT ) def parse_new_prompt ( self , psql : str ) - > List [ str ] : def _check_and_act_on_repl_output ( # AND-clause will stop executing after first False . match_rev_magical_returns.parse_string ( psql_rev ) analysis_result = CmpDomainChecker ( sanitized_sql , columns ) .check ( ) self.tok_pre_database + self.tok_database assert p.parse_last_stmt ( case_trivial ) == \ pg_user : str , `` `` '' line and then the prompt , to allow easy message injection . res_list [ 1 ] [ : :-1 ] # see how the screen would look like , but still allow injecting to pick up relevant SQL statements and syntax errors for hook functions . '' '' '' if self.parser.output_has_magical_return ( res_list [ 2 ] [ : :-1 ] Word , assert p.parse_last_found_stmt ( case_multiline_query ) == \ psql_rev : str = psql [ : :-1 ] if magical_return_res : if self.pg4n_message ! = `` '' \ def test_output_has_new_prompt ( ) - > None : # Literal ( `` ERROR : '' ) return input reduce ( lambda x , y : x + y [ : :-1 ] , results , `` '' ) psql._intercept ( b'\r\n\r\r\n ' ) # Wildcards without LIKE `` `` '' if output [ 0:2 ] == b '' \r\n '' : ) : analysis_result : Optional [ str ] = None def test_output_has_magical_return ( ) - > None : return self.pg_tuple psql.start ( ) intercepted queries and syntax errors . psql._intercept ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 100\x1b [ 27m ; \x08\x08\x08\x08\x08\x08 '' ) # Turn on verbose output to psqlparser.log file in working directory from pyparsing import Literal , Word , ParseException , ParserElement , \ `` psql `` + bytes.decode ( self.psql_args ) , prompt_res : Optional [ ParseResults ] = None : returns : an empty list if no prompt found . Otherwise has [ ' > = ' ] or \ unreversed_flattened_res : str = reduce ( def test_parse_magical_return ( ) - > None : # SQL parser , QEP parser , or an analysis module exploded : # Since latest_output contains error details , we will have to bytes.decode ( latest_output ) # `` = > SELECT psql.ofilter ( b'\r\n\x1b [ ? 2004l\r ' ) `` - ! > '' , `` * ! > '' , `` \ ' ! > '' , `` \ '' ! > '' , `` $ ! > '' , `` ( ! > '' , pg_host : str , return bytes ( line and then the prompt , to allow easy message injection . sql_parser : SqlParser = SqlParser ( conn ) assert psql._intercept ( fresh_prompt_1 ) == \ self.tok_pre_database + self.tok_database + \ match_rev_magical_returns : ParserElement = \ psql = PsqlWrapper ( sys.argv [ 1 ] .encode ( `` utf-8 '' ) , `` `` '' Start psql process and feed hook functions with \ encoding= '' utf-8 '' , assert psql._intercept ( case_query_2_prompt ) == \ main.py [ psql arguments ] < database name > '' ) def check_psql_version ( self ) - > str : self.tok_pre_user + self.tok_user Literal , def parse_new_prompt_and_rest ( self , psql : str ) - > List [ str ] : # for optimization reasons , check output only if len ( ) > 1 , so most psql._intercept ( case_query_1 ) `` `` '' Check for weird Return presses . self.parser.parse_new_prompt_and_rest ( tok_stmt_end psql.ofilter ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C1 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 1\x1b [ 27m00 ; \x08\x08\x08\x08\x08\x08 '' ) .replace ( db_name + `` - > '' , `` '' ) \ and self.parser.parse_new_prompt ( tok_rev_error : ParserElement = Literal ( `` : RORRE '' ) res_list [ 2 ] [ : :-1 ] + res_list [ 1 ] [ : :-1 ] + res_list [ 0 ] [ : :-1 ] try : self.tok_rev_prompt_end def test_parse_new_prompt ( ) - > None : if len ( res_list ) == 4 : # results include \x1b [ ? 2004l # prompt1 per bin/psql/prompt.c : match_rev_last_stmt : ParserElement = ( split_prompt [ 1 ] , assert psql.ofilter ( fresh_prompt_1 ) == \ print ( f '' { os.path.basename ( sys.executable ) } \ results = [ : returns : a two-part list with everything before the prompt \ assert p.parse_last_stmt ( case_select_then_select ) == \ match_rev_last_stmt : ParserElement = \ ' . ' def test_ofilter ( ) - > None : StringEnd , self.pg_tuple = ( if prompt_res : ( Literal ( ' # ' ) | Literal ( ' > ' ) ) are received . `` port= '' + self.pg_port no_newlines_res = unreversed_flattened_res.replace ( '\n ' , ' ' ) def check_and_act_on_repl_output ( self , latest_output : bytes ) - > bytes : Literal ( `` psql ( PostgreSQL ) `` ) psql_rev = psql [ : :-1 ] # slicing is fastest operation for reversing # prompt : analysis_result = CmpDomainChecker ( bytes.decode ( prompt , `` utf-8 '' ) ) return has_magical_return # rev means reversed , these are for performance reasons . from typing import Optional , Tuple return `` Pg4n has only been tested on psql versions `` + \ analysis_result = EqWildcardChecker ( print_msg + `` \r\n\r\n '' if self.parser.output_has_new_prompt ( self.tok_rev_prompt_end def __init__ ( self , psql_args : str ) : SumDistinctChecker ( sanitized_sql , qep_analysis ) .check ( ) CaselessLiteral , to pick up relevant SQL statements for the hook function . potential_future_contents : str = '\n'.join ( # If we have a semantic error message waiting and there is a fresh `` user= '' + self.pg_user `` `` '' Parse for syntax error output . self.tok_pre_host + self.tok_host + \ conn ) .check ( ) : returns : syntax error message from 'ERROR : ' to last '^ ' . self.pg4n_message = self.semantic_analyze ( parsed_sql_query ) qep_analysis : QEPAnalysis = QEPParser ( conn=conn ) .parse ( sql_query ) version_info = \ `` - ? > '' , `` * ? > '' , `` \ ' ? > '' , `` \ '' ? > '' , `` $ ? > '' , `` ( ? > '' ] : returns : an empty string if current version has been tested , \ `` dbname= '' + self.pg_name psql.ofilter ( b'SELECT ' ) bytes.decode ( latest_output ) ) ! = [ ] : # there is new prompt self.match_rev_any_sql_stmt + Word ( self.prompt_chars ) psql.ofilter ( b'\r\x1b [ C ' ) # ( Return is always at least 2 length ) psql.ofilter ( b'\r\x1b [ K\x1b > \x1b [ r\x1b [ ? 1049l ' ) reversed_flattened_res : str = \ # input does not trigger parsing ( Return is always at least 2 length ) psql._intercept ( b'orders ' ) potential_future_screen = \ results = [ res_list [ 3 ] [ : :-1 ] , potential_future_screen_output_sink.feed ( psql.ofilter ( b'SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; ' ) import sys psql._intercept ( b'\r\x1b [ K\x1b > \x1b [ r\x1b [ ? 1049l ' ) : returns : if output is a fresh prompt . ImpliedExpressionChecker ( sanitized_sql , sql_query , if version == `` '' : c.interact ( input_filter=lambda x : x , output_filter=self._intercept ) latest_output : bytes : param prompt : is where the message is injected . A fresh prompt is \ sanitized_sql : exp.Expression = sql_parser.parse_one ( sql_query ) # debug creates pyte.screen ( current screenscraping context ) and Opt ( Literal ( ' * ' ) | Literal ( ' ! ' ) | Literal ( ' ? ' ) , `` '' ) stmt_res = match_error_statement.parse_string ( psql_rev ) pexpect.spawn ( `` psql `` + bytes.decode ( self.psql_args ) psql.ofilter ( b'\x08\x08 ' ) psql.ofilter ( b'\r\n ' ) def ofilter ( self , output : bytes ) - > bytes : : returns : a prompt with injected message , or unchanged if \ `` `` '' Forward output to ` _check_and_act_on_repl_output ` and feed \ StrangeHavingChecker ( sanitized_sql , qep_analysis ) .check ( ) def parse_syntax_error ( self , psql : str ) - > str : # magic strings ( related at least to ctrl-R use ) are lambda x , y : x + y [ : :-1 ] , results , `` '' else : from pyparsing import \ ) - > None : `` `` '' Detect when psql query evaluation has ended by parsing for a new prompt . psql._intercept ( b'\x1b [ ? 2004htest_db- # ' ) psql._intercept ( b ' ; ' ) assert p.parse_last_stmt ( case_empirical_1 ) == \ # from .inconsistent_expression_checker import InconsistentExpressionChecker `` `` '' Forward output to ` check_and_act_on_repl_output ( ) ` and feed \ with . CaselessLiteral , Char , Combine , Literal , ParseException , \ # and resulting message is saved here until when new prompt comes in # Inconsistent expression from functools import reduce # just match against a list of all possible combinations hook_semantic_f : Callable [ [ str ] , str ] , `` user= '' + self.pg_user # % / % R % x % # per postgres bin/psql/settings.h except ParseException as e : : returns : if user has indeed hit return . sql_query : str if len ( res_list ) == 2 : # parsing stops right after database name # replacing \n 's with `` '' maybe has less edge cases . Or actually more . sanitized_sql , `` SELECT * FROM orders WHERE order_total_eur = 100 ; '' # tok_multiline_prompt_end : ParserElement = \ `` `` '' Initiate session by getting psql connection parameters via psql \ # % / = current database psql_rev : str = psql [ : :-1 ] # slicing is fastest operation for reverse self.parser.parse_last_found_stmt ( screen ) self.pg_name `` psql `` + bytes.decode ( self.psql_args ) + `` -- version '' | Literal ( `` \x08\r\n '' [ : :-1 ] ) demultilined_res : str = no_newlines_res psql._intercept ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C1 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 1\x1b [ 27m00 ; \x08\x08\x08\x08\x08\x08 '' ) # e.g . `` pg4n -- help '' is being run . # should parse as \n - > `` `` to avoid `` SELECT * FROM .. '' . print ( `` pg4n [ psql arguments ] < database name > '' ) # get terminal screen contents # superusers have = # prompt # Literal ( '\ '' ' ) | Literal ( ' $ ' ) | Literal ( ' ( ' ) ) # multiple elements into one . These are often combined to build functions elif len ( res_list ) == 2 : # parsing stops right after database name # Analysis is always done when user presses Return [ `` # = '' ] self.pg_pass , Literal ( `` > = '' ) | Literal ( `` # = '' ) with psycopg.connect ( `` host= '' + self.pg_host def start ( # SELECT in subquery Word ( nums ) # Inconsistent expression InconsistentExpressionChecker ( sanitized_sql , qep_analysis ) .check ( ) psql.ofilter ( b'orders ' ) # possibly provide a message to be included in next new prompt . stmt_chars : str = \ Control is only returned after psql process exits . tok_marker_caret : ParserElement = Literal ( `` ^ '' ) ZeroOrMore ( White ( ) ) from typing import List control codes . \n is newline ( carriage return \r will be added by \ multiline_prompt_ends : list [ str ] = \ assert p.parse_last_stmt ( case_query_with_newline ) == \ [ `` - # '' , `` * # '' , `` \ ' # '' , `` \ '' # '' , `` $ # '' , `` ( # '' , `` SELECT * FROM orders WHERE order_total_eur = 100 ; '' ZeroOrMore ( Char ( `` \n '' ) | Char ( `` \r '' ) | White ( ) ) debug : bool = False match_rev_prompt_and_then_rest : ParserElement = ( psql.ofilter ( case_psql_start ) stmt_res : Optional [ ParseResults ] = None assert p.parse_last_found_stmt ( case_multiple_queries_and_whitespaces ) == \ respectively . self `` `` '' Parse for a fresh prompt and everything preceding it into 2-length \ f.write ( '\n'.join ( line.rstrip ( ) for line in self.pyte_screen.display ) # and resulting message is saved until when new prompt comes in bytes.decode ( output , `` utf-8 '' ) output_filter=self.ofilter ) `` -- version '' ) stmt_chars : str = printable.translate ( str.maketrans ( `` '' , `` '' , stmt_end ) ) ) sql_parser : returns : unchanged input . SubqueryOrderByChecker ( sanitized_sql , qep_analysis ) .check ( ) psql._intercept ( b ' * ' ) `` - ! # '' , `` * ! # '' , `` \ ' ! # '' , `` \ '' ! # '' , `` $ ! # '' , `` ( ! # '' , messages are passed to , and from which corresponding warning messages \ detecting new prompt fails . sem_router = SemanticRouter ( * conn_info ) # asterisk unpacks the 5-tuple pg_name : str return assert p.parse_new_prompt ( case_trivial ) == \ `` utf-8 '' print_msg + `` \r\n\r\n '' : param input : user input characters . stmt_res_list [ 1 ] ] # `` pgdb= > SELECT def test_parse_last_found_stmt ( ) - > None : : param prompt : is output where message is injected to . A fresh prompt \ ) .check ( ) ] # * FROM orders WHERE order_total_eur = 100 ; c.interact ( input_filter=self.ifilter , psql._intercept ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 10\x1b [ 27m0 ; \x08\x08\x08\x08\x08\x08 '' ) analysis_result = StrangeHavingChecker ( `` utf-8 '' ) psql._intercept ( b'\r\n ' ) res_list [ 3 ] [ : :-1 ] , def parse_magical_return ( self , psql : str ) - > List [ str ] : return bytes ( split_prompt [ 0 ] + `` \r\n '' split_prompt : List [ str ] = self.parser.parse_new_prompt_and_rest ( tok_stmt_end : ParserElement = Char ( ' ; ' ) sql_parser : SqlParser = SqlParser ( conn ) `` Pg4n has only been tested on psql versions `` `` `` '' Handle semantic analysis modules . '' '' '' psql._intercept ( b '' \r\n\x1b [ ? 2004l\r '' ) `` . '' elif len ( res_list ) == 4 : # results include \x1b [ ? 2004h .. EqWildcardChecker ( sanitized_sql , qep_analysis ) .check ( ) # reverse string for parsing efficiency syntax_error = \ def test_intercept ( ) - > None : if analysis_result is not None : sem_router.run_analysis , psql._intercept ( b'\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) # magic strings related seemingly solely to ctrl-R use are bytes.decode ( output , `` utf-8 '' ) ) ! = [ ] : `` - * # '' , `` * * # '' , `` \ ' * # '' , `` \ '' * # '' , `` $ * # '' , `` ( * # '' , parsed_sql_query : str = self.parser.parse_last_stmt ( screen ) results : List [ str ] = [ ] ParseException , ParserElement , \ psql_output = pexpect.spawn ( # `` \r\n\x1b [ ? 2004l\r '' , `` \r\n\r\r\n '' and `` \x08\r\n '' . encoding= '' utf-8 '' , psql_output.expect ( pexpect.EOF ) self.pg4n_message = `` '' # Strange HAVING clause without GROUP BY self.pg4n_message = self.syntax_analyze ( syntax_error ) psql._intercept ( b'\x1b [ ? 2004l\r\x1b [ ? 2004htest_db- # ' ) assert psql.ofilter ( b'\x1b [ ? 2004l\r order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004htest_db= # ' ) == \ def main ( ) - > None : str ( self.supported_psql_versions ) + `` . '' if magical_return_res : assert p.parse_last_found_stmt ( case_trivial ) == \ # This will match against `` % R % x % # `` , e.g `` = > `` . # Strange HAVING clause without GROUP BY line.rstrip ( ) for line in self.pyte_screen.display ) parsed_sql_query : str = \ if stmt_res : def start ( self ) - > None : self : param db_name_parameter : is name of database we are connecting to . # % R = - , * , ' , `` ; also $ , ( if syntax_error ! = `` '' : return analysis_result : param psql : screenscraped psql string with only whitespace \ list , facilitating easy message injection . `` - > '' , `` * > '' , `` \ ' > '' , `` \ '' > '' , `` $ > '' , `` ( > '' , `` host= '' + self.pg_host self.tok_pre_port + self.tok_port + \ psql.ofilter ( b '' \r\n\x1b [ ? 2004l\r '' ) # no syntax error analysis : psql.ofilter ( b ' ; ' ) match_rev_prompt_end : ParserElement = self.tok_rev_prompt_end return has_new_prompt assert p.parse_last_found_stmt ( case_query_with_newline ) == \ pg_pass : str , assert psql._intercept ( b'\x1b [ ? 2004l\r order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004htest_db= # ' ) == \ psql.ofilter ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 100\x1b [ 27m ; \x08\x08\x08\x08\x08\x08 '' ) name . psql._intercept ( b '' \x1b [ A\rtest_db= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; \x1b [ K\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\r\n\r '' ) psql.ofilter ( b'\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) psql._intercept ( b'FROM ' ) f.write ( str ( e.explain ( ) ) + `` \n '' ) columns def ifilter ( self , input : bytes ) - > bytes : from typing import Optional except ParseException as e : | ( # or continue \x1b [ ? .. [ ' # = ' ] . def __init__ ( new_output : bytes = self._replace_prompt ( latest_output ) # as interesting things usually are at end of a long string . printable.translate ( str.maketrans ( `` '' , `` '' , stmt_end ) ) ) - > str : StringEnd ( ) from typing import Optional psql._intercept ( b'\x08\x08 ' ) def parse_last_found_stmt ( self , psql : str ) - > str : deepcopy ( self.pyte_screen ) ) self.parser.parse_syntax_error ( potential_future_contents ) # cheaper and easier to reverse & start from the end # % # = # , > from .psqlconninfo import PsqlConnInfo : param hook_semantic_f : is a callback to which scraped SQL queries are\ # for optimization reasons , check output only if len ( ) > 1 , so keyboard psql._intercept ( b'SELECT ' ) [ `` > = '' ] from copy import deepcopy assert p.parse_last_stmt ( case_select_then_insert ) == \ Word ( nums ) psql.ofilter ( case_query_1 ) from .psqlparser import PsqlParser evaluation has ended . ) if self.debug : : returns : an empty list if no presses are found . \ # This will match against `` % R % x % # `` , e.g `` - > `` . # SELECT in subquery Char , res_list = prompt_res.as_list ( ) output : bytes pg_port : str , from functools import reduce return ( # * FROM orders WHERE order_total_eur = 100 ; '' # % x = nothing , * , ! , ? c = pexpect.spawn ( `` psql `` + bytes.decode ( self.psql_args ) , # ( Literal ( '- ' ) | Literal ( ' * ' ) | Literal ( '\ '' ) | # semantic analysis : from .psqlconninfo import PsqlConnInfo split_prompt [ 1 ] , assert psql.ofilter ( case_query_2_prompt ) == \ psql._intercept ( b '' '\r ( reverse-i-search ) ` ' : `` ) | Literal ( `` \x08\r\n '' [ : :-1 ] ) results = magical_return_res.as_list ( ) tok_rev_prompt_end : ParserElement = Combine ( match_select_stmt : ParserElement = ( demultilined_res = no_newlines_res\ self.pg_port , new_output : bytes = self._check_and_act_on_repl_output ( output ) return `` '' # No semantic errors found ZeroOrMore , assert p.parse_new_prompt ( case_mixed_results ) == \ # should convert \n - > `` `` to avoid `` SELECT * FROM .. '' . hook_f : Callable [ [ str ] , str ] , parser : PsqlParser ) : e.explain ( ) ) Literal ( `` \r\n\x1b [ ? 2004l\r '' [ : :-1 ] ) : param psql : screenscraped psql string res_list [ 0 ] [ : :-1 ] def _check_psql_version ( self ) - > str : # Replacing \n 's with `` `` seems to have less edge cases . self.pg_host , `` `` '' Check PostgreSQL version via psql child process and match \ stmt_res_list [ length - 4 ] ) : stmt_res_list [ length - 4 ] ] return new_output match_rev_any_sql_stmt : ParserElement = \ c = pexpect.spawn ( passed to , and from which corresponding semantic warning messages are \ self.pg_user , wrapper ) . `` psql `` assert p.output_has_new_prompt ( case_trivial ) split_prompt [ 0 ] + `` \r\n '' otherwise a warning message . # `` pgdb= > SELECT * FROM orders WHERE order_tot # either by only having single element , or using Combine to squash ) # should parse as \n - > `` '' psql._intercept ( b'\x1b [ ? 2004l\r\x1b [ ? 1049h\x1b=\r order_id | order_total_eur | customer_id \x1b [ m\r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\x1b [ m\r\n 1 | 535.36 | 111\x1b [ m\r\n 2 | 409.80 | 217\x1b [ m\r\n 3 | 189.43 | 19\x1b [ m\r\n 4 | 144.14 | 157\x1b [ m\r\n 5 | 582.52 | 172\x1b [ m\r\n 6 | 132.85 | 206\x1b [ m\r\n 7 | 183.92 | 236\x1b [ m\r\n 8 | 424.80 | 244\x1b [ m\r\n 9 | 519.43 | 175\x1b [ m\r\n 10 | 414.55 | 234\x1b [ m\r\n 11 | 88.19 | 50\x1b [ m\r\n 12 | 591.72 | 143\x1b [ m\r\n 13 | 503.52 | 216\x1b [ m\r\n 14 | 586.06 | 181\x1b [ m\r\n 15 | 47.79 | 248\x1b [ m\r\n 16 | 330.92 | 130\x1b [ m\r\n 17 | 302.31 | 225\x1b [ m\r\n 18 | 438.38 | 26\x1b [ m\r\n 19 | 107.53 | 94\x1b [ m\r\n 20 | ' self.tok_pre_host + self.tok_host ParseResults , return prompt # prompt is malformed and is returned as-is . line.rstrip ( ) for line in self.pyte_screen.display ) ) assert p.parse_magical_return ( case_long_return ) == \ stmt_res_list [ 2 ] , psql._intercept ( case_psql_start ) ParserElement.setDefaultWhitespaceChars ( `` ) to and from which semantic error messages are received in return . `` `` '' Parse for an empty prompt , to detect when a query \ from .psqlwrapper import PsqlWrapper has_new_prompt : bool = False # asterisk unpacks the 5-tuple match_psql_conninfo : ParserElement = ( match_rev_prompt_end : ParserElement = \ stmt_res : ParseResults = None `` `` '' Parse for an empty prompt and everything preceding it \ # should convert \n - > `` '' to avoid `` order_tot al_eur '' # Implied expression ParseException , def output_has_new_prompt ( self , psql : str ) - > bool : : returns : if user has hit return . .replace ( db_name + `` - # '' , `` '' ) psql._intercept ( b'\x08\x08\x08\x08\x08\x08 ' ) `` - ? # '' , `` * ? # '' , `` \ ' ? # '' , `` \ '' ? # '' , `` $ ? # '' , `` ( ? # '' , results = [ `` , match_version_stmt : ParserElement = ( debug : bool = False if stmt_res is not None : analysis_result = \ assert p.output_has_magical_return ( case_long_return ) # ORDER BY in subquery : param hook_f : is a callback to which scraped SQL queries are passed \ output to pyte screen for future screen-scraping . `` `` '' User input filter function for pexpect.interact : not used . Stream ( potential_future_screen ) stmt_res_list [ length - 3 ] , Word ( self.prompt_chars ) + \ magical_return_res = \ Literal ( `` ? [ \x1b '' ) # in this case control code parameter self.pg_pass , ( StringEnd ( ) # output may stop at end of db name , return results match_rev_any_sql_stmt [ `` \rl4002 ? [ \x1b\n\r '' ] is expected , or otherwise no injection is made . match_select_stmt : ParserElement = \ Literal , Word , \ results = [ stmt_res_list [ 3 ] , analysis_result = ImpliedExpressionChecker ( psql.ofilter ( b'\x08order_total_eur = 0 AND order_total_eur = 10\x1b [ C\x1b [ 1P ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) `` port= '' + self.pg_port Opt , conn White , def main ( ) - > None : lambda syntax_error_analysis : `` '' , psql._intercept ( b'\r\x1b [ C ' ) with psycopg.connect ( results = [ stmt_res_list [ length - 3 ] , intercepted output . '' '' '' str ( self.supported_psql_versions ) sem_router = SemanticRouter ( * conn_info ) version_msg = self._check_psql_version ( ) def output_has_magical_return ( self , psql : str ) - > bool : identbodychars , nums psql._intercept ( b'\r\n\x1b [ ? 2004l\r ' ) # feed query to semantic analysis hook function # save a potential warning to be included in before next fresh prompt . # breaks , because both of these work right in straight psql . See : # ORDER BY in subquery ParseResults , ParserElement , StringEnd , White , Word , ZeroOrMore , \ # tok , or token , is parsing element with only single element output , psql._intercept ( b'\x08order_total_eur = 0 AND order_total_eur = 1\x1b [ 1P00 ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) self.match_rev_magical_returns.parse_string ( psql_rev ) new_output = self._replace_prompt ( latest_output ) lambda x , y : x + y , sys.argv [ 1 : ] , `` '' ... : returns : if output has a weird Return press . ) : print ( e.explain ( ) ) ZeroOrMore ( White ( ) ) + CaselessLiteral ( `` SELECT '' ) match_psql_conninfo : ParserElement = \ self.pg_user , CaselessLiteral ( `` SELECT '' ) PsqlParser ( ) self.semantic_analyze : Callable [ [ str ] , str ] = hook_semantic_f Literal ( `` \r\n\x1b [ ? 2004l\r '' [ : :-1 ] ) \ from shutil import get_terminal_size # Parsing functions common to more than 1 parsing functions are listed here # TODO ( ? ) : We may have to match for errors def get ( self ) - > ( str , str , str , str , str ) : results = [ ) unreversed_flattened_res : str = \ # If there is a fresh prompt : tok_rev_prompt_end : ParserElement = \ # for simplicity , just use pexpect here prompt_res : ParseResults = None psql._intercept ( b'\x08order_total_eur = 0 AND order_total_eur = 10\x1b [ C\x1b [ 1P ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) qep_analysis : QEPAnalysis = QEPParser ( conn=conn ) .parse ( sql_query ) # Wildcards without LIKE if self.pg4n_message ! = `` '' : # Implied expression Only one ( static ) class instance is intended for use in program . demultilined_res = demultilined_res.replace ( prompt , `` '' ) output to pyte screen for screenscraping . # keyboard input does not trigger parsing f = open ( `` psqlparser.log '' , `` a '' ) psql.ofilter ( b '' \x08\x08\x08= ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m=\x1b [ 27m 100 ; \x08\x08\x08\x08\x08\x08 '' ) self.analyze : Callable [ [ str ] , str ] = hook_f psql._intercept ( return_press_1 ) psql = PsqlWrapper ( assert p.parse_last_stmt ( case_multiple_queries_and_whitespaces ) == \ # command-line arguments prevent interactive sessions ( e.g pg4n -- help ) if prompt_res : # To save time , since linebreak prompts are only removed , match_rev_any_sql_stmt : ParserElement = ( psql._intercept ( b'SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; ' ) analysis_result = SubqueryOrderByChecker ( sys.argv [ 1 ] .encode ( `` utf-8 '' ) , `` password= '' + self.pg_pass psql.ofilter ( b '' \x1b [ A\rtest_db= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; \x1b [ K\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\r\n\r '' ) ParserElement , tok_stmt_end : ParserElement = \ and then starting the session . '' '' '' psql.ofilter ( b'\x08order_total_eur = 0 AND order_total_eur = 1\x1b [ 1P00 ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) psql.ofilter ( b'FROM ' ) print ( e.explain ( ) ) from .semanticrouter import SemanticRouter psql.ofilter ( return_press_1 ) Combine , dimensions= ( self.rows , self.cols ) ( StringEnd ( ) | ( Literal ( `` ? [ \x1b '' ) self.pg_tuple : Optional [ Tuple [ str , str , str , str , str ] ] = None : returns : a prompt with injected message . ) as conn : self.syntax_analyze : Callable [ [ str ] , str ] = hook_syntax_f sanitized_sql : exp.Expression = sql_parser.parse_one ( sql_query ) ( Literal ( '= ' ) | Literal ( '^ ' ) ) has_new_prompt = True child process , initializing semantic analysis and wrapper modules , \ def run_analysis ( self , sql_query : str ) - > str : # Comparing different domains return `` '' # No semantic errors found def run_analysis ( psql.ofilter ( b'\x1b [ ? 2004l\r\x1b [ ? 2004htest_db- # ' ) analysis_result : Optional [ str ] = None List is empty if no fresh prompt was found . Combine ( res_list [ 1 ] [ : :-1 ] + res_list [ 0 ] [ : :-1 ] split_prompt : List [ str ] = \ potential_future_screen_output_sink = \ version_msg = self.check_psql_version ( ) return `` '' # ( Literal ( ' # ' ) | Literal ( ' > ' ) ) ) expected . # and save resulting message bytes.decode ( prompt , `` utf-8 '' ) ) - > Optional [ Tuple [ str , str , str , str , str ] ] : | Literal ( `` \r\n\r\r\n '' [ : :-1 ] ) self.pg_port , : returns : a two-part list with everything before the prompt \ f.close ( ) psql.ofilter ( b ' * ' ) sem_router.run_analysis , tok_rev_error self.pg4n_message = `` '' tok_marker_caret parser : PsqlParser # an insightful syntax error message from the syntax analysis . tok_rev_prompt_end if conn_info is not None : return unreversed_flattened_res against versions pg4n is tested with . prompt = db_name + multiline_prompt_end `` password= '' + self.pg_pass ) as conn : f.write ( '\n'.join ( ... + StringEnd ( ) ) ) ] reduce ( # Combine ( psql.start ( ) match_rev_magical_returns : ParserElement = ( ] pg_port : str , : param hook_syntax_f : is a callback to which scraped syntax error \ `` `` '' Start psql process and then start feeding hook function with \ # ^either stops after dbname or includes \x1b [ ? 2004l ... if self.parser.parse_magical_return ( identbodychars , has_magical_return : bool = False hook_syntax_f : Callable [ [ str ] , str ] , nums # for matching . # match_error : ParserElement = \ : param psql_args : are the command-line arguments pg4n has been called \ def get ( # TODO/BUG : removing \n 's is a tough problem , see : prompt_res = match_rev_prompt_and_then_rest.parse_string ( psql_rev ) # ParserElement for these would look this : dimensions= ( self.rows , self.cols ) ) # prompt2 per bin/psql/prompt.c : new_output : bytes = self.check_and_act_on_repl_output ( output ) ZeroOrMore ( Char ( `` \n '' ) | Char ( `` \r '' ) | White ( ) ) + \ # Reversing happens for performance reasons , self.tok_pre_port + self.tok_port assert p.parse_last_found_stmt ( case_empirical_1 ) == \ 5-tuple or None . psql_args : bytes , # feed query to hook function and save resulting message # Psql is not connecting to any database , psql._intercept ( b'\x08\x08\x08\x08 ' ) def _intercept ( # `` \r\n\x1b [ ? 2004l\r '' , `` \r\n\r\r\n '' and `` \x08\r\n '' . # If we have a semantic error message waiting def __init__ ( self , def parse_last_stmt ( self , psql : str ) - > str : # from functools import reduce assert p.parse_last_found_stmt ( case_select_then_select ) == \ # Replacing \n 's has some edge cases where wrapper transparency Word ( self.prompt_chars ) `` - * > '' , `` * * > '' , `` \ ' * > '' , `` \ '' * > '' , `` $ * > '' , `` ( * > '' , magical_return_res : ParseResults = None `` dbname= '' + self.pg_name '' , pg_host : str , assert p.parse_last_stmt ( case_multiline_query ) == \ PsqlParser ( ) ) psql.ofilter ( b'\x08\x08\x08\x08 ' ) columns : list [ Column ] = sql_parser.get_query_columns ( sanitized_sql ) return ( self.pg_host , magical_return_res = \ from .psqlparser import PsqlParser sql_query , ) line.rstrip ( ) for line in potential_future_screen.display pg_pass : str , magical_return_res : Optional [ ParseResults ] = None | Literal ( `` \r\n\r\r\n '' [ : :-1 ] ) \ analysis_result = InconsistentExpressionChecker ( # `` = > SELECT * FROM orders WHERE order_tot reduce ( lambda x , y : x + y [ : :-1 ] , results , `` '' ) ParserElement.setDefaultWhitespaceChars ( `` '' ) # % R = = , ^ assert psql.ofilter ( b'\x1b [ ? 2004htest_db= # ' ) == \ # Based on exploratory testing , screen : str = '\n'.join ( if split_prompt == [ ] : name . '' '' '' assert p.parse_last_found_stmt ( case_select_then_insert ) == \ pg_name : str if analysis_result is not None : ZeroOrMore ( White ( ) ) + tok_stmt_end + ... + \ no_newlines_res = reversed_flattened_res.replace ( '\n ' , ' ' ) columns : list [ Column ] = sql_parser.get_query_columns ( sanitized_sql ) from .psqlwrapper import PsqlWrapper import sys psql.ofilter ( b'\x08\x08\x08\x08\x08\x08 ' ) self.tok_rev_prompt_end + \ print ( bytes.decode ( psql_output.before ) ) new_output : bytes = `` '' results = prompt_res.as_list ( ) stmt_res_list = stmt_res.as_list ( ) # SUM/AVG ( DISTINCT ) import pexpect psql._intercept ( b '' \x08\x08\x08= ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m=\x1b [ 27m 100 ; \x08\x08\x08\x08\x08\x08 '' ) ... # has already been parsed as prompt_chars prompt_res = match_rev_prompt_and_then_rest.parse_string ( psql_rev ) import os Opt ( White ( ) ) ... control codes and newlines ( without carriage returns ) . from .semanticrouter import SemanticRouter def __init__ ( self , psql_args : bytes , screen : str = \ return new_output has_magical_return = True for multiline_prompt_end in self.multiline_prompt_ends : match_version_stmt : ParserElement = \ lambda x : `` '' , assert psql._intercept ( b'\x1b [ ? 2004htest_db= # ' ) == \ : returns : ( hostname , port , user , password , database name ) \ match_rev_prompt_and_then_rest : ParserElement = \ self.pg4n_message = self.analyze ( parsed_sql_query ) `` `` '' Parse for weird Return presses . res_list = prompt_res.as_list ( ) # optimization : do not spend time parsing if there is no message : # 'rev ' in variable names is shorthand for reversed . Otherwise has newline text . received in return . print ( `` Fatal error : psql connection info could not be parsed\n '' to 2 cells . psql_rev = psql [ : :-1 ] psql.ofilter ( b'\x1b [ ? 2004l\r\x1b [ ? 1049h\x1b=\r order_id | order_total_eur | customer_id \x1b [ m\r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\x1b [ m\r\n 1 | 535.36 | 111\x1b [ m\r\n 2 | 409.80 | 217\x1b [ m\r\n 3 | 189.43 | 19\x1b [ m\r\n 4 | 144.14 | 157\x1b [ m\r\n 5 | 582.52 | 172\x1b [ m\r\n 6 | 132.85 | 206\x1b [ m\r\n 7 | 183.92 | 236\x1b [ m\r\n 8 | 424.80 | 244\x1b [ m\r\n 9 | 519.43 | 175\x1b [ m\r\n 10 | 414.55 | 234\x1b [ m\r\n 11 | 88.19 | 50\x1b [ m\r\n 12 | 591.72 | 143\x1b [ m\r\n 13 | 503.52 | 216\x1b [ m\r\n 14 | 586.06 | 181\x1b [ m\r\n 15 | 47.79 | 248\x1b [ m\r\n 16 | 330.92 | 130\x1b [ m\r\n 17 | 302.31 | 225\x1b [ m\r\n 18 | 438.38 | 26\x1b [ m\r\n 19 | 107.53 | 94\x1b [ m\r\n 20 | ' analysis_result = SumDistinctChecker ( match_error_statement : ParserElement = ( version_info = pexpect.spawn ( `` `` '' psql.ofilter ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 10\x1b [ 27m0 ; \x08\x08\x08\x08\x08\x08 '' ) : param psql : screen-scraped psql output . # psqlwrapper.log ( capturing terminal stream ) in working directory return analysis_result self.pg_name ) self.tok_pre_user + self.tok_user + \ results : list [ str ] = [ ]","['src/pg4n/main.py', 'src/pg4n/psqlconninfo.py', 'src/pg4n/psqlparser.py', 'src/pg4n/psqlwrapper.py', 'src/pg4n/semanticrouter.py', 'src/pg4n/test/test_psqlparser.py', 'src/pg4n/test/test_psqlwrapper.py']",2022-11-04 12:12:28+00:00,2022-11-04 14:51:56+00:00,2022-12-12 14:47:03+02:00
55,f0c8da964af2e49927972c237584994b8aca901b,0.0002206778735853,0,,Detect subquery that does n't use its select columns ( e29 per Brass ),Merge pull request # 57 from Project-C-SQL/feat/subquery-orderby,"insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 29 , 217.18 , 124 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 104 , 97.04 , 11 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 88 , 210.95 , 158 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 1 , 535.36 , 111 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 202 , 'Sonja ' , 'Pentycross ' , ' B ' , 'Carthaette ' ) ; WHERE c.customer_id = o.customer_id ) ; '' '' '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 172 , 15.3 , 30 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 207 , 'Elise ' , 'Kamenar ' , ' C ' , 'Caswell ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 41 , 158.78 , 145 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 12 , 'Tiffi ' , 'Riolfo ' , ' C ' , 'Ada ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 205 , 'Orlan ' , 'Kynder ' , ' C ' , 'Cassandra ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 248 , 321.97 , 195 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 242 , 356.69 , 244 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 210 , 332.45 , 47 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 79 , 94.87 , 194 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 118 , 23.96 , 195 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 1 , 'Josi ' , 'Grimsell ' , ' B ' , 'Aaron ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 68 , 73.27 , 189 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 117 , 23.13 , 46 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 155 , 274.14 , 151 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 60 , 'Sibyl ' , 'Thoms ' , ' C ' , 'Almira ' ) ; sql.find_all ( insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 197 , 'Missie ' , 'Fealty ' , ' C ' , 'Carol ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 42 , 561.85 , 222 ) ; parsed_sql = sql_parser.parse_one ( sql_statement ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 112 , 38.97 , 239 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 187 , 271.52 , 242 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 83 , 451.45 , 203 ) ; , PRIMARY KEY ( order_id ) import sqlglot.expressions as exp insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 27 , 'Callean ' , 'Werlock ' , ' C ' , 'Aileen ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 183 , 546.08 , 88 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 36 , 'Bendite ' , 'Morfett ' , ' B ' , 'Aleksandr ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 198 , 'Kellby ' , 'Threlfall ' , ' C ' , 'Carolann ' ) ; ) parsed_sql = sqlparser.parse ( sql_statement ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 201 , 411.07 , 202 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 20 , 'Robbi ' , ' O '' Caherny ' , ' B ' , 'Adelphia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 179 , 'Daphne ' , 'Kells ' , ' C ' , 'Broderick ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 248 , 'Norby ' , 'Biernacki ' , ' C ' , 'Clementine ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 173 , 297.4 , 85 ) ; # everything . This check is left here for documentation of one such case . insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 166 , 95.01 , 189 ) ; print ( `` SQL_MULTIPLE_INNER_ORDERS '' ) `` `` '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 97 , 'Germain ' , 'Haly ' , ' B ' , 'Archilles ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 96 , 'Tiertza ' , 'Bunford ' , ' C ' , 'Archibald ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 119 , 579.12 , 43 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 97 , 313.39 , 241 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 135 , 574.1 , 222 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 169 , 'Elsbeth ' , 'Nucciotti ' , ' B ' , 'Bradley ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 174 , 'Carolyn ' , 'Quinlan ' , ' C ' , 'Brian ' ) ; from pytest_postgresql import factories insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 110 , 144.28 , 59 ) ; CUSTOMERS_TABLE_NAME = `` inner_orderby_test_table_customers '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 80 , 17.1 , 21 ) ; `` `` '' def __init__ ( self , parsed_sql : exp.Expression , qep_analysis : QEPAnalysis ) : ORDER BY o.customer_id ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 227 , 189.25 , 230 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 198 , 120.47 , 95 ) ; # Gets all the non-root select statements insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 4 , 'Nancey ' , 'Fawlkes ' , ' C ' , 'Abel ' ) ; FROM { ORDERS_TABLE_NAME } o2 insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 152 , 'Towny ' , 'Middell ' , ' B ' , 'Bert ' ) ; _test ( True , STATEMENT_OUTER_ORDER_WITH_INNER_ORDER , db_name ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 56 , 'Kaitlin ' , 'Payle ' , ' B ' , 'Allyson ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 194 , 'Corilla ' , 'Aldwinckle ' , ' C ' , 'Carmellia ' ) ; _test ( True , STATEMENT_WITHOUT_OUTER_ORDER , db_name ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 222 , 416.65 , 59 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 223 , 200.44 , 47 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 114 , 339.9 , 108 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 2 , 'Tomlin ' , 'Nozzolinii ' , ' B ' , 'Abbigail ' ) ; self.qep_analysis.root.rfindval ( `` Node Type '' , `` Sort '' ) ) > 0 insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 90 , 169.25 , 30 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 11 , 'Amby ' , 'Ligoe ' , ' C ' , 'Absalom ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 63 , 'Gratia ' , 'Moss ' , ' B ' , 'Althea ' ) ; import sys insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 70 , 'Carmela ' , 'Sedgeworth ' , ' C ' , 'Amos ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 104 , 'Timofei ' , 'Grene ' , ' B ' , 'Armena ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 115 , 351.68 , 153 ) ; assert checker is not None insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 171 , 175.72 , 249 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 47 , 'Tracey ' , 'Sauvan ' , ' B ' , 'Alice ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 102 , 158.53 , 220 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 63 , 542.48 , 52 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 76 , 281.92 , 183 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 62 , 418.98 , 60 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 134 , 296.72 , 222 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 120 , 454.18 , 214 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 239 , 327.06 , 34 ) ; print ( `` SQL_WITHOUT_OUTER_ORDER '' ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 25 , 83.54 , 79 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 40 , 33.89 , 23 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 195 , 504.28 , 117 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 34 , 64.76 , 13 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 109 , 'Marquita ' , 'Impy ' , ' B ' , 'Aron ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 151 , 'Prentiss ' , 'Filby ' , ' B ' , 'Berney ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 216 , 'Elsbeth ' , 'MacGaughie ' , ' B ' , 'Charles ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 225 , 'Egbert ' , 'Vasyunin ' , ' B ' , 'Chloe ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 69 , 'Maryjo ' , 'Pink ' , ' C ' , 'Amelia ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 241 , 296.03 , 169 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 111 , 490.85 , 191 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 161 , 184.39 , 94 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 72 , 539.87 , 62 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 195 , 'Dewey ' , 'Bottom ' , ' C ' , 'Carmelo ' ) ; FROM orders o insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 80 , 'Petey ' , 'Colloby ' , ' B ' , 'Ann ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 222 , 'Hazel ' , 'Rushforth ' , ' C ' , 'Chester ' ) ; SQL_MULTIPLE_INNER_ORDERS = \ insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 238 , 448.86 , 16 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 53 , 'Riva ' , 'Scawen ' , ' C ' , 'Allen ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 145 , 112.51 , 162 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 58 , 'Lettie ' , 'Coffin ' , ' B ' , 'Almena ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 73 , 144.33 , 52 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 59 , 'Lin ' , 'Race ' , ' B ' , 'Almina ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 209 , 203.86 , 244 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 203 , 545.33 , 116 ) ; , PRIMARY KEY ( customer_id ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 127 , 451.77 , 17 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 113 , 'Dania ' , 'Foxton ' , ' C ' , 'Arthusa ' ) ; WHERE EXISTS ( ORDERS_TABLE_NAME = `` inner_orderby_test_table_orders '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 146 , 184.13 , 22 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 170 , 539.11 , 92 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 94 , 'Halimeda ' , 'Freak ' , ' B ' , 'Arabelle ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 148 , 'Lidia ' , 'Quinane ' , ' C ' , 'Benjamin ' ) ; , nickname VARCHAR ( 20 ) NOT NULL insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 100 , 424.83 , 50 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 81 , 'Sharline ' , 'Rosenwald ' , ' B ' , 'Anna ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 213 , 329.78 , 105 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 137 , 417.16 , 215 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 231 , 'Calhoun ' , 'BoHlingolsen ' , ' C ' , 'Christina ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 31 , 394.48 , 62 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 15 , 47.79 , 248 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 167 , 'Ninnette ' , 'Steere ' , ' C ' , 'Brad ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 17 , 'Carlyle ' , 'Zimek ' , ' B ' , 'Adelbert ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 235 , 'Justus ' , 'Barthrup ' , ' B ' , 'Christy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 142 , 509.25 , 190 ) ; conn : Connection = psycopg.connect ( * * kwargs ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 220 , 367.15 , 163 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 220 , 'Kylen ' , 'Bewicke ' , ' B ' , 'Cheryl ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 180 , 'Leonelle ' , 'Chiommienti ' , ' B ' , 'Caitlin ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 52 , 81.47 , 212 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 90 , 'Forest ' , 'Trim ' , ' B ' , 'Appoline ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 221 , 'Cassondra ' , 'Mattingson ' , ' B ' , 'Chesley ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 8 , 424.8 , 244 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 229 , 89.34 , 147 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 21 , 'Nady ' , 'Lempertz ' , ' B ' , 'Adolphus ' ) ; has_orderby = self.parsed_sql.find ( exp.Order ) is not None insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 67 , 550.21 , 63 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 103 , 'Ede ' , 'Golden of Ireland ' , ' C ' , 'Armanda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 89 , 556.68 , 74 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 162 , 168.92 , 27 ) ; SQL_OUTER_ORDER_WITH_INNER_ORDER = \ CHECK ( type IN ( ' C ' , ' B ' ) ) -- C = customer , B = business # assert warning_msg is not None insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 76 , 'Ardys ' , 'Currm ' , ' B ' , 'Andriane ' ) ; cur.execute ( insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 247 , 'Dulcie ' , 'Crutchley ' , ' B ' , 'Clement ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 163 , 61.42 , 69 ) ; SELECT * def load_database ( * * kwargs ) : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 182 , 'Sasha ' , 'Stiffkins ' , ' C ' , 'Caldonia ' ) ; sql_statement = SQL_OUTER_ORDER_WITH_INNER_ORDER insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 49 , 'Theodosia ' , 'Rosson ' , ' B ' , 'Aline ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 55 , 'Terrill ' , 'Syde ' , ' B ' , 'Allison ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 5 , 'Callida ' , 'Tomasello ' , ' B ' , 'Abiel ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 154 , 291.52 , 54 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 191 , 'Frankie ' , 'Canny ' , ' B ' , 'Candace ' ) ; ORDER BY o2.customer_id ) AS o insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 10 , 'Sonnie ' , 'Kelling ' , ' B ' , 'Abram ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 68 , 'Leisha ' , 'Darlington ' , ' C ' , 'Ambrose ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 212 , 179.55 , 180 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 226 , 212.04 , 28 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 229 , 'Melessa ' , 'MacAleese ' , ' C ' , 'Christiana ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 140 , 'Suki ' , 'Flinn ' , ' B ' , 'Bea ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 88 , 'Sansone ' , 'Copsey ' , ' C ' , 'Antonia ' ) ; STATEMENT_WITHOUT_OUTER_ORDER = \ insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 224 , 293.35 , 186 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 50 , 'Anne-marie ' , 'Mounsie ' , ' B ' , 'Alison ' ) ; should never give false positives , only false negatives . insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 204 , 'Cassy ' , 'Pearcehouse ' , ' C ' , 'Casper ' ) ; load= [ load_database ] , insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 188 , 'Ferguson ' , 'Mackriell ' , ' B ' , 'Cameron ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 48 , 'Marve ' , 'Eykel ' , ' C ' , 'Alicia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 208 , 'Legra ' , 'Drought ' , ' C ' , 'Catherine ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 249 , 'Rhoda ' , 'Leheude ' , ' C ' , 'Cliff ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 77 , 'Maegan ' , 'Wheldon ' , ' C ' , 'Angela ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 181 , 'Daria ' , 'Wistance ' , ' C ' , 'Caitlyn ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 156 , 'Allistir ' , 'Frary ' , ' C ' , 'Beth ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 72 , 'Nadiya ' , 'Gingles ' , ' B ' , 'Anderson ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 7 , 183.92 , 236 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 7 , 'Lorin ' , 'Dollimore ' , ' C ' , 'Abijah ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 79 , 'Preston ' , 'Groves ' , ' B ' , 'Angelina ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 144 , 504.73 , 154 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 219 , 594.84 , 121 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 141 , 183.27 , 44 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 217 , 'Lucy ' , 'Durtnell ' , ' C ' , 'Charlie ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 140 , 297.41 , 101 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 215 , 'Nollie ' , 'Jemmett ' , ' B ' , 'Charity ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 85 , 404.96 , 79 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 27 , 137.86 , 21 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 240 , 384.87 , 107 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 115 , 'Shirl ' , 'Pilpovic ' , ' C ' , 'Asahel ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 96 , 311.78 , 173 ) ; STATEMENT_NESTED_SUBQUERY_INNER_ORDER = \ insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 206 , 226.62 , 228 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 155 , 'Murdock ' , 'Dix ' , ' C ' , 'Bess ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 38 , 366.31 , 59 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 19 , 107.53 , 94 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 138 , 'Ainsley ' , 'Wraighte ' , ' C ' , 'Barticus ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 176 , 'Marylou ' , 'Guilloton ' , ' C ' , 'Bridget ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 233 , 87.21 , 179 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 177 , 334.0 , 167 ) ; CREATE TABLE { ORDERS_TABLE_NAME } ( f '' '' '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 178 , 563.08 , 161 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 30 , 'Colin ' , 'Jansie ' , ' C ' , 'Alastair ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 160 , 144.6 , 82 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 153 , 'Alfy ' , 'McCahill ' , ' B ' , 'Bertha ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 124 , 552.02 , 191 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 114 , 'Fara ' , 'Arkil ' , ' B ' , 'Arzada ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 206 , 'Ardyth ' , 'Conningham ' , ' B ' , 'Cassidy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 108 , 294.25 , 131 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 46 , 362.72 , 240 ) ; _test ( True , STATEMENT_MULTIPLE_INNER_ORDERS , db_name ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 29 , 'Dawna ' , 'Knipe ' , ' C ' , 'Alanson ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 111 , 'Torey ' , 'Sessuns ' , ' B ' , 'Artemus ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 2 , 409.8 , 217 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 112 , 'Nanci ' , 'Byrd ' , ' C ' , 'Arthur ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 126 , 384.61 , 226 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 182 , 478.47 , 70 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 81 , 490.65 , 41 ) ; lambda x : x.parent is not None , insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 197 , 529.63 , 46 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 232 , 'Maritsa ' , 'Cowpland ' , ' C ' , 'Christine ' ) ; sql_statement = SQL_WITHOUT_OUTER_ORDER insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 230 , 'Cordell ' , 'Bineham ' , ' B ' , 'Christiano ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 168 , 137.02 , 109 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 11 , 88.19 , 50 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 130 , 'Rora ' , 'Adcock ' , ' C ' , 'Babs ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 122 , 'Myrlene ' , 'Worcs ' , ' B ' , 'Augusta ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 217 , 302.24 , 189 ) ; sql_statement = SQL_MULTIPLE_INNER_ORDERS insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 151 , 221.16 , 212 ) ; CREATE TABLE { CUSTOMERS_TABLE_NAME } ( # TODO : More sophisticated check that inspects self.parsed_sql and insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 60 , 473.05 , 208 ) ; warning_msg = checker.check ( ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 23 , 236.48 , 51 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 200 , 'Fanni ' , 'Iacopetti ' , ' C ' , 'Carolyn ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 250 , 367.56 , 214 ) ; '' '' '' ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 235 , 230.72 , 168 ) ; _test ( True , STATEMENT_NESTED_SUBQUERY_INNER_ORDER , db_name ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 185 , 'Tanitansy ' , 'Headington ' , ' C ' , 'Calista ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 53 , 592.15 , 207 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 211 , 399.2 , 138 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 131 , 'Ive ' , 'Matches ' , ' B ' , 'Barbara ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 26 , 'Jenica ' , 'Martina ' , ' C ' , 'Agnes ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 202 , 99.52 , 171 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 3 , 189.43 , 19 ) ; import psycopg WHERE EXISTS ( SELECT * insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 226 , 'Emelina ' , 'Ayliff ' , ' B ' , 'Chris ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 211 , 'Jobi ' , 'Bails ' , ' B ' , 'Cecilia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 121 , 'Clywd ' , 'Stokey ' , ' B ' , 'August ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 107 , 'Celisse ' , 'Rubra ' , ' B ' , 'Arminta ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 44 , 537.56 , 2 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 149 , 'Erik ' , 'Cushe ' , ' B ' , 'Benjy ' ) ; sqlglot.exp.Select ) ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 239 , 'Atalanta ' , 'Girdler ' , ' C ' , 'Claire ' ) ; from . qepparser import QEPAnalysis insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 56 , 501.06 , 129 ) ; , customer_id INT NOT NULL from .. qepparser import QEPParser insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 31 , 'Dario ' , 'Siehard ' , ' C ' , 'Alazama ' ) ; , FOREIGN KEY ( customer_id ) # finds more warnings than postgresql . insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 61 , 343.91 , 223 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 42 , 'Pyotr ' , 'Feldhorn ' , ' C ' , 'Alexis ' ) ; print ( USAGE , file=sys.stderr ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 203 , 'Rory ' , 'Hallatt ' , ' C ' , 'Casey ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 228 , 'Rudd ' , 'Ames ' , ' B ' , 'Christian ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 61 , 'Blisse ' , 'Dillway ' , ' C ' , 'Alonzo ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 164 , 'Abel ' , 'Bezants ' , ' C ' , 'Bob ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 65 , 318.64 , 6 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 136 , 'Aretha ' , 'Arias ' , ' C ' , 'Bart ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 152 , 291.54 , 10 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 69 , 266.3 , 39 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 196 , 'Louisa ' , 'Matasov ' , ' B ' , 'Carmon ' ) ; has_sort_node = len ( insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 160 , 'Patti ' , 'Louis ' , ' C ' , 'Biddie ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 48 , 199.52 , 234 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 236 , 485.18 , 167 ) ; # This check still gives false negatives so we intentionally do n't test for qep_analysis = qep_parser ( sql_statement ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 214 , 'Chalmers ' , 'Britton ' , ' C ' , 'Celinda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 189 , 164.91 , 68 ) ; assert warning_msg is None WHERE c.customer_id = o.customer_id insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 210 , 'Pamelina ' , 'Vittery ' , ' C ' , 'Cathy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 101 , 328.66 , 189 ) ; , fname VARCHAR ( 50 ) NOT NULL SQL_NESTED_SUBQUERY_INNER_ORDER = \ return any ( [ subquery.find ( sqlglot.exp.Order ) for subquery in subqueries ] ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 62 , 'Seline ' , 'McGray ' , ' B ' , 'Alphinias ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 65 , 'Glenna ' , 'Alastair ' , ' C ' , 'Alyssa ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 75 , 'Erma ' , 'Cranstone ' , ' B ' , 'Andrew ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 231 , 51.77 , 118 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 129 , 426.3 , 136 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 66 , 'Sadella ' , 'Boxhall ' , ' B ' , 'Alzada ' ) ; qep = bytes.decode ( qep ) FROM ( SELECT * insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 37 , 'Talbot ' , 'Keddey ' , ' B ' , 'Aleva ' ) ; def qep_parser ( postgresql : Connection ) : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 98 , 177.22 , 86 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 122 , 406.1 , 80 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 204 , 212.04 , 203 ) ; This check gives misses some situations with redundant ORDER BY but insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 227 , 'Jeralee ' , 'Atwill ' , ' C ' , 'Christa ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 221 , 487.39 , 227 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 186 , 'Chloette ' , 'Ratt ' , ' B ' , 'Calpurnia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 209 , 'Dulcea ' , 'Akister ' , ' C ' , 'Cathleen ' ) ; import sqlglot from typing import Optional insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 4 , 144.14 , 157 ) ; checker = SubqueryOrderByChecker ( parsed_sql , qep_analysis ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 71 , 175.29 , 115 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 218 , 389.51 , 177 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 183 , 'Harvey ' , 'Skinn ' , ' B ' , 'Caleb ' ) ; ORDER BY o.customer_id ) ; '' '' '' postgresql = factories.postgresql ( `` factory '' ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 119 , 'Gregg ' , 'Lazenbury ' , ' B ' , 'Aubrey ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 18 , 'Odie ' , 'Rowling ' , ' C ' , 'Adele ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 236 , 'Garnette ' , 'Tabrett ' , ' C ' , 'Cicely ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 146 , 'Dunstan ' , 'Cressey ' , ' B ' , 'Bella ' ) ; def main ( ) : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 118 , 'Hermy ' , 'Whieldon ' , ' B ' , 'Ashley ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 237 , 293.23 , 140 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 224 , 'Dayle ' , 'Eirwin ' , ' B ' , 'Chick ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 199 , 376.5 , 53 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 28 , 87.44 , 1 ) ; print ( `` SQL_OUTER_ORDER_WITHOUT_INNER_ORDER '' ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 106 , 236.57 , 4 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 16 , 330.92 , 130 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 131 , 255.66 , 127 ) ; ) ; with conn.cursor ( ) as cur : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 93 , 'Sashenka ' , 'Fedorski ' , ' C ' , 'Arabella ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 103 , 14.83 , 183 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 232 , 330.85 , 204 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 94 , 406.59 , 129 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 161 , 'Barron ' , 'Dishmon ' , ' B ' , 'Bill ' ) ; return None insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 10 , 414.55 , 234 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 200 , 592.16 , 137 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 71 , 'Cynthie ' , 'Rouby ' , ' B ' , 'Anastasia ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 249 , 491.05 , 63 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 116 , 'Annmarie ' , 'Errichelli ' , ' B ' , 'Asaph ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 143 , 239.98 , 109 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 244 , 273.35 , 153 ) ; if expected ! = result : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 194 , 328.76 , 41 ) ; return warning_msg insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 245 , 327.9 , 212 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 133 , 499.73 , 235 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 142 , 'Elfrieda ' , 'Cleary ' , ' C ' , 'Becca ' ) ; FROM orders o2 f '' '' '' class SubqueryOrderByChecker : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 64 , 'Dyan ' , 'Crosbie ' , ' B ' , 'Alverta ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 67 , 'Zsazsa ' , 'Bellocht ' , ' C ' , 'Amanda ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 134 , 'Georgetta ' , 'Crossley ' , ' B ' , 'Barnabas ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 201 , 'Arv ' , 'Spawforth ' , ' B ' , 'Carrie ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 101 , 'Hamilton ' , 'Pellew ' , ' B ' , 'Arizona ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 243 , 209.34 , 31 ) ; DROP TABLE IF EXISTS { CUSTOMERS_TABLE_NAME } ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 123 , 'Lyon ' , 'Nolleau ' , ' C ' , 'Augustina ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 43 , 'Belle ' , 'Barsham ' , ' B ' , 'Alfonse ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 205 , 508.59 , 59 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 17 , 302.31 , 225 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 99 , 354.37 , 66 ) ; def _test ( expected : bool , sql_statement : str , db_name : str ) : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 176 , 22.8 , 175 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 3 , 'Christen ' , 'Culley ' , ' C ' , 'Abednego ' ) ; , type CHAR ( 1 ) NOT NULL insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 141 , 'Jacinta ' , 'Villiers ' , ' B ' , 'Beatrice ' ) ; # Does not matter all only here so we can get a connection SELECT * ORDER BY c.customer_id ; '' '' '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 167 , 547.07 , 197 ) ; STATEMENT_OUTER_ORDER_WITHOUT_INNER_ORDER = \ insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 159 , 281.36 , 198 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 102 , 'Ricca ' , 'Rupprecht ' , ' B ' , 'Arlene ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 175 , 'Davy ' , 'Blomefield ' , ' B ' , 'Brianna ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 120 , 'Corinna ' , 'Pyburn ' , ' B ' , 'Audrey ' ) ; SELECT * insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 162 , 'Jessee ' , 'List ' , ' B ' , 'Billy ' ) ; Does not use the qep so far . insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 157 , 477.53 , 205 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 52 , 'Gerrilee ' , 'Ackland ' , ' B ' , 'Allan ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 126 , 'Lilllie ' , 'Annis ' , ' C ' , 'Aurelia ' ) ; def sql_parser ( postgresql : Connection ) : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 109 , 170.82 , 206 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 24 , 'Jacinthe ' , 'Kleeman ' , ' B ' , 'Adrienne ' ) ; subqueries = filter ( warning_msg = `` Warning : ORDER BY in a subquery [ pg4n : :InnerOrderBy ] '' f '' '' '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 91 , 'Bobby ' , 'Fortesquieu ' , ' B ' , 'Aquilla ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 38 , 'Web ' , 'Catterill ' , ' B ' , 'Alex ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 51 , 244.27 , 119 ) ; FROM { CUSTOMERS_TABLE_NAME } c insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 75 , 238.65 , 203 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 184 , 'Louise ' , 'Jansey ' , ' C ' , 'California ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 54 , 'Malchy ' , 'Hearty ' , ' B ' , 'Allisandra ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 208 , 344.91 , 150 ) ; ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 137 , 'Lucilia ' , 'Bentick ' , ' C ' , 'Bartholomew ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 25 , 'Neely ' , 'Merrydew ' , ' B ' , 'Agatha ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 41 , 'Reilly ' , 'Kennler ' , ' B ' , 'Alexandria ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 93 , 452.63 , 115 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 240 , 'Britte ' , 'Muge ' , ' B ' , 'Clara ' ) ; print ( `` SQL_NESTED_SUBQUERY_INNER_ORDER '' ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 121 , 132.25 , 50 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 230 , 389.39 , 247 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 154 , 'Conney ' , 'Riteley ' , ' C ' , 'Bertram ' ) ; self.qep_analysis : QEPAnalysis = qep_analysis insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 241 , 'Sigismund ' , 'Mowsdill ' , ' B ' , 'Clare ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 132 , 'Olympe ' , 'Faber ' , ' B ' , 'Barbery ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 106 , 'Merrily ' , 'Coundley ' , ' C ' , 'Arminda ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 242 , 'Brenden ' , 'Simmons ' , ' B ' , 'Clarence ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 218 , 'Raffarty ' , 'Sweeney ' , ' C ' , 'Charlotte ' ) ; return SqlParser ( db_connection=postgresql ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 173 , 'Kristopher ' , 'Mackelworth ' , ' B ' , 'Brenda ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 187 , 'Donall ' , 'Casolla ' , ' B ' , 'Calvin ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 107 , 23.63 , 179 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 186 , 561.85 , 156 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 172 , 'Pammi ' , 'Codling ' , ' B ' , 'Breeanna ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 14 , 586.06 , 181 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 83 , 'Wolf ' , 'Brenton ' , ' B ' , 'Annette ' ) ; result = has_subquery_order_by ( parsed_sql , qep ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 98 , 'Elfreda ' , 'Tome ' , ' C ' , 'Ariadne ' ) ; ORDER BY o.customer_id ) OR insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 223 , 'Annice ' , 'Haynes ' , ' B ' , 'Chet ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 147 , 180.39 , 2 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 57 , 349.14 , 58 ) ; def has_subquery_order_by ( sql : sqlglot.exp.Expression , qep : str ) - > bool : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 129 , 'Ashla ' , 'De-Ville ' , ' C ' , 'Bab ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 45 , 46.05 , 177 ) ; , sname VARCHAR ( 50 ) NOT NULL insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 78 , 'Matilde ' , 'Froome ' , ' B ' , 'Angelica ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 212 , 'Annecorinne ' , 'Soles ' , ' B ' , 'Cedric ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 87 , 441.16 , 191 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 145 , 'Adena ' , 'Wenham ' , ' C ' , 'Belinda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 91 , 331.76 , 115 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 84 , 396.02 , 111 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 138 , 223.81 , 183 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 139 , 'Kelsi ' , 'Suddell ' , ' C ' , 'Bazaleel ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 54 , 591.44 , 145 ) ; SQL_OUTER_ORDER_WITHOUT_INNER_ORDER = \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 33 , 'Amble ' , 'Jewes ' , ' B ' , 'Alberta ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 117 , 'Marysa ' , 'Wadman ' , ' C ' , 'Asenath ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 32 , 331.93 , 144 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 234 , 'Cayla ' , 'Statter ' , ' B ' , 'Christopher ' ) ; print ( `` SQL_OUTER_ORDER_WITH_INNER_ORDER '' ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 123 , 370.87 , 115 ) ; exit ( 1 ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 165 , 84.61 , 1 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 39 , 42.62 , 95 ) ; main ( ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 188 , 495.68 , 39 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 215 , 515.79 , 96 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 192 , 'Dudley ' , 'Vesco ' , ' B ' , 'Carlotta ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 13 , 'Marion ' , 'Penelli ' , ' B ' , 'Adaline ' ) ; ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 105 , 107.29 , 12 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 125 , 'Leo ' , 'Creaney ' , ' B ' , 'Augustus ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 18 , 438.38 , 26 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 247 , 123.55 , 179 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 163 , 'Gerhardt ' , 'Simcock ' , ' B ' , 'Blanche ' ) ; print ( f '' expected : { expected } , result : { str ( result ) } '' ) ORDER BY c.customer_id ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 30 , 435.57 , 105 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 214 , 520.52 , 98 ) ; _test ( False , STATEMENT_OUTER_ORDER_WITHOUT_INNER_ORDER , db_name ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 150 , 'Agnesse ' , 'Liebmann ' , ' B ' , 'Bernard ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 33 , 140.92 , 236 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 21 , 471.12 , 179 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 28 , 'Nanice ' , 'MacMaster ' , ' B ' , 'Alan ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 144 , 'Ange ' , 'Pasterfield ' , ' C ' , 'Bedelia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 95 , 'Amandie ' , 'Botham ' , ' B ' , 'Araminta ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 128 , 415.86 , 243 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 159 , 'Carilyn ' , 'Vinecombe ' , ' B ' , 'Bezaleel ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 193 , 449.91 , 213 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 191 , 183.55 , 142 ) ; USAGE = `` usage : orderby.py < db_name > '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 113 , 305.06 , 123 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 6 , 'Daisey ' , 'Hamill ' , ' B ' , 'Abigail ' ) ; from . import sqlparser insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 87 , 'Nanette ' , 'McElwee ' , ' B ' , 'Antoinette ' ) ; DROP TABLE IF EXISTS { ORDERS_TABLE_NAME } ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 238 , 'Gregor ' , 'Crinion ' , ' B ' , 'Cindy ' ) ; EXISTS ( SELECT * insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 110 , 'Donall ' , 'Labrenz ' , ' B ' , 'Artelepsa ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 12 , 591.72 , 143 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 174 , 597.34 , 184 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 136 , 411.87 , 10 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 99 , 'Phineas ' , 'Yuryaev ' , ' B ' , 'Arielle ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 179 , 453.95 , 43 ) ; WHERE c.customer_id = o.customer_id from pprint import pprint insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 14 , 'Davon ' , 'Burris ' , ' C ' , 'Addison ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 130 , 575.58 , 235 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 193 , 'Brucie ' , 'Coning ' , ' C ' , 'Carlton ' ) ; ) OR EXISTS ( FROM customers c insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 58 , 10.24 , 74 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 156 , 130.63 , 188 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 9 , 'Lester ' , 'Markus ' , ' C ' , 'Abraham ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 150 , 439.75 , 18 ) ; FROM { ORDERS_TABLE_NAME } o insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 250 , 'Langston ' , 'Prosser ' , ' C ' , 'Clifford ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 77 , 335.23 , 149 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 125 , 170.66 , 131 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 149 , 340.62 , 215 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 177 , 'Genvieve ' , 'Marthen ' , ' B ' , 'Brittany ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 23 , 'Jeanette ' , 'Fincher ' , ' B ' , 'Adriane ' ) ; sql_statement = SQL_NESTED_SUBQUERY_INNER_ORDER insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 20 , 207.6 , 9 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 92 , 156.72 , 192 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 24 , 538.88 , 38 ) ; customer_id INT insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 233 , 'Tibold ' , 'Sleigh ' , ' C ' , 'Christoph ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 153 , 350.78 , 247 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 171 , 'Fredrick ' , 'Matuszynski ' , ' C ' , 'Breanna ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 127 , 'Rhoda ' , 'Kurton ' , ' C ' , 'Avarilla ' ) ; from .. sqlparser import SqlParser db_name = str ( sys.argv [ 1 ] ) assert warning_msg is not None insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 148 , 203.36 , 180 ) ; factory = factories.postgresql_proc ( insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 189 , 'Merle ' , 'Erridge ' , ' C ' , 'Camille ' ) ; return QEPParser ( conn=postgresql ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 57 , 'Vita ' , 'Dunnett ' , ' B ' , 'Allyssa ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 181 , 150.37 , 69 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 243 , 'Hannah ' , 'Mattheis ' , ' C ' , 'Clarinda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 139 , 441.16 , 97 ) ; otherwise None . insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 9 , 519.43 , 175 ) ; self.parsed_sql : exp.Expression = parsed_sql order_id INT insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 132 , 488.95 , 234 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 199 , 'Matilda ' , 'Malenoir ' , ' C ' , 'Caroline ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 44 , 'Buffy ' , ' O '' Cridigan ' , ' B ' , 'Alfred ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 225 , 26.43 , 228 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 185 , 505.7 , 49 ) ; conn.commit ( ) STATEMENT_MULTIPLE_INNER_ORDERS = \ print ( parsed_sql ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 108 , 'Janene ' , 'Motten ' , ' C ' , 'Arnold ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 178 , 'Rogers ' , 'Plose ' , ' B ' , 'Brittney ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 5 , 582.52 , 172 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 175 , 161.61 , 58 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 45 , 'Seymour ' , 'Mayer ' , ' B ' , 'Alfreda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 158 , 65.82 , 201 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 47 , 163.79 , 141 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 135 , 'Janenna ' , 'McCamish ' , ' C ' , 'Barney ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 37 , 322.11 , 41 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 168 , 'Melicent ' , 'Cheston ' , ' B ' , 'Bradford ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 35 , 389.81 , 218 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 43 , 133.73 , 196 ) ; import pytest insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 180 , 452.67 , 234 ) ; from psycopg import Connection insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 92 , 'Raven ' , 'Eilles ' , ' C ' , 'Ara ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 234 , 254.56 , 98 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 190 , 'Kara ' , 'Backs ' , ' B ' , 'Campbell ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 124 , 'Penelope ' , 'Quadling ' , ' C ' , 'Augustine ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 237 , 'Jeramie ' , 'Gallehock ' , ' C ' , 'Cinderella ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 184 , 380.46 , 98 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 19 , 'Daphne ' , 'Bullen ' , ' B ' , 'Adeline ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 147 , 'Wilmer ' , 'MacWhan ' , ' B ' , 'Benedict ' ) ; REFERENCES { CUSTOMERS_TABLE_NAME } ( customer_id ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 219 , 'Adriane ' , 'Ccomini ' , ' B ' , 'Chauncey ' ) ; ORDER BY o.customer_id if not has_inner_orderby : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 244 , 'Katrine ' , 'Janiak ' , ' B ' , 'Clarissa ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 133 , 'Clementia ' , 'Fergusson ' , ' B ' , 'Barbie ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 46 , 'Mechelle ' , 'Vinick ' , ' B ' , 'Algernon ' ) ; STATEMENT_OUTER_ORDER_WITH_INNER_ORDER = \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 246 , 'Albert ' , 'Heimann ' , ' B ' , 'Cleatus ' ) ; Returns warning message if there exists ORDER BY in a subquery , insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 213 , 'Rubin ' , 'Lunney ' , ' B ' , 'Celeste ' ) ; has_inner_orderby = has_orderby and not has_sort_node if len ( sys.argv ) ! = 2 : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 32 , 'Aubrie ' , 'Lockitt ' , ' C ' , 'Albert ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 22 , 193.12 , 6 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 95 , 367.31 , 48 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 59 , 141.8 , 118 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 39 , 'Tabbie ' , 'Glison ' , ' B ' , 'Alexander ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 216 , 388.15 , 142 ) ; if __name__ == `` __main__ '' : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 86 , 537.64 , 201 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 26 , 590.52 , 50 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 70 , 596.2 , 221 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 128 , 'Jere ' , 'Cometti ' , ' B ' , 'Azariah ' ) ; def check ( self ) - > Optional [ str ] : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 64 , 534.3 , 108 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 165 , 'Angele ' , 'Wildbore ' , ' C ' , 'Bobby ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 16 , 'Augustin ' , 'Blaxall ' , ' C ' , 'Adelaide ' ) ; ORDER BY o2.customer_id ) AS o , order_total_eur DECIMAL ( 6,2 ) NOT NULL insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 13 , 503.52 , 216 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 34 , 'Lorens ' , 'Buzin ' , ' C ' , 'Aldo ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 49 , 376.9 , 89 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 192 , 206.39 , 151 ) ; qep = subprocess.check_output ( [ `` psql '' , `` -X '' , `` -d '' , db_name , `` -c '' , insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 22 , 'Grazia ' , 'Syne ' , ' C ' , 'Adrian ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 74 , 'Giffy ' , 'Cottee ' , ' C ' , 'Andrea ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 164 , 193.39 , 169 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 6 , 132.85 , 206 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 116 , 292.86 , 97 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 86 , 'Lauren ' , 'Tolworth ' , ' B ' , 'Anthony ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 50 , 306.71 , 235 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 166 , 'Angelo ' , 'Vanstone ' , ' C ' , 'Boetius ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 35 , 'Lainey ' , 'Davidow ' , ' C ' , 'Aldrich ' ) ; from .. subquery_orderby_checker import SubqueryOrderByChecker FROM ( SELECT * insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 143 , 'Sasha ' , 'Eunson ' , ' C ' , 'Beck ' ) ; sql_statement = SQL_OUTER_ORDER_WITHOUT_INNER_ORDER # False negative : dont assert WHERE c.customer_id = o.customer_id ) def test_inner_orderby ( sql_parser : SqlParser , qep_parser : QEPParser ) : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 100 , 'Gypsy ' , 'Bottrell ' , ' C ' , 'Aristotle ' ) ; SQL_WITHOUT_OUTER_ORDER = \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 73 , 'Seymour ' , 'Maffioletti ' , ' B ' , 'Andre ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 170 , 'Bard ' , 'Shaw ' , ' C ' , 'Brady ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 74 , 63.02 , 117 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 84 , 'Birk ' , 'Malling ' , ' C ' , 'Annie ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 89 , 'Nickie ' , 'Bloss ' , ' C ' , 'Antonio ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 36 , 225.6 , 136 ) ; import subprocess insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 190 , 401.19 , 88 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 85 , 'Brig ' , 'Triswell ' , ' C ' , 'Anselm ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 246 , 510.74 , 188 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 245 , 'Holly ' , 'Roy ' , ' C ' , 'Claudia ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 228 , 542.3 , 42 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 15 , 'Zachary ' , 'Faloon ' , ' C ' , 'Adela ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 158 , 'Anett ' , 'Hercules ' , ' B ' , 'Beverly ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 8 , 'Gasparo ' , 'Bohlje ' , ' C ' , 'Abner ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 169 , 552.88 , 241 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 207 , 205.25 , 199 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 105 , 'Cary ' , 'Sells ' , ' C ' , 'Armilda ' ) ; `` `` '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 51 , 'Kennan ' , 'Burstowe ' , ' B ' , 'Alixandra ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 78 , 569.4 , 99 ) ; `` EXPLAIN ANALYZE `` + sql_statement ] ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 82 , 106.39 , 237 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 157 , 'Noach ' , 'MacRitchie ' , ' C ' , 'Bethena ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 196 , 259.0 , 244 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 82 , 'Abey ' , 'Darridon ' , ' C ' , 'Anne ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 66 , 454.41 , 11 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 55 , 391.93 , 128 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 40 , 'Olva ' , 'Leborgne ' , ' C ' , 'Alexandra ' ) ;","['src/pg4n/orderby.py', 'src/pg4n/subquery_orderby_checker.py', 'src/pg4n/test/test_subquery_orderby_checker.py']",2022-11-07 18:54:47+00:00,2022-11-08 08:07:17+00:00,2022-11-08 10:05:35+02:00
56,de27eb5c5d71e31de1e07099cbea189952749079,0.000133340654429,0,,Detect subquery condition that can be moved to the `` parent '' query ( e30 per Brass ),Merge pull request # 58 from Project-C-SQL/feat/subquery-select,"insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 29 , 217.18 , 124 ) ; sql_statement = SQL_SUBQUERY_SELECT_WITH_TOPLEVEL_CONDITIONS_SUSPICIOUS insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 104 , 97.04 , 11 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 88 , 210.95 , 158 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 1 , 535.36 , 111 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 202 , 'Sonja ' , 'Pentycross ' , ' B ' , 'Carthaette ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 172 , 15.3 , 30 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 207 , 'Elise ' , 'Kamenar ' , ' C ' , 'Caswell ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 41 , 158.78 , 145 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 12 , 'Tiffi ' , 'Riolfo ' , ' C ' , 'Ada ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 205 , 'Orlan ' , 'Kynder ' , ' C ' , 'Cassandra ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 248 , 321.97 , 195 ) ; if all ( filter ( lambda x : x not in all_subquery_column_names , insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 242 , 356.69 , 244 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 210 , 332.45 , 47 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 79 , 94.87 , 194 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 118 , 23.96 , 195 ) ; ORDERS_TABLE_NAME = `` e29_test_table_orders '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 1 , 'Josi ' , 'Grimsell ' , ' B ' , 'Aaron ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 68 , 73.27 , 189 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 117 , 23.13 , 46 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 155 , 274.14 , 151 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 60 , 'Sibyl ' , 'Thoms ' , ' C ' , 'Almira ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 197 , 'Missie ' , 'Fealty ' , ' C ' , 'Carol ' ) ; checker = SubquerySelectChecker ( parsed_sql , sql_parser ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 42 , 561.85 , 222 ) ; parsed_sql = sql_parser.parse_one ( sql_statement ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 112 , 38.97 , 239 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 187 , 271.52 , 242 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 83 , 451.45 , 203 ) ; , PRIMARY KEY ( order_id ) FROM { ORDERS_TABLE_NAME } insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 27 , 'Callean ' , 'Werlock ' , ' C ' , 'Aileen ' ) ; import sqlglot.expressions as exp insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 183 , 546.08 , 88 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 36 , 'Bendite ' , 'Morfett ' , ' B ' , 'Aleksandr ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 198 , 'Kellby ' , 'Threlfall ' , ' C ' , 'Carolann ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 201 , 411.07 , 202 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 20 , 'Robbi ' , ' O '' Caherny ' , ' B ' , 'Adelphia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 179 , 'Daphne ' , 'Kells ' , ' C ' , 'Broderick ' ) ; column_exps = select_expression.find_all ( exp.Column ) customer_id in ( SELECT order_id insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 248 , 'Norby ' , 'Biernacki ' , ' C ' , 'Clementine ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 173 , 297.4 , 85 ) ; select_column_names = [ ] insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 166 , 95.01 , 189 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 97 , 'Germain ' , 'Haly ' , ' B ' , 'Archilles ' ) ; WHERE order_total_eur > 20 ) ; '' '' '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 96 , 'Tiertza ' , 'Bunford ' , ' C ' , 'Archibald ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 119 , 579.12 , 43 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 97 , 313.39 , 241 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 135 , 574.1 , 222 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 169 , 'Elsbeth ' , 'Nucciotti ' , ' B ' , 'Bradley ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 174 , 'Carolyn ' , 'Quinlan ' , ' C ' , 'Brian ' ) ; from pytest_postgresql import factories insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 110 , 144.28 , 59 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 80 , 17.1 , 21 ) ; WHERE ( EXISTS ( SELECT order_total_eur insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 227 , 189.25 , 230 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 198 , 120.47 , 95 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 4 , 'Nancey ' , 'Fawlkes ' , ' C ' , 'Abel ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 152 , 'Towny ' , 'Middell ' , ' B ' , 'Bert ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 56 , 'Kaitlin ' , 'Payle ' , ' B ' , 'Allyson ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 194 , 'Corilla ' , 'Aldwinckle ' , ' C ' , 'Carmellia ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 222 , 416.65 , 59 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 223 , 200.44 , 47 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 114 , 339.9 , 108 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 2 , 'Tomlin ' , 'Nozzolinii ' , ' B ' , 'Abbigail ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 90 , 169.25 , 30 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 11 , 'Amby ' , 'Ligoe ' , ' C ' , 'Absalom ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 63 , 'Gratia ' , 'Moss ' , ' B ' , 'Althea ' ) ; WHERE order_total_eur > 20 ) ) OR insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 70 , 'Carmela ' , 'Sedgeworth ' , ' C ' , 'Amos ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 104 , 'Timofei ' , 'Grene ' , ' B ' , 'Armena ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 115 , 351.68 , 153 ) ; assert checker is not None insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 171 , 175.72 , 249 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 47 , 'Tracey ' , 'Sauvan ' , ' B ' , 'Alice ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 102 , 158.53 , 220 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 63 , 542.48 , 52 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 76 , 281.92 , 183 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 62 , 418.98 , 60 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 134 , 296.72 , 222 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 120 , 454.18 , 214 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 239 , 327.06 , 34 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 25 , 83.54 , 79 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 40 , 33.89 , 23 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 195 , 504.28 , 117 ) ; SELECT ( 1 , 2 , 3 ) ; '' '' '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 34 , 64.76 , 13 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 109 , 'Marquita ' , 'Impy ' , ' B ' , 'Aron ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 151 , 'Prentiss ' , 'Filby ' , ' B ' , 'Berney ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 216 , 'Elsbeth ' , 'MacGaughie ' , ' B ' , 'Charles ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 225 , 'Egbert ' , 'Vasyunin ' , ' B ' , 'Chloe ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 69 , 'Maryjo ' , 'Pink ' , ' C ' , 'Amelia ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 241 , 296.03 , 169 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 111 , 490.85 , 191 ) ; VT100_RESET = `` \x1b [ 0m '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 161 , 184.39 , 94 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 72 , 539.87 , 62 ) ; column_name = \ FROM { ORDERS_TABLE_NAME } insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 195 , 'Dewey ' , 'Bottom ' , ' C ' , 'Carmelo ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 80 , 'Petey ' , 'Colloby ' , ' B ' , 'Ann ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 222 , 'Hazel ' , 'Rushforth ' , ' C ' , 'Chester ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 238 , 448.86 , 16 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 53 , 'Riva ' , 'Scawen ' , ' C ' , 'Allen ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 145 , 112.51 , 162 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 58 , 'Lettie ' , 'Coffin ' , ' B ' , 'Almena ' ) ; if i ! = len ( self.nested_condition_contexts ) - 1 : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 73 , 144.33 , 52 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 59 , 'Lin ' , 'Race ' , ' B ' , 'Almina ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 209 , 203.86 , 244 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 203 , 545.33 , 116 ) ; , PRIMARY KEY ( customer_id ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 127 , 451.77 , 17 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 113 , 'Dania ' , 'Foxton ' , ' C ' , 'Arthusa ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 146 , 184.13 , 22 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 170 , 539.11 , 92 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 94 , 'Halimeda ' , 'Freak ' , ' B ' , 'Arabelle ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 148 , 'Lidia ' , 'Quinane ' , ' C ' , 'Benjamin ' ) ; , nickname VARCHAR ( 20 ) NOT NULL insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 100 , 424.83 , 50 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 81 , 'Sharline ' , 'Rosenwald ' , ' B ' , 'Anna ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 213 , 329.78 , 105 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 137 , 417.16 , 215 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 231 , 'Calhoun ' , 'BoHlingolsen ' , ' C ' , 'Christina ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 31 , 394.48 , 62 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 15 , 47.79 , 248 ) ; WHERE EXISTS ( SELECT order_total_eur insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 167 , 'Ninnette ' , 'Steere ' , ' C ' , 'Brad ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 17 , 'Carlyle ' , 'Zimek ' , ' B ' , 'Adelbert ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 235 , 'Justus ' , 'Barthrup ' , ' B ' , 'Christy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 142 , 509.25 , 190 ) ; conn : Connection = psycopg.connect ( * * kwargs ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 220 , 367.15 , 163 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 220 , 'Kylen ' , 'Bewicke ' , ' B ' , 'Cheryl ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 180 , 'Leonelle ' , 'Chiommienti ' , ' B ' , 'Caitlin ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 52 , 81.47 , 212 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 90 , 'Forest ' , 'Trim ' , ' B ' , 'Appoline ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 221 , 'Cassondra ' , 'Mattingson ' , ' B ' , 'Chesley ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 8 , 424.8 , 244 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 229 , 89.34 , 147 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 21 , 'Nady ' , 'Lempertz ' , ' B ' , 'Adolphus ' ) ; select_column_names.append ( column_name ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 67 , 550.21 , 63 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 103 , 'Ede ' , 'Golden of Ireland ' , ' C ' , 'Armanda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 89 , 556.68 , 74 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 162 , 168.92 , 27 ) ; CHECK ( type IN ( ' C ' , ' B ' ) ) -- C = customer , B = business insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 76 , 'Ardys ' , 'Currm ' , ' B ' , 'Andriane ' ) ; cur.execute ( insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 247 , 'Dulcie ' , 'Crutchley ' , ' B ' , 'Clement ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 163 , 61.42 , 69 ) ; def load_database ( * * kwargs ) : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 182 , 'Sasha ' , 'Stiffkins ' , ' C ' , 'Caldonia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 49 , 'Theodosia ' , 'Rosson ' , ' B ' , 'Aline ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 55 , 'Terrill ' , 'Syde ' , ' B ' , 'Allison ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 5 , 'Callida ' , 'Tomasello ' , ' B ' , 'Abiel ' ) ; class SubquerySelectContext : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 154 , 291.52 , 54 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 191 , 'Frankie ' , 'Canny ' , ' B ' , 'Candace ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 10 , 'Sonnie ' , 'Kelling ' , ' B ' , 'Abram ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 68 , 'Leisha ' , 'Darlington ' , ' C ' , 'Ambrose ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 212 , 179.55 , 180 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 226 , 212.04 , 28 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 229 , 'Melessa ' , 'MacAleese ' , ' C ' , 'Christiana ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 140 , 'Suki ' , 'Flinn ' , ' B ' , 'Bea ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 88 , 'Sansone ' , 'Copsey ' , ' C ' , 'Antonia ' ) ; if len ( self.nested_condition_contexts ) == 0 : from .. subquery_select_checker import SubquerySelectChecker insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 224 , 293.35 , 186 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 50 , 'Anne-marie ' , 'Mounsie ' , ' B ' , 'Alison ' ) ; not used in that subquery of its own columns , otherwise returns None . insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 204 , 'Cassy ' , 'Pearcehouse ' , ' C ' , 'Casper ' ) ; load= [ load_database ] , insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 188 , 'Ferguson ' , 'Mackriell ' , ' B ' , 'Cameron ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 48 , 'Marve ' , 'Eykel ' , ' C ' , 'Alicia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 208 , 'Legra ' , 'Drought ' , ' C ' , 'Catherine ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 249 , 'Rhoda ' , 'Leheude ' , ' C ' , 'Cliff ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 77 , 'Maegan ' , 'Wheldon ' , ' C ' , 'Angela ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 181 , 'Daria ' , 'Wistance ' , ' C ' , 'Caitlyn ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 156 , 'Allistir ' , 'Frary ' , ' C ' , 'Beth ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 72 , 'Nadiya ' , 'Gingles ' , ' B ' , 'Anderson ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 7 , 183.92 , 236 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 7 , 'Lorin ' , 'Dollimore ' , ' C ' , 'Abijah ' ) ; subquery_end_offset = subquery_start_offset + len ( subquery ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 79 , 'Preston ' , 'Groves ' , ' B ' , 'Angelina ' ) ; def __init__ ( self , parsed_sql : exp.Expression , sql_parser : SqlParser ) : subquery_start_offset = whole_statement.find ( subquery ) FROM { ORDERS_TABLE_NAME } insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 144 , 504.73 , 154 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 219 , 594.84 , 121 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 141 , 183.27 , 44 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 217 , 'Lucy ' , 'Durtnell ' , ' C ' , 'Charlie ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 140 , 297.41 , 101 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 215 , 'Nollie ' , 'Jemmett ' , ' B ' , 'Charity ' ) ; VT100_UNDERLINE = `` \x1b [ 4m '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 85 , 404.96 , 79 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 27 , 137.86 , 21 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 240 , 384.87 , 107 ) ; column_exp ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 115 , 'Shirl ' , 'Pilpovic ' , ' C ' , 'Asahel ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 96 , 311.78 , 173 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 206 , 226.62 , 228 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 155 , 'Murdock ' , 'Dix ' , ' C ' , 'Bess ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 38 , 366.31 , 59 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 19 , 107.53 , 94 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 138 , 'Ainsley ' , 'Wraighte ' , ' C ' , 'Barticus ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 176 , 'Marylou ' , 'Guilloton ' , ' C ' , 'Bridget ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 233 , 87.21 , 179 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 177 , 334.0 , 167 ) ; CREATE TABLE { ORDERS_TABLE_NAME } ( f '' '' '' insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 178 , 563.08 , 161 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 30 , 'Colin ' , 'Jansie ' , ' C ' , 'Alastair ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 160 , 144.6 , 82 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 153 , 'Alfy ' , 'McCahill ' , ' B ' , 'Bertha ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 124 , 552.02 , 191 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 114 , 'Fara ' , 'Arkil ' , ' B ' , 'Arzada ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 206 , 'Ardyth ' , 'Conningham ' , ' B ' , 'Cassidy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 108 , 294.25 , 131 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 46 , 362.72 , 240 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 29 , 'Dawna ' , 'Knipe ' , ' C ' , 'Alanson ' ) ; VT100_RESET + \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 111 , 'Torey ' , 'Sessuns ' , ' B ' , 'Artemus ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 2 , 409.8 , 217 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 112 , 'Nanci ' , 'Byrd ' , ' C ' , 'Arthur ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 126 , 384.61 , 226 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 182 , 478.47 , 70 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 81 , 490.65 , 41 ) ; warning_msg += warning_header + underlined_query SELECT order_id insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 197 , 529.63 , 46 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 232 , 'Maritsa ' , 'Cowpland ' , ' C ' , 'Christine ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 230 , 'Cordell ' , 'Bineham ' , ' B ' , 'Christiano ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 168 , 137.02 , 109 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 11 , 88.19 , 50 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 130 , 'Rora ' , 'Adcock ' , ' C ' , 'Babs ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 122 , 'Myrlene ' , 'Worcs ' , ' B ' , 'Augusta ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 217 , 302.24 , 189 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 151 , 221.16 , 212 ) ; warning_msg += '\n ' CREATE TABLE { CUSTOMERS_TABLE_NAME } ( insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 60 , 473.05 , 208 ) ; for i , nested_condition_context in \ warning_msg = checker.check ( ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 23 , 236.48 , 51 ) ; SqlParser.get_column_name_from_column_expression ( insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 200 , 'Fanni ' , 'Iacopetti ' , ' C ' , 'Carolyn ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 250 , 367.56 , 214 ) ; '' '' '' ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 235 , 230.72 , 168 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 185 , 'Tanitansy ' , 'Headington ' , ' C ' , 'Calista ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 53 , 592.15 , 207 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 211 , 399.2 , 138 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 131 , 'Ive ' , 'Matches ' , ' B ' , 'Barbara ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 26 , 'Jenica ' , 'Martina ' , ' C ' , 'Agnes ' ) ; self._detect_suspicious_nested_conditions ( ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 202 , 99.52 , 171 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 3 , 189.43 , 19 ) ; return import psycopg SQL_SUBQUERY_SELECT_WITH_TOPLEVEL_CONDITIONS_SUSPICIOUS = \ warning_header = `` Warning : No column in subquery SELECT references its tables [ pg4n : :SubquerySelect ] \n '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 211 , 'Jobi ' , 'Bails ' , ' B ' , 'Cecilia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 226 , 'Emelina ' , 'Ayliff ' , ' B ' , 'Chris ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 121 , 'Clywd ' , 'Stokey ' , ' B ' , 'August ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 107 , 'Celisse ' , 'Rubra ' , ' B ' , 'Arminta ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 149 , 'Erik ' , 'Cushe ' , ' B ' , 'Benjy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 44 , 537.56 , 2 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 239 , 'Atalanta ' , 'Girdler ' , ' C ' , 'Claire ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 56 , 501.06 , 129 ) ; , customer_id INT NOT NULL from dataclasses import dataclass insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 31 , 'Dario ' , 'Siehard ' , ' C ' , 'Alazama ' ) ; , FOREIGN KEY ( customer_id ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 61 , 343.91 , 223 ) ; select = subquery.find ( exp.Select ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 42 , 'Pyotr ' , 'Feldhorn ' , ' C ' , 'Alexis ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 203 , 'Rory ' , 'Hallatt ' , ' C ' , 'Casey ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 228 , 'Rudd ' , 'Ames ' , ' B ' , 'Christian ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 61 , 'Blisse ' , 'Dillway ' , ' C ' , 'Alonzo ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 164 , 'Abel ' , 'Bezants ' , ' C ' , 'Bob ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 65 , 318.64 , 6 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 136 , 'Aretha ' , 'Arias ' , ' C ' , 'Bart ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 152 , 291.54 , 10 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 69 , 266.3 , 39 ) ; sql_statement = SQL_SUBQUERY_SELECT_IN_SUSPICIOUS insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 196 , 'Louisa ' , 'Matasov ' , ' B ' , 'Carmon ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 160 , 'Patti ' , 'Louis ' , ' C ' , 'Biddie ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 48 , 199.52 , 234 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 236 , 485.18 , 167 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 214 , 'Chalmers ' , 'Britton ' , ' C ' , 'Celinda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 189 , 164.91 , 68 ) ; sql_statement = SQL_NO_SUBQUERIES assert warning_msg is None subqueries = self.parsed_sql.find_all ( exp.In , exp.SubqueryPredicate ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 210 , 'Pamelina ' , 'Vittery ' , ' C ' , 'Cathy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 101 , 328.66 , 189 ) ; warning_msg = `` '' sql_statement = SQL_SUBQUERY_SELECT_EXISTS_SUSPICIOUS , fname VARCHAR ( 50 ) NOT NULL insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 62 , 'Seline ' , 'McGray ' , ' B ' , 'Alphinias ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 65 , 'Glenna ' , 'Alastair ' , ' C ' , 'Alyssa ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 75 , 'Erma ' , 'Cranstone ' , ' B ' , 'Andrew ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 231 , 51.77 , 118 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 129 , 426.3 , 136 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 66 , 'Sadella ' , 'Boxhall ' , ' B ' , 'Alzada ' ) ; sql_statement = SQL_NO_CONDITIONS insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 37 , 'Talbot ' , 'Keddey ' , ' B ' , 'Aleva ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 98 , 177.22 , 86 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 122 , 406.1 , 80 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 204 , 212.04 , 203 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 227 , 'Jeralee ' , 'Atwill ' , ' C ' , 'Christa ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 221 , 487.39 , 227 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 186 , 'Chloette ' , 'Ratt ' , ' B ' , 'Calpurnia ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 209 , 'Dulcea ' , 'Akister ' , ' C ' , 'Cathleen ' ) ; from typing import Optional insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 4 , 144.14 , 157 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 71 , 175.29 , 115 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 218 , 389.51 , 177 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 183 , 'Harvey ' , 'Skinn ' , ' B ' , 'Caleb ' ) ; postgresql = factories.postgresql ( `` factory '' ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 119 , 'Gregg ' , 'Lazenbury ' , ' B ' , 'Aubrey ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 18 , 'Odie ' , 'Rowling ' , ' C ' , 'Adele ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 236 , 'Garnette ' , 'Tabrett ' , ' C ' , 'Cicely ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 146 , 'Dunstan ' , 'Cressey ' , ' B ' , 'Bella ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 118 , 'Hermy ' , 'Whieldon ' , ' B ' , 'Ashley ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 237 , 293.23 , 140 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 224 , 'Dayle ' , 'Eirwin ' , ' B ' , 'Chick ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 199 , 376.5 , 53 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 28 , 87.44 , 1 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 106 , 236.57 , 4 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 16 , 330.92 , 130 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 131 , 255.66 , 127 ) ; SELECT customers_id with conn.cursor ( ) as cur : SELECT customer_id VT100_UNDERLINE + \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 93 , 'Sashenka ' , 'Fedorski ' , ' C ' , 'Arabella ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 103 , 14.83 , 183 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 232 , 330.85 , 204 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 94 , 406.59 , 129 ) ; if subqueries is None : FROM { ORDERS_TABLE_NAME } insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 161 , 'Barron ' , 'Dishmon ' , ' B ' , 'Bill ' ) ; return None insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 10 , 414.55 , 234 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 200 , 592.16 , 137 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 71 , 'Cynthie ' , 'Rouby ' , ' B ' , 'Anastasia ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 249 , 491.05 , 63 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 116 , 'Annmarie ' , 'Errichelli ' , ' B ' , 'Asaph ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 143 , 239.98 , 109 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 244 , 273.35 , 153 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 194 , 328.76 , 41 ) ; # We need to find whether the subquery SELECT uses a tuple variable return warning_msg insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 245 , 327.9 , 212 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 133 , 499.73 , 235 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 142 , 'Elfrieda ' , 'Cleary ' , ' C ' , 'Becca ' ) ; CUSTOMERS_TABLE_NAME = `` e29_test_table_customers '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 64 , 'Dyan ' , 'Crosbie ' , ' B ' , 'Alverta ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 67 , 'Zsazsa ' , 'Bellocht ' , ' C ' , 'Amanda ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 134 , 'Georgetta ' , 'Crossley ' , ' B ' , 'Barnabas ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 201 , 'Arv ' , 'Spawforth ' , ' B ' , 'Carrie ' ) ; WHERE type = ' B ' ) ; '' '' '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 101 , 'Hamilton ' , 'Pellew ' , ' B ' , 'Arizona ' ) ; self.nested_condition_contexts : list [ SubquerySelectContext ] = [ ] insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 243 , 209.34 , 31 ) ; DROP TABLE IF EXISTS { CUSTOMERS_TABLE_NAME } ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 123 , 'Lyon ' , 'Nolleau ' , ' C ' , 'Augustina ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 43 , 'Belle ' , 'Barsham ' , ' B ' , 'Alfonse ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 205 , 508.59 , 59 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 17 , 302.31 , 225 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 99 , 354.37 , 66 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 176 , 22.8 , 175 ) ; whole_statement [ subquery_end_offset : len ( whole_statement ) ] subquery : exp.Expression insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 3 , 'Christen ' , 'Culley ' , ' C ' , 'Abednego ' ) ; , type CHAR ( 1 ) NOT NULL WHERE order_id % 2 = 0 ) AND insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 141 , 'Jacinta ' , 'Villiers ' , ' B ' , 'Beatrice ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 167 , 547.07 , 197 ) ; SQL_NO_CONDITIONS = \ insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 159 , 281.36 , 198 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 102 , 'Ricca ' , 'Rupprecht ' , ' B ' , 'Arlene ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 175 , 'Davy ' , 'Blomefield ' , ' B ' , 'Brianna ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 120 , 'Corinna ' , 'Pyburn ' , ' B ' , 'Audrey ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 162 , 'Jessee ' , 'List ' , ' B ' , 'Billy ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 157 , 477.53 , 205 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 52 , 'Gerrilee ' , 'Ackland ' , ' B ' , 'Allan ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 126 , 'Lilllie ' , 'Annis ' , ' C ' , 'Aurelia ' ) ; def sql_parser ( postgresql : Connection ) : whole_statement = str ( self.parsed_sql ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 109 , 170.82 , 206 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 24 , 'Jacinthe ' , 'Kleeman ' , ' B ' , 'Adrienne ' ) ; class SubquerySelectChecker : f '' '' '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 91 , 'Bobby ' , 'Fortesquieu ' , ' B ' , 'Aquilla ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 38 , 'Web ' , 'Catterill ' , ' B ' , 'Alex ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 51 , 244.27 , 119 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 75 , 238.65 , 203 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 184 , 'Louise ' , 'Jansey ' , ' C ' , 'California ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 54 , 'Malchy ' , 'Hearty ' , ' B ' , 'Allisandra ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 208 , 344.91 , 150 ) ; ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 137 , 'Lucilia ' , 'Bentick ' , ' C ' , 'Bartholomew ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 25 , 'Neely ' , 'Merrydew ' , ' B ' , 'Agatha ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 41 , 'Reilly ' , 'Kennler ' , ' B ' , 'Alexandria ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 93 , 452.63 , 115 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 240 , 'Britte ' , 'Muge ' , ' B ' , 'Clara ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 121 , 132.25 , 50 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 230 , 389.39 , 247 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 154 , 'Conney ' , 'Riteley ' , ' C ' , 'Bertram ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 132 , 'Olympe ' , 'Faber ' , ' B ' , 'Barbery ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 241 , 'Sigismund ' , 'Mowsdill ' , ' B ' , 'Clare ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 106 , 'Merrily ' , 'Coundley ' , ' C ' , 'Arminda ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 242 , 'Brenden ' , 'Simmons ' , ' B ' , 'Clarence ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 218 , 'Raffarty ' , 'Sweeney ' , ' C ' , 'Charlotte ' ) ; for subquery in subqueries : WHERE type = ' B ' ) AND return SqlParser ( db_connection=postgresql ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 173 , 'Kristopher ' , 'Mackelworth ' , ' B ' , 'Brenda ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 187 , 'Donall ' , 'Casolla ' , ' B ' , 'Calvin ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 107 , 23.63 , 179 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 186 , 561.85 , 156 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 172 , 'Pammi ' , 'Codling ' , ' B ' , 'Breeanna ' ) ; WHERE customer_id in ( SELECT order_id insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 14 , 586.06 , 181 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 83 , 'Wolf ' , 'Brenton ' , ' B ' , 'Annette ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 98 , 'Elfreda ' , 'Tome ' , ' C ' , 'Ariadne ' ) ; FROM { CUSTOMERS_TABLE_NAME } insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 223 , 'Annice ' , 'Haynes ' , ' B ' , 'Chet ' ) ; self.sql_parser : SqlParser = sql_parser insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 147 , 180.39 , 2 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 57 , 349.14 , 58 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 129 , 'Ashla ' , 'De-Ville ' , ' C ' , 'Bab ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 45 , 46.05 , 177 ) ; , sname VARCHAR ( 50 ) NOT NULL insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 78 , 'Matilde ' , 'Froome ' , ' B ' , 'Angelica ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 212 , 'Annecorinne ' , 'Soles ' , ' B ' , 'Cedric ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 87 , 441.16 , 191 ) ; self.nested_condition_contexts.append ( context ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 145 , 'Adena ' , 'Wenham ' , ' C ' , 'Belinda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 91 , 331.76 , 115 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 84 , 396.02 , 111 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 138 , 223.81 , 183 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 139 , 'Kelsi ' , 'Suddell ' , ' C ' , 'Bazaleel ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 54 , 591.44 , 145 ) ; order_id > 40 ; '' '' '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 33 , 'Amble ' , 'Jewes ' , ' B ' , 'Alberta ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 117 , 'Marysa ' , 'Wadman ' , ' C ' , 'Asenath ' ) ; # ( e.g . FROM statement ) of the subquery . insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 32 , 331.93 , 144 ) ; select_column_names ) ) : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 234 , 'Cayla ' , 'Statter ' , ' B ' , 'Christopher ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 123 , 370.87 , 115 ) ; SQL_NO_SUBQUERIES = \ insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 165 , 84.61 , 1 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 39 , 42.62 , 95 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 188 , 495.68 , 39 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 215 , 515.79 , 96 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 192 , 'Dudley ' , 'Vesco ' , ' B ' , 'Carlotta ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 13 , 'Marion ' , 'Penelli ' , ' B ' , 'Adaline ' ) ; ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 105 , 107.29 , 12 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 125 , 'Leo ' , 'Creaney ' , ' B ' , 'Augustus ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 18 , 438.38 , 26 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 247 , 123.55 , 179 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 163 , 'Gerhardt ' , 'Simcock ' , ' B ' , 'Blanche ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 30 , 435.57 , 105 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 214 , 520.52 , 98 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 150 , 'Agnesse ' , 'Liebmann ' , ' B ' , 'Bernard ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 33 , 140.92 , 236 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 21 , 471.12 , 179 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 28 , 'Nanice ' , 'MacMaster ' , ' B ' , 'Alan ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 144 , 'Ange ' , 'Pasterfield ' , ' C ' , 'Bedelia ' ) ; # exp.In is not SubqueryPredicate for some reason insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 95 , 'Amandie ' , 'Botham ' , ' B ' , 'Araminta ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 128 , 415.86 , 243 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 159 , 'Carilyn ' , 'Vinecombe ' , ' B ' , 'Bezaleel ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 193 , 449.91 , 213 ) ; SQL_SUBQUERY_SELECT_IN_SUSPICIOUS = \ insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 191 , 183.55 , 142 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 113 , 305.06 , 123 ) ; SQL_SUBQUERY_SELECT_EXISTS_SUSPICIOUS = \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 6 , 'Daisey ' , 'Hamill ' , ' B ' , 'Abigail ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 87 , 'Nanette ' , 'McElwee ' , ' B ' , 'Antoinette ' ) ; DROP TABLE IF EXISTS { ORDERS_TABLE_NAME } ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 238 , 'Gregor ' , 'Crinion ' , ' B ' , 'Cindy ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 110 , 'Donall ' , 'Labrenz ' , ' B ' , 'Artelepsa ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 12 , 591.72 , 143 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 174 , 597.34 , 184 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 136 , 411.87 , 10 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 99 , 'Phineas ' , 'Yuryaev ' , ' B ' , 'Arielle ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 179 , 453.95 , 43 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 14 , 'Davon ' , 'Burris ' , ' C ' , 'Addison ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 130 , 575.58 , 235 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 193 , 'Brucie ' , 'Coning ' , ' C ' , 'Carlton ' ) ; FROM { CUSTOMERS_TABLE_NAME } insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 58 , 10.24 , 74 ) ; from .sqlparser import SqlParser insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 156 , 130.63 , 188 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 9 , 'Lester ' , 'Markus ' , ' C ' , 'Abraham ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 150 , 439.75 , 18 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 250 , 'Langston ' , 'Prosser ' , ' C ' , 'Clifford ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 77 , 335.23 , 149 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 125 , 170.66 , 131 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 149 , 340.62 , 215 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 177 , 'Genvieve ' , 'Marthen ' , ' B ' , 'Brittany ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 23 , 'Jeanette ' , 'Fincher ' , ' B ' , 'Adriane ' ) ; SQL_MULTIPLE_SUBQUERY_SELECTS_SUSPICIOUS = \ insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 20 , 207.6 , 9 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 92 , 156.72 , 192 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 24 , 538.88 , 38 ) ; customer_id INT underlined_query = whole_statement [ : subquery_start_offset ] + \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 233 , 'Tibold ' , 'Sleigh ' , ' C ' , 'Christoph ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 153 , 350.78 , 247 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 171 , 'Fredrick ' , 'Matuszynski ' , ' C ' , 'Breanna ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 127 , 'Rhoda ' , 'Kurton ' , ' C ' , 'Avarilla ' ) ; from .. sqlparser import SqlParser assert warning_msg is not None insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 148 , 203.36 , 180 ) ; factory = factories.postgresql_proc ( insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 189 , 'Merle ' , 'Erridge ' , ' C ' , 'Camille ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 57 , 'Vita ' , 'Dunnett ' , ' B ' , 'Allyssa ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 181 , 150.37 , 69 ) ; subquery + \ insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 243 , 'Hannah ' , 'Mattheis ' , ' C ' , 'Clarinda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 139 , 441.16 , 97 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 9 , 519.43 , 175 ) ; self.parsed_sql : exp.Expression = parsed_sql order_id INT insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 132 , 488.95 , 234 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 199 , 'Matilda ' , 'Malenoir ' , ' C ' , 'Caroline ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 44 , 'Buffy ' , ' O '' Cridigan ' , ' B ' , 'Alfred ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 225 , 26.43 , 228 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 185 , 505.7 , 49 ) ; conn.commit ( ) context = SubquerySelectContext ( subquery ) insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 108 , 'Janene ' , 'Motten ' , ' C ' , 'Arnold ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 178 , 'Rogers ' , 'Plose ' , ' B ' , 'Brittney ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 5 , 582.52 , 172 ) ; all_subquery_columns = self.sql_parser.get_query_columns ( subquery ) insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 175 , 161.61 , 58 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 45 , 'Seymour ' , 'Mayer ' , ' B ' , 'Alfreda ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 158 , 65.82 , 201 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 47 , 163.79 , 141 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 135 , 'Janenna ' , 'McCamish ' , ' C ' , 'Barney ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 37 , 322.11 , 41 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 168 , 'Melicent ' , 'Cheston ' , ' B ' , 'Bradford ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 35 , 389.81 , 218 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 43 , 133.73 , 196 ) ; import pytest insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 180 , 452.67 , 234 ) ; from psycopg import Connection insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 92 , 'Raven ' , 'Eilles ' , ' C ' , 'Ara ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 234 , 254.56 , 98 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 190 , 'Kara ' , 'Backs ' , ' B ' , 'Campbell ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 124 , 'Penelope ' , 'Quadling ' , ' C ' , 'Augustine ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 237 , 'Jeramie ' , 'Gallehock ' , ' C ' , 'Cinderella ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 184 , 380.46 , 98 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 19 , 'Daphne ' , 'Bullen ' , ' B ' , 'Adeline ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 147 , 'Wilmer ' , 'MacWhan ' , ' B ' , 'Benedict ' ) ; REFERENCES { CUSTOMERS_TABLE_NAME } ( customer_id ) WHERE type = ' B ' ; '' '' '' def _detect_suspicious_nested_conditions ( self ) : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 219 , 'Adriane ' , 'Ccomini ' , ' B ' , 'Chauncey ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 244 , 'Katrine ' , 'Janiak ' , ' B ' , 'Clarissa ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 133 , 'Clementia ' , 'Fergusson ' , ' B ' , 'Barbie ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 46 , 'Mechelle ' , 'Vinick ' , ' B ' , 'Algernon ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 246 , 'Albert ' , 'Heimann ' , ' B ' , 'Cleatus ' ) ; all_subquery_column_names = [ x.name for x in all_subquery_columns ] insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 213 , 'Rubin ' , 'Lunney ' , ' B ' , 'Celeste ' ) ; FROM { CUSTOMERS_TABLE_NAME } insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 32 , 'Aubrie ' , 'Lockitt ' , ' C ' , 'Albert ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 22 , 193.12 , 6 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 95 , 367.31 , 48 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 59 , 141.8 , 118 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 39 , 'Tabbie ' , 'Glison ' , ' B ' , 'Alexander ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 216 , 388.15 , 142 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 86 , 537.64 , 201 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 26 , 590.52 , 50 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 70 , 596.2 , 221 ) ; for column_exp in column_exps : def test_check ( sql_parser : SqlParser ) : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 128 , 'Jere ' , 'Cometti ' , ' B ' , 'Azariah ' ) ; def check ( self ) - > Optional [ str ] : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 64 , 534.3 , 108 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 165 , 'Angele ' , 'Wildbore ' , ' C ' , 'Bobby ' ) ; sql_statement = SQL_MULTIPLE_SUBQUERY_SELECTS_SUSPICIOUS insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 16 , 'Augustin ' , 'Blaxall ' , ' C ' , 'Adelaide ' ) ; subquery = str ( nested_condition_context.subquery ) , order_total_eur DECIMAL ( 6,2 ) NOT NULL insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 13 , 503.52 , 216 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 34 , 'Lorens ' , 'Buzin ' , ' C ' , 'Aldo ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 49 , 376.9 , 89 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 192 , 206.39 , 151 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 22 , 'Grazia ' , 'Syne ' , ' C ' , 'Adrian ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 74 , 'Giffy ' , 'Cottee ' , ' C ' , 'Andrea ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 164 , 193.39 , 169 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 6 , 132.85 , 206 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 116 , 292.86 , 97 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 86 , 'Lauren ' , 'Tolworth ' , ' B ' , 'Anthony ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 50 , 306.71 , 235 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 166 , 'Angelo ' , 'Vanstone ' , ' C ' , 'Boetius ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 35 , 'Lainey ' , 'Davidow ' , ' C ' , 'Aldrich ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 143 , 'Sasha ' , 'Eunson ' , ' C ' , 'Beck ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 100 , 'Gypsy ' , 'Bottrell ' , ' C ' , 'Aristotle ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 74 , 63.02 , 117 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 73 , 'Seymour ' , 'Maffioletti ' , ' B ' , 'Andre ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 170 , 'Bard ' , 'Shaw ' , ' C ' , 'Brady ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 84 , 'Birk ' , 'Malling ' , ' C ' , 'Annie ' ) ; enumerate ( self.nested_condition_contexts ) : insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 89 , 'Nickie ' , 'Bloss ' , ' C ' , 'Antonio ' ) ; for select_expression in select.expressions : insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 36 , 225.6 , 136 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 190 , 401.19 , 88 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 85 , 'Brig ' , 'Triswell ' , ' C ' , 'Anselm ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 246 , 510.74 , 188 ) ; Returns warning message if there no column SELECTed in a subquery is insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 245 , 'Holly ' , 'Roy ' , ' C ' , 'Claudia ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 228 , 542.3 , 42 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 15 , 'Zachary ' , 'Faloon ' , ' C ' , 'Adela ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 158 , 'Anett ' , 'Hercules ' , ' B ' , 'Beverly ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 8 , 'Gasparo ' , 'Bohlje ' , ' C ' , 'Abner ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 169 , 552.88 , 241 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 207 , 205.25 , 199 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 105 , 'Cary ' , 'Sells ' , ' C ' , 'Armilda ' ) ; `` `` '' insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 51 , 'Kennan ' , 'Burstowe ' , ' B ' , 'Alixandra ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 78 , 569.4 , 99 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 196 , 259.0 , 244 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 82 , 106.39 , 237 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 157 , 'Noach ' , 'MacRitchie ' , ' C ' , 'Bethena ' ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 82 , 'Abey ' , 'Darridon ' , ' C ' , 'Anne ' ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 66 , 454.41 , 11 ) ; insert into { ORDERS_TABLE_NAME } ( order_id , order_total_eur , customer_id ) values ( 55 , 391.93 , 128 ) ; insert into { CUSTOMERS_TABLE_NAME } ( customer_id , fname , sname , type , nickname ) values ( 40 , 'Olva ' , 'Leborgne ' , ' C ' , 'Alexandra ' ) ;","['src/pg4n/subquery_select_checker.py', 'src/pg4n/test/test_subquery_select_checker.py']",2022-11-07 18:55:37+00:00,2022-11-08 08:07:17+00:00,2022-11-08 10:07:16+02:00
70,bbd831ee1f05324f62486eca5ace30ed845111a7,0.0001707839983282,0,,Detect strange HAVING clause without GROUP BY ( e32 per Brass ),Merge pull request # 77 from Project-C-SQL/feat/errfmt,"warning_msg = `` Warning : DISTINCT in SUM or AVG [ pg4n : :SumDistinct ] '' warning_name = `` SurplusParentheses '' warning = `` HAVING without GROUP BY '' warning = `` ORDER BY in a subquery '' from .errfmt import ErrorFormatter VT100_RESET = `` \x1b [ 0m '' warning_msg = formatter.format ( ) class ErrorFormatter : def test_format ( ) : def format ( self ) - > str : self , underlined_query : Optional [ str ] = None , warning_name = `` SumDistinct '' warning_name = `` InnerOrderBy '' and warning_msg.find ( underlined_query ) ! = -1 VT100_UNDERLINE = `` \x1b [ 4m '' self.underlined_query : Optional [ str ] = underlined_query from . qepparser import QEPAnalysis warning_msg = formatter.format ( ) return base_msg + f '' \n { self.underlined_query } '' from .. errfmt import ErrorFormatter warning_name = `` EqWildcard '' formatter = ErrorFormatter ( warning , warning_name , underlined_query ) warning_header = `` Warning : No column in subquery SELECT references its tables [ pg4n : :SubquerySelect ] \n '' underlined_query = f '' '' '' SELECT * warning_msg = `` Warning : Possible use of '= ' instead of % for wildcard pattern [ pg4n : :EqWildcard ] '' from .qepparser import QEPAnalysis if self.underlined_query : warning = `` Found impossible comparison due to column/table constraints '' warning_msg = `` Warning : HAVING without GROUP BY [ pg4n : :StrangeHaving ] '' { VT100_UNDERLINE } WHERE type ' C ' { VT100_RESET } = 1 OR 100 = 100 ; '' '' '' base_msg = f '' Warning : { self.warning_msg } [ pg4n : : { self.warning_name } ] '' return base_msg warning_msg.find ( warning ) ! = -1 warning_name = `` SurplusSemicolons '' warning_msg = `` Warning : ORDER BY in a subquery [ pg4n : :InnerOrderBy ] '' ) : FROM customers warning_msg += formatter.format ( ) self.warning_msg = formatter.format ( ) warning_msg = `` Warning : Found impossible comparison due to column/table constraints [ pg4n : :ImpliedExpression ] '' warning = `` DISTINCT in SUM or AVG '' self.warning_msg = self.warning_msg + msg_header + underlined_query warning_name = `` CmpDomains '' self.warning_name : str = warning_name warning_name : str , formatter = ErrorFormatter ( warning , warning_name , underlined_query ) warning = `` Possible use of '= ' instead of LIKE for wildcard pattern '' warning = `` Too many semicolons '' ) from typing import Optional warning = f '' Comparison between different domains ( { domain1 } , { domain2 } ) '' warning_msg += warning_header + underlined_query warning_name = `` SubquerySelect '' assert warning_msg.find ( warning ) ! = -1 and warning_msg.find ( warning_name ) ! = -1 warning = `` No column in subquery SELECT references its tables '' def __init__ ( warning_msg : str , formatter = ErrorFormatter ( warning , warning_name ) warning_name = `` StrangeHaving '' assert ( warning = `` Too many parentheses '' self.warning_msg : str = warning_msg warning_name = `` ImpliedExpression '' formatter = ErrorFormatter ( warning , warning_name ) `` `` '' msg_header = f '' Warning : Comparison between different domains ( { domain1 } , { domain2 } ) [ pg4n : :CmpDomains ] \n '' Returns a formatted error message . and warning_msg.find ( warning_name ) ! = -1","['src/pg4n/cmp_domain_checker.py', 'src/pg4n/eq_wildcard_checker.py', 'src/pg4n/errfmt.py', 'src/pg4n/implied_expression_checker.py', 'src/pg4n/strange_having_checker.py', 'src/pg4n/subquery_orderby_checker.py', 'src/pg4n/subquery_select_checker.py', 'src/pg4n/sum_distinct_checker.py', 'src/pg4n/test/test_errfmt.py']",2022-11-17 17:50:30+00:00,2022-11-21 10:02:16+00:00,2022-11-21 12:21:55+02:00
72,535fdf800713ce7b74f1e330e9c02af0bb981db2,0.0098002571612596,0,,Detect SUM/AVG ( DISTINCT ... ) ( e33 per Brass ),Merge pull request # 95 from Project-C-SQL/feat/error-handling-and-syntax-error-detection,"def parse_new_prompt_and_rest ( self , psql : str ) - > list [ str ] : prompt_res = match_rev_prompt_end.parse_string ( psql_rev ) Literal ( `` psql ( PostgreSQL ) `` ) + Combine ( Word ( nums ) + ' . ' + Word ( nums ) ) SubquerySelectChecker ( sanitized_sql , sql_parser ) .check ( ) from pyparsing import ( prompt_res = match_rev_prompt_end.parse_string ( psql_rev ) # Licensed under MIT . self.tok_rev_prompt_end psql_args : str # Semantic analysis is always done when user presses Return after most recent query . pg_user : str , # Comparing different domains Char ( ' ; ' ) from shutil import get_terminal_size psql.ofilter ( b'\r\n\r\r\n ' ) self , analysis_result = SubquerySelectChecker ( if output [ 0:2 ] == b'\r\n ' : qep_analysis def test_parse_last_stmt ( ) - > None : except Exception : # Matches only program errors ( see flake8 rule E722 ) ) - > bytes : # Opt ( Literal ( ' * ' ) | Literal ( ' ! ' ) | Literal ( ' ? ' ) , `` '' ) psql.ofilter ( b'\x1b [ ? 2004htest_db- # ' ) except ParseException : psql.ofilter ( b '' '\r ( reverse-i-search ) ` ' : `` ) assert p.output_has_new_prompt ( case_mixed_results ) # SUM/AVG ( DISTINCT ) def parse_new_prompt ( self , psql : str ) - > List [ str ] : def _check_and_act_on_repl_output ( # AND-clause will stop executing after first False . match_rev_magical_returns.parse_string ( psql_rev ) analysis_result = CmpDomainChecker ( sanitized_sql , columns ) .check ( ) self.tok_pre_database + self.tok_database assert p.parse_last_stmt ( case_trivial ) == \ pg_user : str , `` `` '' line and then the prompt , to allow easy message injection . res_list [ 1 ] [ : :-1 ] # see how the screen would look like , but still allow injecting to pick up relevant SQL statements and syntax errors for hook functions . '' '' '' if self.parser.output_has_magical_return ( res_list [ 2 ] [ : :-1 ] Word , assert p.parse_last_found_stmt ( case_multiline_query ) == \ psql_rev : str = psql [ : :-1 ] if magical_return_res : if self.pg4n_message ! = `` '' \ def test_output_has_new_prompt ( ) - > None : # Literal ( `` ERROR : '' ) return input reduce ( lambda x , y : x + y [ : :-1 ] , results , `` '' ) psql._intercept ( b'\r\n\r\r\n ' ) # Wildcards without LIKE `` `` '' if output [ 0:2 ] == b '' \r\n '' : ) : analysis_result : Optional [ str ] = None def test_output_has_magical_return ( ) - > None : return self.pg_tuple psql.start ( ) intercepted queries and syntax errors . psql._intercept ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 100\x1b [ 27m ; \x08\x08\x08\x08\x08\x08 '' ) # Turn on verbose output to psqlparser.log file in working directory from pyparsing import Literal , Word , ParseException , ParserElement , \ `` psql `` + bytes.decode ( self.psql_args ) , prompt_res : Optional [ ParseResults ] = None : returns : an empty list if no prompt found . Otherwise has [ ' > = ' ] or \ unreversed_flattened_res : str = reduce ( def test_parse_magical_return ( ) - > None : # SQL parser , QEP parser , or an analysis module exploded : # Since latest_output contains error details , we will have to bytes.decode ( latest_output ) # `` = > SELECT psql.ofilter ( b'\r\n\x1b [ ? 2004l\r ' ) `` - ! > '' , `` * ! > '' , `` \ ' ! > '' , `` \ '' ! > '' , `` $ ! > '' , `` ( ! > '' , pg_host : str , return bytes ( line and then the prompt , to allow easy message injection . sql_parser : SqlParser = SqlParser ( conn ) assert psql._intercept ( fresh_prompt_1 ) == \ self.tok_pre_database + self.tok_database + \ match_rev_magical_returns : ParserElement = \ psql = PsqlWrapper ( sys.argv [ 1 ] .encode ( `` utf-8 '' ) , `` `` '' Start psql process and feed hook functions with \ encoding= '' utf-8 '' , assert psql._intercept ( case_query_2_prompt ) == \ main.py [ psql arguments ] < database name > '' ) def check_psql_version ( self ) - > str : self.tok_pre_user + self.tok_user Literal , def parse_new_prompt_and_rest ( self , psql : str ) - > List [ str ] : # for optimization reasons , check output only if len ( ) > 1 , so most psql._intercept ( case_query_1 ) `` `` '' Check for weird Return presses . self.parser.parse_new_prompt_and_rest ( tok_stmt_end psql.ofilter ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C1 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 1\x1b [ 27m00 ; \x08\x08\x08\x08\x08\x08 '' ) .replace ( db_name + `` - > '' , `` '' ) \ and self.parser.parse_new_prompt ( tok_rev_error : ParserElement = Literal ( `` : RORRE '' ) res_list [ 2 ] [ : :-1 ] + res_list [ 1 ] [ : :-1 ] + res_list [ 0 ] [ : :-1 ] try : self.tok_rev_prompt_end def test_parse_new_prompt ( ) - > None : if len ( res_list ) == 4 : # results include \x1b [ ? 2004l # prompt1 per bin/psql/prompt.c : match_rev_last_stmt : ParserElement = ( split_prompt [ 1 ] , assert psql.ofilter ( fresh_prompt_1 ) == \ print ( f '' { os.path.basename ( sys.executable ) } \ results = [ : returns : a two-part list with everything before the prompt \ assert p.parse_last_stmt ( case_select_then_select ) == \ match_rev_last_stmt : ParserElement = \ ' . ' def test_ofilter ( ) - > None : StringEnd , self.pg_tuple = ( if prompt_res : ( Literal ( ' # ' ) | Literal ( ' > ' ) ) are received . `` port= '' + self.pg_port no_newlines_res = unreversed_flattened_res.replace ( '\n ' , ' ' ) def check_and_act_on_repl_output ( self , latest_output : bytes ) - > bytes : Literal ( `` psql ( PostgreSQL ) `` ) psql_rev = psql [ : :-1 ] # slicing is fastest operation for reversing # prompt : analysis_result = CmpDomainChecker ( bytes.decode ( prompt , `` utf-8 '' ) ) return has_magical_return # rev means reversed , these are for performance reasons . from typing import Optional , Tuple return `` Pg4n has only been tested on psql versions `` + \ analysis_result = EqWildcardChecker ( print_msg + `` \r\n\r\n '' if self.parser.output_has_new_prompt ( self.tok_rev_prompt_end def __init__ ( self , psql_args : str ) : SumDistinctChecker ( sanitized_sql , qep_analysis ) .check ( ) CaselessLiteral , to pick up relevant SQL statements for the hook function . potential_future_contents : str = '\n'.join ( # If we have a semantic error message waiting and there is a fresh `` user= '' + self.pg_user `` `` '' Parse for syntax error output . self.tok_pre_host + self.tok_host + \ conn ) .check ( ) : returns : syntax error message from 'ERROR : ' to last '^ ' . self.pg4n_message = self.semantic_analyze ( parsed_sql_query ) qep_analysis : QEPAnalysis = QEPParser ( conn=conn ) .parse ( sql_query ) version_info = \ `` - ? > '' , `` * ? > '' , `` \ ' ? > '' , `` \ '' ? > '' , `` $ ? > '' , `` ( ? > '' ] : returns : an empty string if current version has been tested , \ `` dbname= '' + self.pg_name psql.ofilter ( b'SELECT ' ) bytes.decode ( latest_output ) ) ! = [ ] : # there is new prompt self.match_rev_any_sql_stmt + Word ( self.prompt_chars ) psql.ofilter ( b'\r\x1b [ C ' ) # ( Return is always at least 2 length ) psql.ofilter ( b'\r\x1b [ K\x1b > \x1b [ r\x1b [ ? 1049l ' ) reversed_flattened_res : str = \ # input does not trigger parsing ( Return is always at least 2 length ) psql._intercept ( b'orders ' ) potential_future_screen = \ results = [ res_list [ 3 ] [ : :-1 ] , potential_future_screen_output_sink.feed ( psql.ofilter ( b'SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; ' ) import sys psql._intercept ( b'\r\x1b [ K\x1b > \x1b [ r\x1b [ ? 1049l ' ) : returns : if output is a fresh prompt . ImpliedExpressionChecker ( sanitized_sql , sql_query , if version == `` '' : c.interact ( input_filter=lambda x : x , output_filter=self._intercept ) latest_output : bytes : param prompt : is where the message is injected . A fresh prompt is \ sanitized_sql : exp.Expression = sql_parser.parse_one ( sql_query ) # debug creates pyte.screen ( current screenscraping context ) and Opt ( Literal ( ' * ' ) | Literal ( ' ! ' ) | Literal ( ' ? ' ) , `` '' ) stmt_res = match_error_statement.parse_string ( psql_rev ) pexpect.spawn ( `` psql `` + bytes.decode ( self.psql_args ) psql.ofilter ( b'\x08\x08 ' ) psql.ofilter ( b'\r\n ' ) def ofilter ( self , output : bytes ) - > bytes : : returns : a prompt with injected message , or unchanged if \ `` `` '' Forward output to ` _check_and_act_on_repl_output ` and feed \ StrangeHavingChecker ( sanitized_sql , qep_analysis ) .check ( ) def parse_syntax_error ( self , psql : str ) - > str : # magic strings ( related at least to ctrl-R use ) are lambda x , y : x + y [ : :-1 ] , results , `` '' else : from pyparsing import \ ) - > None : `` `` '' Detect when psql query evaluation has ended by parsing for a new prompt . psql._intercept ( b'\x1b [ ? 2004htest_db- # ' ) psql._intercept ( b ' ; ' ) assert p.parse_last_stmt ( case_empirical_1 ) == \ # from .inconsistent_expression_checker import InconsistentExpressionChecker `` `` '' Forward output to ` check_and_act_on_repl_output ( ) ` and feed \ with . CaselessLiteral , Char , Combine , Literal , ParseException , \ # and resulting message is saved here until when new prompt comes in # Inconsistent expression from functools import reduce # just match against a list of all possible combinations hook_semantic_f : Callable [ [ str ] , str ] , `` user= '' + self.pg_user # % / % R % x % # per postgres bin/psql/settings.h except ParseException as e : : returns : if user has indeed hit return . sql_query : str if len ( res_list ) == 2 : # parsing stops right after database name # replacing \n 's with `` '' maybe has less edge cases . Or actually more . sanitized_sql , `` SELECT * FROM orders WHERE order_total_eur = 100 ; '' # tok_multiline_prompt_end : ParserElement = \ `` `` '' Initiate session by getting psql connection parameters via psql \ # % / = current database psql_rev : str = psql [ : :-1 ] # slicing is fastest operation for reverse self.parser.parse_last_found_stmt ( screen ) self.pg_name `` psql `` + bytes.decode ( self.psql_args ) + `` -- version '' | Literal ( `` \x08\r\n '' [ : :-1 ] ) demultilined_res : str = no_newlines_res psql._intercept ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C1 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 1\x1b [ 27m00 ; \x08\x08\x08\x08\x08\x08 '' ) # e.g . `` pg4n -- help '' is being run . # should parse as \n - > `` `` to avoid `` SELECT * FROM .. '' . print ( `` pg4n [ psql arguments ] < database name > '' ) # get terminal screen contents # superusers have = # prompt # Literal ( '\ '' ' ) | Literal ( ' $ ' ) | Literal ( ' ( ' ) ) # multiple elements into one . These are often combined to build functions elif len ( res_list ) == 2 : # parsing stops right after database name # Analysis is always done when user presses Return [ `` # = '' ] self.pg_pass , Literal ( `` > = '' ) | Literal ( `` # = '' ) with psycopg.connect ( `` host= '' + self.pg_host def start ( # SELECT in subquery Word ( nums ) # Inconsistent expression InconsistentExpressionChecker ( sanitized_sql , qep_analysis ) .check ( ) psql.ofilter ( b'orders ' ) # possibly provide a message to be included in next new prompt . stmt_chars : str = \ Control is only returned after psql process exits . tok_marker_caret : ParserElement = Literal ( `` ^ '' ) ZeroOrMore ( White ( ) ) from typing import List control codes . \n is newline ( carriage return \r will be added by \ multiline_prompt_ends : list [ str ] = \ assert p.parse_last_stmt ( case_query_with_newline ) == \ [ `` - # '' , `` * # '' , `` \ ' # '' , `` \ '' # '' , `` $ # '' , `` ( # '' , `` SELECT * FROM orders WHERE order_total_eur = 100 ; '' ZeroOrMore ( Char ( `` \n '' ) | Char ( `` \r '' ) | White ( ) ) debug : bool = False match_rev_prompt_and_then_rest : ParserElement = ( psql.ofilter ( case_psql_start ) stmt_res : Optional [ ParseResults ] = None assert p.parse_last_found_stmt ( case_multiple_queries_and_whitespaces ) == \ respectively . self `` `` '' Parse for a fresh prompt and everything preceding it into 2-length \ f.write ( '\n'.join ( line.rstrip ( ) for line in self.pyte_screen.display ) # and resulting message is saved until when new prompt comes in bytes.decode ( output , `` utf-8 '' ) output_filter=self.ofilter ) `` -- version '' ) stmt_chars : str = printable.translate ( str.maketrans ( `` '' , `` '' , stmt_end ) ) ) sql_parser : returns : unchanged input . SubqueryOrderByChecker ( sanitized_sql , qep_analysis ) .check ( ) psql._intercept ( b ' * ' ) `` - ! # '' , `` * ! # '' , `` \ ' ! # '' , `` \ '' ! # '' , `` $ ! # '' , `` ( ! # '' , messages are passed to , and from which corresponding warning messages \ detecting new prompt fails . sem_router = SemanticRouter ( * conn_info ) # asterisk unpacks the 5-tuple pg_name : str return assert p.parse_new_prompt ( case_trivial ) == \ `` utf-8 '' print_msg + `` \r\n\r\n '' : param input : user input characters . stmt_res_list [ 1 ] ] # `` pgdb= > SELECT def test_parse_last_found_stmt ( ) - > None : : param prompt : is output where message is injected to . A fresh prompt \ ) .check ( ) ] # * FROM orders WHERE order_total_eur = 100 ; c.interact ( input_filter=self.ifilter , psql._intercept ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 10\x1b [ 27m0 ; \x08\x08\x08\x08\x08\x08 '' ) analysis_result = StrangeHavingChecker ( `` utf-8 '' ) psql._intercept ( b'\r\n ' ) res_list [ 3 ] [ : :-1 ] , def parse_magical_return ( self , psql : str ) - > List [ str ] : return bytes ( split_prompt [ 0 ] + `` \r\n '' split_prompt : List [ str ] = self.parser.parse_new_prompt_and_rest ( tok_stmt_end : ParserElement = Char ( ' ; ' ) sql_parser : SqlParser = SqlParser ( conn ) `` Pg4n has only been tested on psql versions `` `` `` '' Handle semantic analysis modules . '' '' '' psql._intercept ( b '' \r\n\x1b [ ? 2004l\r '' ) `` . '' elif len ( res_list ) == 4 : # results include \x1b [ ? 2004h .. EqWildcardChecker ( sanitized_sql , qep_analysis ) .check ( ) # reverse string for parsing efficiency syntax_error = \ def test_intercept ( ) - > None : if analysis_result is not None : sem_router.run_analysis , psql._intercept ( b'\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) # magic strings related seemingly solely to ctrl-R use are bytes.decode ( output , `` utf-8 '' ) ) ! = [ ] : `` - * # '' , `` * * # '' , `` \ ' * # '' , `` \ '' * # '' , `` $ * # '' , `` ( * # '' , parsed_sql_query : str = self.parser.parse_last_stmt ( screen ) results : List [ str ] = [ ] ParseException , ParserElement , \ psql_output = pexpect.spawn ( # `` \r\n\x1b [ ? 2004l\r '' , `` \r\n\r\r\n '' and `` \x08\r\n '' . encoding= '' utf-8 '' , psql_output.expect ( pexpect.EOF ) self.pg4n_message = `` '' # Strange HAVING clause without GROUP BY self.pg4n_message = self.syntax_analyze ( syntax_error ) psql._intercept ( b'\x1b [ ? 2004l\r\x1b [ ? 2004htest_db- # ' ) assert psql.ofilter ( b'\x1b [ ? 2004l\r order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004htest_db= # ' ) == \ def main ( ) - > None : str ( self.supported_psql_versions ) + `` . '' if magical_return_res : assert p.parse_last_found_stmt ( case_trivial ) == \ # This will match against `` % R % x % # `` , e.g `` = > `` . # Strange HAVING clause without GROUP BY line.rstrip ( ) for line in self.pyte_screen.display ) parsed_sql_query : str = \ if stmt_res : def start ( self ) - > None : self : param db_name_parameter : is name of database we are connecting to . # % R = - , * , ' , `` ; also $ , ( if syntax_error ! = `` '' : return analysis_result : param psql : screenscraped psql string with only whitespace \ list , facilitating easy message injection . `` - > '' , `` * > '' , `` \ ' > '' , `` \ '' > '' , `` $ > '' , `` ( > '' , `` host= '' + self.pg_host self.tok_pre_port + self.tok_port + \ psql.ofilter ( b '' \r\n\x1b [ ? 2004l\r '' ) # no syntax error analysis : psql.ofilter ( b ' ; ' ) match_rev_prompt_end : ParserElement = self.tok_rev_prompt_end return has_new_prompt assert p.parse_last_found_stmt ( case_query_with_newline ) == \ pg_pass : str , assert psql._intercept ( b'\x1b [ ? 2004l\r order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004htest_db= # ' ) == \ psql.ofilter ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 100\x1b [ 27m ; \x08\x08\x08\x08\x08\x08 '' ) name . psql._intercept ( b '' \x1b [ A\rtest_db= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; \x1b [ K\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\r\n\r '' ) psql.ofilter ( b'\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) psql._intercept ( b'FROM ' ) f.write ( str ( e.explain ( ) ) + `` \n '' ) columns def ifilter ( self , input : bytes ) - > bytes : from typing import Optional except ParseException as e : | ( # or continue \x1b [ ? .. [ ' # = ' ] . def __init__ ( new_output : bytes = self._replace_prompt ( latest_output ) # as interesting things usually are at end of a long string . printable.translate ( str.maketrans ( `` '' , `` '' , stmt_end ) ) ) - > str : StringEnd ( ) from typing import Optional psql._intercept ( b'\x08\x08 ' ) def parse_last_found_stmt ( self , psql : str ) - > str : deepcopy ( self.pyte_screen ) ) self.parser.parse_syntax_error ( potential_future_contents ) # cheaper and easier to reverse & start from the end # % # = # , > from .psqlconninfo import PsqlConnInfo : param hook_semantic_f : is a callback to which scraped SQL queries are\ # for optimization reasons , check output only if len ( ) > 1 , so keyboard psql._intercept ( b'SELECT ' ) [ `` > = '' ] from copy import deepcopy assert p.parse_last_stmt ( case_select_then_insert ) == \ Word ( nums ) psql.ofilter ( case_query_1 ) from .psqlparser import PsqlParser evaluation has ended . ) if self.debug : : returns : an empty list if no presses are found . \ # This will match against `` % R % x % # `` , e.g `` - > `` . # SELECT in subquery Char , res_list = prompt_res.as_list ( ) output : bytes pg_port : str , from functools import reduce return ( # * FROM orders WHERE order_total_eur = 100 ; '' # % x = nothing , * , ! , ? c = pexpect.spawn ( `` psql `` + bytes.decode ( self.psql_args ) , # ( Literal ( '- ' ) | Literal ( ' * ' ) | Literal ( '\ '' ) | # semantic analysis : from .psqlconninfo import PsqlConnInfo split_prompt [ 1 ] , assert psql.ofilter ( case_query_2_prompt ) == \ psql._intercept ( b '' '\r ( reverse-i-search ) ` ' : `` ) | Literal ( `` \x08\r\n '' [ : :-1 ] ) results = magical_return_res.as_list ( ) tok_rev_prompt_end : ParserElement = Combine ( match_select_stmt : ParserElement = ( demultilined_res = no_newlines_res\ self.pg_port , new_output : bytes = self._check_and_act_on_repl_output ( output ) return `` '' # No semantic errors found ZeroOrMore , assert p.parse_new_prompt ( case_mixed_results ) == \ # should convert \n - > `` `` to avoid `` SELECT * FROM .. '' . hook_f : Callable [ [ str ] , str ] , parser : PsqlParser ) : e.explain ( ) ) Literal ( `` \r\n\x1b [ ? 2004l\r '' [ : :-1 ] ) : param psql : screenscraped psql string res_list [ 0 ] [ : :-1 ] def _check_psql_version ( self ) - > str : # Replacing \n 's with `` `` seems to have less edge cases . self.pg_host , `` `` '' Check PostgreSQL version via psql child process and match \ stmt_res_list [ length - 4 ] ) : stmt_res_list [ length - 4 ] ] return new_output match_rev_any_sql_stmt : ParserElement = \ c = pexpect.spawn ( passed to , and from which corresponding semantic warning messages are \ self.pg_user , wrapper ) . `` psql `` assert p.output_has_new_prompt ( case_trivial ) split_prompt [ 0 ] + `` \r\n '' otherwise a warning message . # `` pgdb= > SELECT * FROM orders WHERE order_tot # either by only having single element , or using Combine to squash ) # should parse as \n - > `` '' psql._intercept ( b'\x1b [ ? 2004l\r\x1b [ ? 1049h\x1b=\r order_id | order_total_eur | customer_id \x1b [ m\r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\x1b [ m\r\n 1 | 535.36 | 111\x1b [ m\r\n 2 | 409.80 | 217\x1b [ m\r\n 3 | 189.43 | 19\x1b [ m\r\n 4 | 144.14 | 157\x1b [ m\r\n 5 | 582.52 | 172\x1b [ m\r\n 6 | 132.85 | 206\x1b [ m\r\n 7 | 183.92 | 236\x1b [ m\r\n 8 | 424.80 | 244\x1b [ m\r\n 9 | 519.43 | 175\x1b [ m\r\n 10 | 414.55 | 234\x1b [ m\r\n 11 | 88.19 | 50\x1b [ m\r\n 12 | 591.72 | 143\x1b [ m\r\n 13 | 503.52 | 216\x1b [ m\r\n 14 | 586.06 | 181\x1b [ m\r\n 15 | 47.79 | 248\x1b [ m\r\n 16 | 330.92 | 130\x1b [ m\r\n 17 | 302.31 | 225\x1b [ m\r\n 18 | 438.38 | 26\x1b [ m\r\n 19 | 107.53 | 94\x1b [ m\r\n 20 | ' self.tok_pre_host + self.tok_host ParseResults , return prompt # prompt is malformed and is returned as-is . line.rstrip ( ) for line in self.pyte_screen.display ) ) assert p.parse_magical_return ( case_long_return ) == \ stmt_res_list [ 2 ] , psql._intercept ( case_psql_start ) ParserElement.setDefaultWhitespaceChars ( `` ) to and from which semantic error messages are received in return . `` `` '' Parse for an empty prompt , to detect when a query \ from .psqlwrapper import PsqlWrapper has_new_prompt : bool = False # asterisk unpacks the 5-tuple match_psql_conninfo : ParserElement = ( match_rev_prompt_end : ParserElement = \ stmt_res : ParseResults = None `` `` '' Parse for an empty prompt and everything preceding it \ # should convert \n - > `` '' to avoid `` order_tot al_eur '' # Implied expression ParseException , def output_has_new_prompt ( self , psql : str ) - > bool : : returns : if user has hit return . .replace ( db_name + `` - # '' , `` '' ) psql._intercept ( b'\x08\x08\x08\x08\x08\x08 ' ) `` - ? # '' , `` * ? # '' , `` \ ' ? # '' , `` \ '' ? # '' , `` $ ? # '' , `` ( ? # '' , results = [ `` , match_version_stmt : ParserElement = ( debug : bool = False if stmt_res is not None : analysis_result = \ assert p.output_has_magical_return ( case_long_return ) # ORDER BY in subquery : param hook_f : is a callback to which scraped SQL queries are passed \ output to pyte screen for future screen-scraping . `` `` '' User input filter function for pexpect.interact : not used . Stream ( potential_future_screen ) stmt_res_list [ length - 3 ] , Word ( self.prompt_chars ) + \ magical_return_res = \ Literal ( `` ? [ \x1b '' ) # in this case control code parameter self.pg_pass , ( StringEnd ( ) # output may stop at end of db name , return results match_rev_any_sql_stmt [ `` \rl4002 ? [ \x1b\n\r '' ] is expected , or otherwise no injection is made . match_select_stmt : ParserElement = \ Literal , Word , \ results = [ stmt_res_list [ 3 ] , analysis_result = ImpliedExpressionChecker ( psql.ofilter ( b'\x08order_total_eur = 0 AND order_total_eur = 10\x1b [ C\x1b [ 1P ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) `` port= '' + self.pg_port Opt , conn White , def main ( ) - > None : lambda syntax_error_analysis : `` '' , psql._intercept ( b'\r\x1b [ C ' ) with psycopg.connect ( results = [ stmt_res_list [ length - 3 ] , intercepted output . '' '' '' str ( self.supported_psql_versions ) sem_router = SemanticRouter ( * conn_info ) version_msg = self._check_psql_version ( ) def output_has_magical_return ( self , psql : str ) - > bool : identbodychars , nums psql._intercept ( b'\r\n\x1b [ ? 2004l\r ' ) # feed query to semantic analysis hook function # save a potential warning to be included in before next fresh prompt . # breaks , because both of these work right in straight psql . See : # ORDER BY in subquery ParseResults , ParserElement , StringEnd , White , Word , ZeroOrMore , \ # tok , or token , is parsing element with only single element output , psql._intercept ( b'\x08order_total_eur = 0 AND order_total_eur = 1\x1b [ 1P00 ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) self.match_rev_magical_returns.parse_string ( psql_rev ) new_output = self._replace_prompt ( latest_output ) lambda x , y : x + y , sys.argv [ 1 : ] , `` '' ... : returns : if output has a weird Return press . ) : print ( e.explain ( ) ) ZeroOrMore ( White ( ) ) + CaselessLiteral ( `` SELECT '' ) match_psql_conninfo : ParserElement = \ self.pg_user , CaselessLiteral ( `` SELECT '' ) PsqlParser ( ) self.semantic_analyze : Callable [ [ str ] , str ] = hook_semantic_f Literal ( `` \r\n\x1b [ ? 2004l\r '' [ : :-1 ] ) \ from shutil import get_terminal_size # Parsing functions common to more than 1 parsing functions are listed here # TODO ( ? ) : We may have to match for errors def get ( self ) - > ( str , str , str , str , str ) : results = [ ) unreversed_flattened_res : str = \ # If there is a fresh prompt : tok_rev_prompt_end : ParserElement = \ # for simplicity , just use pexpect here prompt_res : ParseResults = None psql._intercept ( b'\x08order_total_eur = 0 AND order_total_eur = 10\x1b [ C\x1b [ 1P ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) qep_analysis : QEPAnalysis = QEPParser ( conn=conn ) .parse ( sql_query ) # Wildcards without LIKE if self.pg4n_message ! = `` '' : # Implied expression Only one ( static ) class instance is intended for use in program . demultilined_res = demultilined_res.replace ( prompt , `` '' ) output to pyte screen for screenscraping . # keyboard input does not trigger parsing f = open ( `` psqlparser.log '' , `` a '' ) psql.ofilter ( b '' \x08\x08\x08= ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m=\x1b [ 27m 100 ; \x08\x08\x08\x08\x08\x08 '' ) self.analyze : Callable [ [ str ] , str ] = hook_f psql._intercept ( return_press_1 ) psql = PsqlWrapper ( assert p.parse_last_stmt ( case_multiple_queries_and_whitespaces ) == \ # command-line arguments prevent interactive sessions ( e.g pg4n -- help ) if prompt_res : # To save time , since linebreak prompts are only removed , match_rev_any_sql_stmt : ParserElement = ( psql._intercept ( b'SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; ' ) analysis_result = SubqueryOrderByChecker ( sys.argv [ 1 ] .encode ( `` utf-8 '' ) , `` password= '' + self.pg_pass psql.ofilter ( b '' \x1b [ A\rtest_db= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; \x1b [ K\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\r\n\r '' ) ParserElement , tok_stmt_end : ParserElement = \ and then starting the session . '' '' '' psql.ofilter ( b'\x08order_total_eur = 0 AND order_total_eur = 1\x1b [ 1P00 ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) psql.ofilter ( b'FROM ' ) print ( e.explain ( ) ) from .semanticrouter import SemanticRouter psql.ofilter ( return_press_1 ) Combine , dimensions= ( self.rows , self.cols ) ( StringEnd ( ) | ( Literal ( `` ? [ \x1b '' ) self.pg_tuple : Optional [ Tuple [ str , str , str , str , str ] ] = None : returns : a prompt with injected message . ) as conn : self.syntax_analyze : Callable [ [ str ] , str ] = hook_syntax_f sanitized_sql : exp.Expression = sql_parser.parse_one ( sql_query ) ( Literal ( '= ' ) | Literal ( '^ ' ) ) has_new_prompt = True child process , initializing semantic analysis and wrapper modules , \ def run_analysis ( self , sql_query : str ) - > str : # Comparing different domains return `` '' # No semantic errors found def run_analysis ( psql.ofilter ( b'\x1b [ ? 2004l\r\x1b [ ? 2004htest_db- # ' ) analysis_result : Optional [ str ] = None List is empty if no fresh prompt was found . Combine ( res_list [ 1 ] [ : :-1 ] + res_list [ 0 ] [ : :-1 ] split_prompt : List [ str ] = \ potential_future_screen_output_sink = \ version_msg = self.check_psql_version ( ) return `` '' # ( Literal ( ' # ' ) | Literal ( ' > ' ) ) ) expected . # and save resulting message bytes.decode ( prompt , `` utf-8 '' ) ) - > Optional [ Tuple [ str , str , str , str , str ] ] : | Literal ( `` \r\n\r\r\n '' [ : :-1 ] ) self.pg_port , : returns : a two-part list with everything before the prompt \ f.close ( ) psql.ofilter ( b ' * ' ) sem_router.run_analysis , tok_rev_error self.pg4n_message = `` '' tok_marker_caret parser : PsqlParser # an insightful syntax error message from the syntax analysis . tok_rev_prompt_end if conn_info is not None : return unreversed_flattened_res against versions pg4n is tested with . prompt = db_name + multiline_prompt_end `` password= '' + self.pg_pass ) as conn : f.write ( '\n'.join ( ... + StringEnd ( ) ) ) ] reduce ( # Combine ( psql.start ( ) match_rev_magical_returns : ParserElement = ( ] pg_port : str , : param hook_syntax_f : is a callback to which scraped syntax error \ `` `` '' Start psql process and then start feeding hook function with \ # ^either stops after dbname or includes \x1b [ ? 2004l ... if self.parser.parse_magical_return ( identbodychars , has_magical_return : bool = False hook_syntax_f : Callable [ [ str ] , str ] , nums # for matching . # match_error : ParserElement = \ : param psql_args : are the command-line arguments pg4n has been called \ def get ( # TODO/BUG : removing \n 's is a tough problem , see : prompt_res = match_rev_prompt_and_then_rest.parse_string ( psql_rev ) # ParserElement for these would look this : dimensions= ( self.rows , self.cols ) ) # prompt2 per bin/psql/prompt.c : new_output : bytes = self.check_and_act_on_repl_output ( output ) ZeroOrMore ( Char ( `` \n '' ) | Char ( `` \r '' ) | White ( ) ) + \ # Reversing happens for performance reasons , self.tok_pre_port + self.tok_port assert p.parse_last_found_stmt ( case_empirical_1 ) == \ 5-tuple or None . psql_args : bytes , # feed query to hook function and save resulting message # Psql is not connecting to any database , psql._intercept ( b'\x08\x08\x08\x08 ' ) def _intercept ( # `` \r\n\x1b [ ? 2004l\r '' , `` \r\n\r\r\n '' and `` \x08\r\n '' . # If we have a semantic error message waiting def __init__ ( self , def parse_last_stmt ( self , psql : str ) - > str : # from functools import reduce assert p.parse_last_found_stmt ( case_select_then_select ) == \ # Replacing \n 's has some edge cases where wrapper transparency Word ( self.prompt_chars ) `` - * > '' , `` * * > '' , `` \ ' * > '' , `` \ '' * > '' , `` $ * > '' , `` ( * > '' , magical_return_res : ParseResults = None `` dbname= '' + self.pg_name '' , pg_host : str , assert p.parse_last_stmt ( case_multiline_query ) == \ PsqlParser ( ) ) psql.ofilter ( b'\x08\x08\x08\x08 ' ) columns : list [ Column ] = sql_parser.get_query_columns ( sanitized_sql ) return ( self.pg_host , magical_return_res = \ from .psqlparser import PsqlParser sql_query , ) line.rstrip ( ) for line in potential_future_screen.display pg_pass : str , magical_return_res : Optional [ ParseResults ] = None | Literal ( `` \r\n\r\r\n '' [ : :-1 ] ) \ analysis_result = InconsistentExpressionChecker ( # `` = > SELECT * FROM orders WHERE order_tot reduce ( lambda x , y : x + y [ : :-1 ] , results , `` '' ) ParserElement.setDefaultWhitespaceChars ( `` '' ) # % R = = , ^ assert psql.ofilter ( b'\x1b [ ? 2004htest_db= # ' ) == \ # Based on exploratory testing , screen : str = '\n'.join ( if split_prompt == [ ] : name . '' '' '' assert p.parse_last_found_stmt ( case_select_then_insert ) == \ pg_name : str if analysis_result is not None : ZeroOrMore ( White ( ) ) + tok_stmt_end + ... + \ no_newlines_res = reversed_flattened_res.replace ( '\n ' , ' ' ) columns : list [ Column ] = sql_parser.get_query_columns ( sanitized_sql ) from .psqlwrapper import PsqlWrapper import sys psql.ofilter ( b'\x08\x08\x08\x08\x08\x08 ' ) self.tok_rev_prompt_end + \ print ( bytes.decode ( psql_output.before ) ) new_output : bytes = `` '' results = prompt_res.as_list ( ) stmt_res_list = stmt_res.as_list ( ) # SUM/AVG ( DISTINCT ) import pexpect psql._intercept ( b '' \x08\x08\x08= ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m=\x1b [ 27m 100 ; \x08\x08\x08\x08\x08\x08 '' ) ... # has already been parsed as prompt_chars prompt_res = match_rev_prompt_and_then_rest.parse_string ( psql_rev ) import os Opt ( White ( ) ) ... control codes and newlines ( without carriage returns ) . from .semanticrouter import SemanticRouter def __init__ ( self , psql_args : bytes , screen : str = \ return new_output has_magical_return = True for multiline_prompt_end in self.multiline_prompt_ends : match_version_stmt : ParserElement = \ lambda x : `` '' , assert psql._intercept ( b'\x1b [ ? 2004htest_db= # ' ) == \ : returns : ( hostname , port , user , password , database name ) \ match_rev_prompt_and_then_rest : ParserElement = \ self.pg4n_message = self.analyze ( parsed_sql_query ) `` `` '' Parse for weird Return presses . res_list = prompt_res.as_list ( ) # optimization : do not spend time parsing if there is no message : # 'rev ' in variable names is shorthand for reversed . Otherwise has newline text . received in return . print ( `` Fatal error : psql connection info could not be parsed\n '' to 2 cells . psql_rev = psql [ : :-1 ] psql.ofilter ( b'\x1b [ ? 2004l\r\x1b [ ? 1049h\x1b=\r order_id | order_total_eur | customer_id \x1b [ m\r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\x1b [ m\r\n 1 | 535.36 | 111\x1b [ m\r\n 2 | 409.80 | 217\x1b [ m\r\n 3 | 189.43 | 19\x1b [ m\r\n 4 | 144.14 | 157\x1b [ m\r\n 5 | 582.52 | 172\x1b [ m\r\n 6 | 132.85 | 206\x1b [ m\r\n 7 | 183.92 | 236\x1b [ m\r\n 8 | 424.80 | 244\x1b [ m\r\n 9 | 519.43 | 175\x1b [ m\r\n 10 | 414.55 | 234\x1b [ m\r\n 11 | 88.19 | 50\x1b [ m\r\n 12 | 591.72 | 143\x1b [ m\r\n 13 | 503.52 | 216\x1b [ m\r\n 14 | 586.06 | 181\x1b [ m\r\n 15 | 47.79 | 248\x1b [ m\r\n 16 | 330.92 | 130\x1b [ m\r\n 17 | 302.31 | 225\x1b [ m\r\n 18 | 438.38 | 26\x1b [ m\r\n 19 | 107.53 | 94\x1b [ m\r\n 20 | ' analysis_result = SumDistinctChecker ( match_error_statement : ParserElement = ( version_info = pexpect.spawn ( `` `` '' psql.ofilter ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 10\x1b [ 27m0 ; \x08\x08\x08\x08\x08\x08 '' ) : param psql : screen-scraped psql output . # psqlwrapper.log ( capturing terminal stream ) in working directory return analysis_result self.pg_name ) self.tok_pre_user + self.tok_user + \ results : list [ str ] = [ ]","['src/pg4n/main.py', 'src/pg4n/psqlconninfo.py', 'src/pg4n/psqlparser.py', 'src/pg4n/psqlwrapper.py', 'src/pg4n/semanticrouter.py', 'src/pg4n/test/test_psqlparser.py', 'src/pg4n/test/test_psqlwrapper.py']",2022-11-17 18:29:35+00:00,2022-11-21 10:02:30+00:00,2022-12-12 14:47:03+02:00
79,cd7168bd9791c3c51875f85850371cec52a72e57,0.0002187251520808,0,"Removing ` \n 's is a tough problem , see ought to replace \n with ` ` to avoid ` SELECT * FROM ` .",Edge cases with newlined psql queries,Merge pull request # 80 from Project-C-SQL/fix/wrapper,"psql.ofilter ( b'\x08\x08 ' ) b '' order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\r\nTest\r\n\r\n\x1b [ ? 2004htest_db= # `` case_query_with_newline = \ # extra whitespace : identbodychars , nums b ' order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n ' + b'\r\n ' + b'Test ' + b'\r\n\r\n ' + b'\x1b [ ? 2004hpgdb= # ' # ctrl-R to previous query . Query includes a return press near end . `` psql ( 14.5 ) \nType \ '' help\ '' for help.\n\npgdb= # SELECT * FROM\npgdb- # orders ; '' if self.debug : from shutil import get_terminal_size ( CaselessLiteral ( `` > - '' ) | CaselessLiteral ( `` # - '' ) ) + \ assert p.parse_last_found_stmt ( case_multiline_query ) == \ psql.ofilter ( b'\r\n\x1b [ ? 2004l\r ' ) no_newlines_res = reversed_flattened_res.replace ( '\n ' , `` ) psql.ofilter ( b'SELECT ' ) from functools import reduce self.tok_rev_prompt_end + \ # extra 2 whitespaces : is_select : bool = False ZeroOrMore ( Char ( `` \n '' ) | Char ( `` \r '' ) | White ( ) ) + \ assert psql.ofilter ( case_query_2_prompt ) == \ # reverse given string , match reversed tokens , pick first match , # complicated case : user has ctrl-R 'd , copy-pasted command or something , version_ok : bool = version in self.supported_psql_versions # saved stream of characters . Most likely the control streams depend # If parsing was successful , pick interesting parts . db_name = stmt_res_list [ length - 1 ] [ : :-1 ] # in live scenarios most of the time , but I can not reproduce it with this Literal ( `` ERROR : '' ) results = [ stmt_res_list [ length - 3 ] , match_prompt : ParserElement = \ c = pexpect.spawn ( `` psql `` + bytes.decode ( self.psql_args ) , match_error : ParserElement = \ identbodychars b'\x1b [ ? 2004l\r order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\r\nTest\r\n\r\n\x1b [ ? 2004htest_db= # ' psql.ofilter ( b'FROM ' ) # Literal ( `` ERROR : '' ) # b ' order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\r\nTest\r\n\r\n\x1b [ ? 2004hpgdb= # ' # replacing \n 's with `` '' maybe has less edge cases . psql.ofilter ( b'\x1b [ ? 2004htest_db- # ' ) tok_stmt_end : param psql : psql -- version output tok_rev_prompt_end : ParserElement = \ psql.ofilter ( b'\r\x1b [ K\x1b > \x1b [ r\x1b [ ? 1049l ' ) b ' 207.60 | 9\x1b [ m\r\n 21 | 471.12 | 179\x1b [ m\r\n : \x1b [ K ' ) # reverse back , concatenate , and remove \n 's assert psql.ofilter ( case_query_2_prompt ) == \ stmt_res = match_version_stmt.parse_string ( psql ) if len ( res_list ) == 4 : # includes \x1b [ ? 2004l `` SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; '' return reversed_flattened_res stmt_res = match_last_stmt.parse_string ( psql_rev ) case_multiple_queries_and_whitespaces = \ psql.ofilter ( b '' \r\n\x1b [ ? 2004l\r '' ) match_sql_stmt_end : ParserElement = \ psql.ofilter ( b ' * ' ) self.tok_rev_prompt_end case_select_then_insert = `` psql ( 14.5 ) \nType \ '' help\ '' for help.\n\npgdb= # SELECT * FROM orders ; \npgdb= # INSERT INTO orders VALUES ( 6 , 6 , 6 ) ; '' psql.ofilter ( b'\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) ( StringEnd ( ) | ( Literal ( `` ? [ \x1b '' ) def __init__ ( self , db_name_parameter : bytes , ZeroOrMore ( White ( ) ) + tok_stmt_end + ... + \ Word ( prompt_chars ) + Char ( '\n ' ) try : assert psql.ofilter ( b'\x1b [ ? 2004htest_db= # ' ) == \ # magic strings related to solely to ctrl-R use are ( CaselessLiteral ( `` - > '' ) | CaselessLiteral ( `` - # '' ) ) # print ( psql.pyte_screen.display ) elif len ( res_list ) == 2 : # stops right after database name CaselessLiteral ( `` TCELES '' ) + ( CaselessLiteral ( `` > = '' ) | CaselessLiteral ( `` # = '' ) ) # case_query_3_prompt = b ' order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004hpgdb= # ' match_select_stmt : ParserElement = \ Literal ( `` psql ( PostgreSQL ) `` ) + Combine ( Word ( nums ) + ' . ' + Word ( nums ) ) psql.ofilter ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 10\x1b [ 27m0 ; \x08\x08\x08\x08\x08\x08 '' ) ZeroOrMore ( Char ( `` \n '' ) | Char ( `` \r '' ) ) + self.match_whole_rev_sql_stmt # BUG : Will match until previous SELECT query , if newest is e.g INSERT tok_prompt_linebreak : ParserElement = \ return demultilined_res result = stmt_res.as_list ( ) [ 1 ] # Something weird going this test case . Pyte understands this case right # psql.ofilter ( b'\x08\x08\x08\x08 ' ) # multiline query psql.ofilter ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 100\x1b [ 27m ; \x08\x08\x08\x08\x08\x08 '' ) case_query_2_prompt = b '' order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004htest_db= # `` # then reverse the matched string . match_prompt + match_sql_stmt + match_sql_stmt_end version : str = self.parser.parse_psql_version ( version_info_str ) match_sql_stmt : ParserElement = \ b'\r\nTest\r\n\r\n\x1b [ ? 2004htest_db= # ' self.db_name : bytes = db_name_parameter # psql.ofilter ( case_query_3 ) MatchFirst ( [ tok_prompt ] ) # `` '' str ( self.supported_psql_versions ) + `` . '' Literal ( `` > = '' ) | Literal ( `` # = '' ) psql.ofilter ( b'\r\n ' ) # TODO : For some reason Literal ( `` > = '' ) does not provide a match , # ready for analysis . def parse_psql_version ( self , psql : str ) - > str : # parser tokens : psql = new_psqlwrapper ( ) assert p.parse_last_found_stmt ( case_select_then_insert ) == \ CaselessLiteral , Char , Combine , Literal , ParseException , \ psql.ofilter ( b ' ; ' ) case_query_2_prompt = \ `` SELECT * FROM orders ; '' from pyparsing import \ if version_ok : f = open ( `` psqlparser.log '' , `` a '' ) stmt_res : ParseResults = None # al_eur = 100 ; '' else : # ctrl-R to previous query with three key presses searching ( 1 .. 0 .. 0 ) . Press return . # in live scenarios most of the time , but I can not reproduce it with this match_rev_sql_stmt_start : ParserElement = \ case_empirical_1 = \ b'\r\x1b [ 16Ppgdb= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_tot\x08\r\n\x1b [ ? 2004l\r ' ( StringEnd ( ) | ( Literal ( `` ? [ \x1b '' ) + \ `` SELECT * FROM orders WHERE order_total_eur = 100 ; '' version_info = \ # TODO : allow multiple statements def __init__ ( self , psql_args : bytes , # Parse prompt text at the end , so multiline queries can be cleaned version_msg = self.check_psql_version ( ) psql.ofilter ( b '' \x08\x08\x08= ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m=\x1b [ 27m 100 ; \x08\x08\x08\x08\x08\x08 '' ) Word ( stmt_chars ) psql.ofilter ( b'\x08order_total_eur = 0 AND order_total_eur = 10\x1b [ C\x1b [ 1P ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) psql.ofilter ( b '' '\r ( reverse-i-search ) ` ' : `` ) parse_sql_stmt : ParserElement = \ psql.ofilter ( b'\r\x1b [ C ' ) # TODO/BUG : removing \n 's is a tough problem , see : # BUG ( ? ) : Assumes only single statement query if is_select : # TODO : strip `` - > '' / '' - # '' from string to allow multiline queries # Fix it by matching rev_stmt_start also against rev_prompt `` `` '' Parse for psql version and return version number . CaselessLiteral ( `` SELECT `` ) # All interesting stmts are 'select ' ( CaselessLiteral ( `` = > '' ) | CaselessLiteral ( `` = # '' ) ) result : str = `` '' # Something weird going these test case . Pyte understands this case right assert psql.ofilter ( b'\x1b [ ? 2004l\r order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004htest_db= # ' ) == \ match_rev_any_sql_stmt : ParserElement = \ def check_psql_version ( self ) - > str : # Arrow-up to previous query , alt-B until 'orders WHERE ' and remove the from pyparsing import CaselessLiteral , Char , Literal , MatchFirst , \ psql.ofilter ( b '' \x08\x08\x08t ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_to\x1b [ 7mt\x1b [ 27mal_eur = 100 ; \x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08 '' ) supported_psql_versions : list [ str ] = [ `` 14.5 '' ] match_whole_rev_sql_stmt : ParserElement = \ stmt_res_list [ length - 4 ] ] # TODO ( ? ) : We may have to match for errors return `` '' # should parse as \n - > `` `` to avoid `` SELECT * FROM .. '' . # case_query_3 = \ tok_rev_prompt_linebreak : ParserElement = \ self.psql_args : bytes = psql_args psql.ofilter ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C1 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 1\x1b [ 27m00 ; \x08\x08\x08\x08\x08\x08 '' ) # match_error : ParserElement = \ psql.ofilter ( b'\x08order_total_eur = 0 AND order_total_eur = 1\x1b [ 1P00 ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) # psql.ofilter ( b'\x08\x1b [ 1P ' ) assert p.parse_last_found_stmt ( case_multiple_queries_and_whitespaces ) == \ f.close ( ) : returns : version string ( e.g `` 14.5 '' ) return `` Pg4n has only been tested on psql versions `` + \ ( Literal ( `` > = '' ) | Literal ( `` # = '' ) ) + \ # properly . # assert p.parse_last_found_stmt ( case_select_then_insert ) == \ # psql.ofilter ( return_press_1 ) psql.ofilter ( b'\r\n\r\r\n ' ) psql.ofilter ( b'\x08\x08\x08\x08\x08\x08 ' ) if version_msg ! = `` '' : self.match_rev_any_sql_stmt + Word ( self.prompt_chars ) tok_stmt_end + ... + match_rev_sql_stmt_start # case_select_then_insert = `` psql ( 14.5 ) \nType \ '' help\ '' for help.\n\npgdb= # SELECT * FROM orders ; \npgdb= # INSERT INTO orders VALUES ( 6 , 6 , 6 ) ; '' psql.ofilter ( b'\r ( reverse-i-search ) ` \ ' : ' ) pexpect.spawn ( `` psql `` + bytes.decode ( self.psql_args ) psql.ofilter ( b'SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; ' ) psql.ofilter ( b'orders ' ) b ' order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004hpgdb= # ' match_sql_stmt_start : ParserElement = \ # complicated case : user has ctrl-R 'd , copypasted command or something . # reverse string for parsing efficiency # psql.ofilter ( b'\x08\x08\x08\x08\x08\x08 ' ) c = pexpect.spawn ( `` psql `` + bytes.decode ( self.db_name ) , # If it is SELECT , remove multiline delimiters and then statement is match_version_stmt : ParserElement = \ assert p.parse_last_found_stmt ( case_query_with_newline ) == \ match_last_stmt : ParserElement = \ if len ( res_list ) == 4 : # results include \x1b [ ? 2004l return result psql.ofilter ( b'\x1b [ ? 2004l\r\x1b [ ? 1049h\x1b=\r order_id | order_total_eur | customer_id \x1b [ m\r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\x1b [ m\r\n 1 | 535.36 | 111\x1b [ m\r\n 2 | 409.80 | 217\x1b [ m\r\n 3 | 189.43 | 19\x1b [ m\r\n 4 | 144.14 | 157\x1b [ m\r\n 5 | 582.52 | 172\x1b [ m\r\n 6 | 132.85 | 206\x1b [ m\r\n 7 | 183.92 | 236\x1b [ m\r\n 8 | 424.80 | 244\x1b [ m\r\n 9 | 519.43 | 175\x1b [ m\r\n 10 | 414.55 | 234\x1b [ m\r\n 11 | 88.19 | 50\x1b [ m\r\n 12 | 591.72 | 143\x1b [ m\r\n 13 | 503.52 | 216\x1b [ m\r\n 14 | 586.06 | 181\x1b [ m\r\n 15 | 47.79 | 248\x1b [ m\r\n 16 | 330.92 | 130\x1b [ m\r\n 17 | 302.31 | 225\x1b [ m\r\n 18 | 438.38 | 26\x1b [ m\r\n 19 | 107.53 | 94\x1b [ m\r\n 20 | ' Char ( '\n ' ) + Word ( prompt_chars ) + \ # Is the statement a SELECT statement ? `` SELECT * FROM orders WHERE order_total_eur = 100 ; '' psql.ofilter ( b'\x08\x08\x08\x08 ' ) print ( version_msg ) db_name : str = `` '' version_info_str : str = bytes.decode ( version_info.before ) # magic strings related seemingly solely to ctrl-R use are version_info.expect ( pexpect.EOF ) assert p.parse_last_found_stmt ( case_empirical_1 ) == \ `` -- version '' ) # but works fine without the whitespace .. stmt_res = match_rev_last_stmt.parse_string ( psql_rev ) if stmt_res : # on terminal size , and can not be just copy-pasted from live tests . stmt_res_list [ length - 3 ] , # saved stream of characters . `` `` is_select = \ .replace ( db_name + `` - > '' , `` '' ) \ # Match statement that might have \r\n or whitespace at the end . tok_rev_prompt : ParserElement = \ ParseResults , ParserElement , StringEnd , White , Word , ZeroOrMore , \ # psql.ofilter ( b'\x08\x08 ' ) `` psql ( 14.5 ) \nType \ '' help\ '' for help.\n\npgdb= # SELECT * FROM orders ; \npgdb= # INSERT INTO orders VALUES ( 6 , 6 , 6 ) ; \npgdb= # SELECT * FROM\n orders WHERE order_total_eur = 100 ; `` # * FROM orders WHERE order_total_eur = 100 ; tok_prompt : ParserElement = \ # Broken case found in empirical testing match_rev_last_stmt : ParserElement = \ tok_rev_prompt_end psql.ofilter ( b '' \x1b [ A\rtest_db= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; \x1b [ K\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\r\n\r '' ) # `` pgdb= > SELECT * FROM orders WHERE order_tot psql.ofilter ( b'\x1b [ ? 2004l\r\x1b [ ? 2004htest_db- # ' ) ParseException , ParseResults , ParserElement , StringEnd , Word , ZeroOrMore , \ f.write ( str ( e.explain ( ) ) + `` \n '' ) psql.ofilter ( case_query_2 ) except ParseException as e : # `` pgdb= > SELECT Literal ( `` > = '' ) | Literal ( `` # = '' ) demultilined_res = no_newlines_res\ # TODO : test case for multiline - > queries ZeroOrMore ( White ( ) ) + CaselessLiteral ( `` SELECT '' ) case_multiline_query = \ `` sql ( 14.5 ) \nType \ '' help\ '' for help.\n\npgdb= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n '' # fresh prompt in this case : # fresh prompt : .replace ( db_name + `` - # '' , `` '' ) # b'SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; ' # parser combinations assert psql.pg4n_message == `` Test '' match_select_stmt.parse_string ( no_newlines_res ) is not [ ] # should parse as \n - > `` '' `` `` '' stmt_res_list [ length - 4 ] ] # reverse order elif len ( res_list ) == 2 : # parsing stops right after database name # assert psql.ofilter ( case_query_3_prompt ) == \ results = [ stmt_res_list [ length - 2 ] , ( CaselessLiteral ( `` > = '' ) | CaselessLiteral ( `` # = '' ) ) + \ `` sql ( 14.5 ) \nType \ '' help\ '' for help.\n\npgdb= # SELECT * FROM orders WHERE order\n_total_eur = 100 ; \n\n\n '' b '' \x1b [ A\rtest_db= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; \x1b [ K\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\r\n\r '' # Arrow-up to previous query , alt-B until 'orders WHERE ' and remove the","['src/pg4n/psqlparser.py', 'src/pg4n/psqlwrapper.py', 'src/pg4n/test/test_psqlparser.py', 'src/pg4n/test/test_psqlwrapper.py']",2022-11-19 17:10:41+00:00,2022-12-12 12:47:05+00:00,2022-11-21 16:23:44+02:00
81,535fdf800713ce7b74f1e330e9c02af0bb981db2,0.983263373374939,0,,Detect syntax errors to allow syntax error analysis in future,Merge pull request # 95 from Project-C-SQL/feat/error-handling-and-syntax-error-detection,"def parse_new_prompt_and_rest ( self , psql : str ) - > list [ str ] : prompt_res = match_rev_prompt_end.parse_string ( psql_rev ) Literal ( `` psql ( PostgreSQL ) `` ) + Combine ( Word ( nums ) + ' . ' + Word ( nums ) ) SubquerySelectChecker ( sanitized_sql , sql_parser ) .check ( ) from pyparsing import ( prompt_res = match_rev_prompt_end.parse_string ( psql_rev ) # Licensed under MIT . self.tok_rev_prompt_end psql_args : str # Semantic analysis is always done when user presses Return after most recent query . pg_user : str , # Comparing different domains Char ( ' ; ' ) from shutil import get_terminal_size psql.ofilter ( b'\r\n\r\r\n ' ) self , analysis_result = SubquerySelectChecker ( if output [ 0:2 ] == b'\r\n ' : qep_analysis def test_parse_last_stmt ( ) - > None : except Exception : # Matches only program errors ( see flake8 rule E722 ) ) - > bytes : # Opt ( Literal ( ' * ' ) | Literal ( ' ! ' ) | Literal ( ' ? ' ) , `` '' ) psql.ofilter ( b'\x1b [ ? 2004htest_db- # ' ) except ParseException : psql.ofilter ( b '' '\r ( reverse-i-search ) ` ' : `` ) assert p.output_has_new_prompt ( case_mixed_results ) # SUM/AVG ( DISTINCT ) def parse_new_prompt ( self , psql : str ) - > List [ str ] : def _check_and_act_on_repl_output ( # AND-clause will stop executing after first False . match_rev_magical_returns.parse_string ( psql_rev ) analysis_result = CmpDomainChecker ( sanitized_sql , columns ) .check ( ) self.tok_pre_database + self.tok_database assert p.parse_last_stmt ( case_trivial ) == \ pg_user : str , `` `` '' line and then the prompt , to allow easy message injection . res_list [ 1 ] [ : :-1 ] # see how the screen would look like , but still allow injecting to pick up relevant SQL statements and syntax errors for hook functions . '' '' '' if self.parser.output_has_magical_return ( res_list [ 2 ] [ : :-1 ] Word , assert p.parse_last_found_stmt ( case_multiline_query ) == \ psql_rev : str = psql [ : :-1 ] if magical_return_res : if self.pg4n_message ! = `` '' \ def test_output_has_new_prompt ( ) - > None : # Literal ( `` ERROR : '' ) return input reduce ( lambda x , y : x + y [ : :-1 ] , results , `` '' ) psql._intercept ( b'\r\n\r\r\n ' ) # Wildcards without LIKE `` `` '' if output [ 0:2 ] == b '' \r\n '' : ) : analysis_result : Optional [ str ] = None def test_output_has_magical_return ( ) - > None : return self.pg_tuple psql.start ( ) intercepted queries and syntax errors . psql._intercept ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 100\x1b [ 27m ; \x08\x08\x08\x08\x08\x08 '' ) # Turn on verbose output to psqlparser.log file in working directory from pyparsing import Literal , Word , ParseException , ParserElement , \ `` psql `` + bytes.decode ( self.psql_args ) , prompt_res : Optional [ ParseResults ] = None : returns : an empty list if no prompt found . Otherwise has [ ' > = ' ] or \ unreversed_flattened_res : str = reduce ( def test_parse_magical_return ( ) - > None : # SQL parser , QEP parser , or an analysis module exploded : # Since latest_output contains error details , we will have to bytes.decode ( latest_output ) # `` = > SELECT psql.ofilter ( b'\r\n\x1b [ ? 2004l\r ' ) `` - ! > '' , `` * ! > '' , `` \ ' ! > '' , `` \ '' ! > '' , `` $ ! > '' , `` ( ! > '' , pg_host : str , return bytes ( line and then the prompt , to allow easy message injection . sql_parser : SqlParser = SqlParser ( conn ) assert psql._intercept ( fresh_prompt_1 ) == \ self.tok_pre_database + self.tok_database + \ match_rev_magical_returns : ParserElement = \ psql = PsqlWrapper ( sys.argv [ 1 ] .encode ( `` utf-8 '' ) , `` `` '' Start psql process and feed hook functions with \ encoding= '' utf-8 '' , assert psql._intercept ( case_query_2_prompt ) == \ main.py [ psql arguments ] < database name > '' ) def check_psql_version ( self ) - > str : self.tok_pre_user + self.tok_user Literal , def parse_new_prompt_and_rest ( self , psql : str ) - > List [ str ] : # for optimization reasons , check output only if len ( ) > 1 , so most psql._intercept ( case_query_1 ) `` `` '' Check for weird Return presses . self.parser.parse_new_prompt_and_rest ( tok_stmt_end psql.ofilter ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C1 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 1\x1b [ 27m00 ; \x08\x08\x08\x08\x08\x08 '' ) .replace ( db_name + `` - > '' , `` '' ) \ and self.parser.parse_new_prompt ( tok_rev_error : ParserElement = Literal ( `` : RORRE '' ) res_list [ 2 ] [ : :-1 ] + res_list [ 1 ] [ : :-1 ] + res_list [ 0 ] [ : :-1 ] try : self.tok_rev_prompt_end def test_parse_new_prompt ( ) - > None : if len ( res_list ) == 4 : # results include \x1b [ ? 2004l # prompt1 per bin/psql/prompt.c : match_rev_last_stmt : ParserElement = ( split_prompt [ 1 ] , assert psql.ofilter ( fresh_prompt_1 ) == \ print ( f '' { os.path.basename ( sys.executable ) } \ results = [ : returns : a two-part list with everything before the prompt \ assert p.parse_last_stmt ( case_select_then_select ) == \ match_rev_last_stmt : ParserElement = \ ' . ' def test_ofilter ( ) - > None : StringEnd , self.pg_tuple = ( if prompt_res : ( Literal ( ' # ' ) | Literal ( ' > ' ) ) are received . `` port= '' + self.pg_port no_newlines_res = unreversed_flattened_res.replace ( '\n ' , ' ' ) def check_and_act_on_repl_output ( self , latest_output : bytes ) - > bytes : Literal ( `` psql ( PostgreSQL ) `` ) psql_rev = psql [ : :-1 ] # slicing is fastest operation for reversing # prompt : analysis_result = CmpDomainChecker ( bytes.decode ( prompt , `` utf-8 '' ) ) return has_magical_return # rev means reversed , these are for performance reasons . from typing import Optional , Tuple return `` Pg4n has only been tested on psql versions `` + \ analysis_result = EqWildcardChecker ( print_msg + `` \r\n\r\n '' if self.parser.output_has_new_prompt ( self.tok_rev_prompt_end def __init__ ( self , psql_args : str ) : SumDistinctChecker ( sanitized_sql , qep_analysis ) .check ( ) CaselessLiteral , to pick up relevant SQL statements for the hook function . potential_future_contents : str = '\n'.join ( # If we have a semantic error message waiting and there is a fresh `` user= '' + self.pg_user `` `` '' Parse for syntax error output . self.tok_pre_host + self.tok_host + \ conn ) .check ( ) : returns : syntax error message from 'ERROR : ' to last '^ ' . self.pg4n_message = self.semantic_analyze ( parsed_sql_query ) qep_analysis : QEPAnalysis = QEPParser ( conn=conn ) .parse ( sql_query ) version_info = \ `` - ? > '' , `` * ? > '' , `` \ ' ? > '' , `` \ '' ? > '' , `` $ ? > '' , `` ( ? > '' ] : returns : an empty string if current version has been tested , \ `` dbname= '' + self.pg_name psql.ofilter ( b'SELECT ' ) bytes.decode ( latest_output ) ) ! = [ ] : # there is new prompt self.match_rev_any_sql_stmt + Word ( self.prompt_chars ) psql.ofilter ( b'\r\x1b [ C ' ) # ( Return is always at least 2 length ) psql.ofilter ( b'\r\x1b [ K\x1b > \x1b [ r\x1b [ ? 1049l ' ) reversed_flattened_res : str = \ # input does not trigger parsing ( Return is always at least 2 length ) psql._intercept ( b'orders ' ) potential_future_screen = \ results = [ res_list [ 3 ] [ : :-1 ] , potential_future_screen_output_sink.feed ( psql.ofilter ( b'SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; ' ) import sys psql._intercept ( b'\r\x1b [ K\x1b > \x1b [ r\x1b [ ? 1049l ' ) : returns : if output is a fresh prompt . ImpliedExpressionChecker ( sanitized_sql , sql_query , if version == `` '' : c.interact ( input_filter=lambda x : x , output_filter=self._intercept ) latest_output : bytes : param prompt : is where the message is injected . A fresh prompt is \ sanitized_sql : exp.Expression = sql_parser.parse_one ( sql_query ) # debug creates pyte.screen ( current screenscraping context ) and Opt ( Literal ( ' * ' ) | Literal ( ' ! ' ) | Literal ( ' ? ' ) , `` '' ) stmt_res = match_error_statement.parse_string ( psql_rev ) pexpect.spawn ( `` psql `` + bytes.decode ( self.psql_args ) psql.ofilter ( b'\x08\x08 ' ) psql.ofilter ( b'\r\n ' ) def ofilter ( self , output : bytes ) - > bytes : : returns : a prompt with injected message , or unchanged if \ `` `` '' Forward output to ` _check_and_act_on_repl_output ` and feed \ StrangeHavingChecker ( sanitized_sql , qep_analysis ) .check ( ) def parse_syntax_error ( self , psql : str ) - > str : # magic strings ( related at least to ctrl-R use ) are lambda x , y : x + y [ : :-1 ] , results , `` '' else : from pyparsing import \ ) - > None : `` `` '' Detect when psql query evaluation has ended by parsing for a new prompt . psql._intercept ( b'\x1b [ ? 2004htest_db- # ' ) psql._intercept ( b ' ; ' ) assert p.parse_last_stmt ( case_empirical_1 ) == \ # from .inconsistent_expression_checker import InconsistentExpressionChecker `` `` '' Forward output to ` check_and_act_on_repl_output ( ) ` and feed \ with . CaselessLiteral , Char , Combine , Literal , ParseException , \ # and resulting message is saved here until when new prompt comes in # Inconsistent expression from functools import reduce # just match against a list of all possible combinations hook_semantic_f : Callable [ [ str ] , str ] , `` user= '' + self.pg_user # % / % R % x % # per postgres bin/psql/settings.h except ParseException as e : : returns : if user has indeed hit return . sql_query : str if len ( res_list ) == 2 : # parsing stops right after database name # replacing \n 's with `` '' maybe has less edge cases . Or actually more . sanitized_sql , `` SELECT * FROM orders WHERE order_total_eur = 100 ; '' # tok_multiline_prompt_end : ParserElement = \ `` `` '' Initiate session by getting psql connection parameters via psql \ # % / = current database psql_rev : str = psql [ : :-1 ] # slicing is fastest operation for reverse self.parser.parse_last_found_stmt ( screen ) self.pg_name `` psql `` + bytes.decode ( self.psql_args ) + `` -- version '' | Literal ( `` \x08\r\n '' [ : :-1 ] ) demultilined_res : str = no_newlines_res psql._intercept ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C1 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 1\x1b [ 27m00 ; \x08\x08\x08\x08\x08\x08 '' ) # e.g . `` pg4n -- help '' is being run . # should parse as \n - > `` `` to avoid `` SELECT * FROM .. '' . print ( `` pg4n [ psql arguments ] < database name > '' ) # get terminal screen contents # superusers have = # prompt # Literal ( '\ '' ' ) | Literal ( ' $ ' ) | Literal ( ' ( ' ) ) # multiple elements into one . These are often combined to build functions elif len ( res_list ) == 2 : # parsing stops right after database name # Analysis is always done when user presses Return [ `` # = '' ] self.pg_pass , Literal ( `` > = '' ) | Literal ( `` # = '' ) with psycopg.connect ( `` host= '' + self.pg_host def start ( # SELECT in subquery Word ( nums ) # Inconsistent expression InconsistentExpressionChecker ( sanitized_sql , qep_analysis ) .check ( ) psql.ofilter ( b'orders ' ) # possibly provide a message to be included in next new prompt . stmt_chars : str = \ Control is only returned after psql process exits . tok_marker_caret : ParserElement = Literal ( `` ^ '' ) ZeroOrMore ( White ( ) ) from typing import List control codes . \n is newline ( carriage return \r will be added by \ multiline_prompt_ends : list [ str ] = \ assert p.parse_last_stmt ( case_query_with_newline ) == \ [ `` - # '' , `` * # '' , `` \ ' # '' , `` \ '' # '' , `` $ # '' , `` ( # '' , `` SELECT * FROM orders WHERE order_total_eur = 100 ; '' ZeroOrMore ( Char ( `` \n '' ) | Char ( `` \r '' ) | White ( ) ) debug : bool = False match_rev_prompt_and_then_rest : ParserElement = ( psql.ofilter ( case_psql_start ) stmt_res : Optional [ ParseResults ] = None assert p.parse_last_found_stmt ( case_multiple_queries_and_whitespaces ) == \ respectively . self `` `` '' Parse for a fresh prompt and everything preceding it into 2-length \ f.write ( '\n'.join ( line.rstrip ( ) for line in self.pyte_screen.display ) # and resulting message is saved until when new prompt comes in bytes.decode ( output , `` utf-8 '' ) output_filter=self.ofilter ) `` -- version '' ) stmt_chars : str = printable.translate ( str.maketrans ( `` '' , `` '' , stmt_end ) ) ) sql_parser : returns : unchanged input . SubqueryOrderByChecker ( sanitized_sql , qep_analysis ) .check ( ) psql._intercept ( b ' * ' ) `` - ! # '' , `` * ! # '' , `` \ ' ! # '' , `` \ '' ! # '' , `` $ ! # '' , `` ( ! # '' , messages are passed to , and from which corresponding warning messages \ detecting new prompt fails . sem_router = SemanticRouter ( * conn_info ) # asterisk unpacks the 5-tuple pg_name : str return assert p.parse_new_prompt ( case_trivial ) == \ `` utf-8 '' print_msg + `` \r\n\r\n '' : param input : user input characters . stmt_res_list [ 1 ] ] # `` pgdb= > SELECT def test_parse_last_found_stmt ( ) - > None : : param prompt : is output where message is injected to . A fresh prompt \ ) .check ( ) ] # * FROM orders WHERE order_total_eur = 100 ; c.interact ( input_filter=self.ifilter , psql._intercept ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 10\x1b [ 27m0 ; \x08\x08\x08\x08\x08\x08 '' ) analysis_result = StrangeHavingChecker ( `` utf-8 '' ) psql._intercept ( b'\r\n ' ) res_list [ 3 ] [ : :-1 ] , def parse_magical_return ( self , psql : str ) - > List [ str ] : return bytes ( split_prompt [ 0 ] + `` \r\n '' split_prompt : List [ str ] = self.parser.parse_new_prompt_and_rest ( tok_stmt_end : ParserElement = Char ( ' ; ' ) sql_parser : SqlParser = SqlParser ( conn ) `` Pg4n has only been tested on psql versions `` `` `` '' Handle semantic analysis modules . '' '' '' psql._intercept ( b '' \r\n\x1b [ ? 2004l\r '' ) `` . '' elif len ( res_list ) == 4 : # results include \x1b [ ? 2004h .. EqWildcardChecker ( sanitized_sql , qep_analysis ) .check ( ) # reverse string for parsing efficiency syntax_error = \ def test_intercept ( ) - > None : if analysis_result is not None : sem_router.run_analysis , psql._intercept ( b'\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) # magic strings related seemingly solely to ctrl-R use are bytes.decode ( output , `` utf-8 '' ) ) ! = [ ] : `` - * # '' , `` * * # '' , `` \ ' * # '' , `` \ '' * # '' , `` $ * # '' , `` ( * # '' , parsed_sql_query : str = self.parser.parse_last_stmt ( screen ) results : List [ str ] = [ ] ParseException , ParserElement , \ psql_output = pexpect.spawn ( # `` \r\n\x1b [ ? 2004l\r '' , `` \r\n\r\r\n '' and `` \x08\r\n '' . encoding= '' utf-8 '' , psql_output.expect ( pexpect.EOF ) self.pg4n_message = `` '' # Strange HAVING clause without GROUP BY self.pg4n_message = self.syntax_analyze ( syntax_error ) psql._intercept ( b'\x1b [ ? 2004l\r\x1b [ ? 2004htest_db- # ' ) assert psql.ofilter ( b'\x1b [ ? 2004l\r order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004htest_db= # ' ) == \ def main ( ) - > None : str ( self.supported_psql_versions ) + `` . '' if magical_return_res : assert p.parse_last_found_stmt ( case_trivial ) == \ # This will match against `` % R % x % # `` , e.g `` = > `` . # Strange HAVING clause without GROUP BY line.rstrip ( ) for line in self.pyte_screen.display ) parsed_sql_query : str = \ if stmt_res : def start ( self ) - > None : self : param db_name_parameter : is name of database we are connecting to . # % R = - , * , ' , `` ; also $ , ( if syntax_error ! = `` '' : return analysis_result : param psql : screenscraped psql string with only whitespace \ list , facilitating easy message injection . `` - > '' , `` * > '' , `` \ ' > '' , `` \ '' > '' , `` $ > '' , `` ( > '' , `` host= '' + self.pg_host self.tok_pre_port + self.tok_port + \ psql.ofilter ( b '' \r\n\x1b [ ? 2004l\r '' ) # no syntax error analysis : psql.ofilter ( b ' ; ' ) match_rev_prompt_end : ParserElement = self.tok_rev_prompt_end return has_new_prompt assert p.parse_last_found_stmt ( case_query_with_newline ) == \ pg_pass : str , assert psql._intercept ( b'\x1b [ ? 2004l\r order_id | order_total_eur | customer_id \r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\r\n ( 0 rows ) \r\n\r\n\x1b [ ? 2004htest_db= # ' ) == \ psql.ofilter ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 100\x1b [ 27m ; \x08\x08\x08\x08\x08\x08 '' ) name . psql._intercept ( b '' \x1b [ A\rtest_db= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; \x1b [ K\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\r\n\r '' ) psql.ofilter ( b'\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) psql._intercept ( b'FROM ' ) f.write ( str ( e.explain ( ) ) + `` \n '' ) columns def ifilter ( self , input : bytes ) - > bytes : from typing import Optional except ParseException as e : | ( # or continue \x1b [ ? .. [ ' # = ' ] . def __init__ ( new_output : bytes = self._replace_prompt ( latest_output ) # as interesting things usually are at end of a long string . printable.translate ( str.maketrans ( `` '' , `` '' , stmt_end ) ) ) - > str : StringEnd ( ) from typing import Optional psql._intercept ( b'\x08\x08 ' ) def parse_last_found_stmt ( self , psql : str ) - > str : deepcopy ( self.pyte_screen ) ) self.parser.parse_syntax_error ( potential_future_contents ) # cheaper and easier to reverse & start from the end # % # = # , > from .psqlconninfo import PsqlConnInfo : param hook_semantic_f : is a callback to which scraped SQL queries are\ # for optimization reasons , check output only if len ( ) > 1 , so keyboard psql._intercept ( b'SELECT ' ) [ `` > = '' ] from copy import deepcopy assert p.parse_last_stmt ( case_select_then_insert ) == \ Word ( nums ) psql.ofilter ( case_query_1 ) from .psqlparser import PsqlParser evaluation has ended . ) if self.debug : : returns : an empty list if no presses are found . \ # This will match against `` % R % x % # `` , e.g `` - > `` . # SELECT in subquery Char , res_list = prompt_res.as_list ( ) output : bytes pg_port : str , from functools import reduce return ( # * FROM orders WHERE order_total_eur = 100 ; '' # % x = nothing , * , ! , ? c = pexpect.spawn ( `` psql `` + bytes.decode ( self.psql_args ) , # ( Literal ( '- ' ) | Literal ( ' * ' ) | Literal ( '\ '' ) | # semantic analysis : from .psqlconninfo import PsqlConnInfo split_prompt [ 1 ] , assert psql.ofilter ( case_query_2_prompt ) == \ psql._intercept ( b '' '\r ( reverse-i-search ) ` ' : `` ) | Literal ( `` \x08\r\n '' [ : :-1 ] ) results = magical_return_res.as_list ( ) tok_rev_prompt_end : ParserElement = Combine ( match_select_stmt : ParserElement = ( demultilined_res = no_newlines_res\ self.pg_port , new_output : bytes = self._check_and_act_on_repl_output ( output ) return `` '' # No semantic errors found ZeroOrMore , assert p.parse_new_prompt ( case_mixed_results ) == \ # should convert \n - > `` `` to avoid `` SELECT * FROM .. '' . hook_f : Callable [ [ str ] , str ] , parser : PsqlParser ) : e.explain ( ) ) Literal ( `` \r\n\x1b [ ? 2004l\r '' [ : :-1 ] ) : param psql : screenscraped psql string res_list [ 0 ] [ : :-1 ] def _check_psql_version ( self ) - > str : # Replacing \n 's with `` `` seems to have less edge cases . self.pg_host , `` `` '' Check PostgreSQL version via psql child process and match \ stmt_res_list [ length - 4 ] ) : stmt_res_list [ length - 4 ] ] return new_output match_rev_any_sql_stmt : ParserElement = \ c = pexpect.spawn ( passed to , and from which corresponding semantic warning messages are \ self.pg_user , wrapper ) . `` psql `` assert p.output_has_new_prompt ( case_trivial ) split_prompt [ 0 ] + `` \r\n '' otherwise a warning message . # `` pgdb= > SELECT * FROM orders WHERE order_tot # either by only having single element , or using Combine to squash ) # should parse as \n - > `` '' psql._intercept ( b'\x1b [ ? 2004l\r\x1b [ ? 1049h\x1b=\r order_id | order_total_eur | customer_id \x1b [ m\r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\x1b [ m\r\n 1 | 535.36 | 111\x1b [ m\r\n 2 | 409.80 | 217\x1b [ m\r\n 3 | 189.43 | 19\x1b [ m\r\n 4 | 144.14 | 157\x1b [ m\r\n 5 | 582.52 | 172\x1b [ m\r\n 6 | 132.85 | 206\x1b [ m\r\n 7 | 183.92 | 236\x1b [ m\r\n 8 | 424.80 | 244\x1b [ m\r\n 9 | 519.43 | 175\x1b [ m\r\n 10 | 414.55 | 234\x1b [ m\r\n 11 | 88.19 | 50\x1b [ m\r\n 12 | 591.72 | 143\x1b [ m\r\n 13 | 503.52 | 216\x1b [ m\r\n 14 | 586.06 | 181\x1b [ m\r\n 15 | 47.79 | 248\x1b [ m\r\n 16 | 330.92 | 130\x1b [ m\r\n 17 | 302.31 | 225\x1b [ m\r\n 18 | 438.38 | 26\x1b [ m\r\n 19 | 107.53 | 94\x1b [ m\r\n 20 | ' self.tok_pre_host + self.tok_host ParseResults , return prompt # prompt is malformed and is returned as-is . line.rstrip ( ) for line in self.pyte_screen.display ) ) assert p.parse_magical_return ( case_long_return ) == \ stmt_res_list [ 2 ] , psql._intercept ( case_psql_start ) ParserElement.setDefaultWhitespaceChars ( `` ) to and from which semantic error messages are received in return . `` `` '' Parse for an empty prompt , to detect when a query \ from .psqlwrapper import PsqlWrapper has_new_prompt : bool = False # asterisk unpacks the 5-tuple match_psql_conninfo : ParserElement = ( match_rev_prompt_end : ParserElement = \ stmt_res : ParseResults = None `` `` '' Parse for an empty prompt and everything preceding it \ # should convert \n - > `` '' to avoid `` order_tot al_eur '' # Implied expression ParseException , def output_has_new_prompt ( self , psql : str ) - > bool : : returns : if user has hit return . .replace ( db_name + `` - # '' , `` '' ) psql._intercept ( b'\x08\x08\x08\x08\x08\x08 ' ) `` - ? # '' , `` * ? # '' , `` \ ' ? # '' , `` \ '' ? # '' , `` $ ? # '' , `` ( ? # '' , results = [ `` , match_version_stmt : ParserElement = ( debug : bool = False if stmt_res is not None : analysis_result = \ assert p.output_has_magical_return ( case_long_return ) # ORDER BY in subquery : param hook_f : is a callback to which scraped SQL queries are passed \ output to pyte screen for future screen-scraping . `` `` '' User input filter function for pexpect.interact : not used . Stream ( potential_future_screen ) stmt_res_list [ length - 3 ] , Word ( self.prompt_chars ) + \ magical_return_res = \ Literal ( `` ? [ \x1b '' ) # in this case control code parameter self.pg_pass , ( StringEnd ( ) # output may stop at end of db name , return results match_rev_any_sql_stmt [ `` \rl4002 ? [ \x1b\n\r '' ] is expected , or otherwise no injection is made . match_select_stmt : ParserElement = \ Literal , Word , \ results = [ stmt_res_list [ 3 ] , analysis_result = ImpliedExpressionChecker ( psql.ofilter ( b'\x08order_total_eur = 0 AND order_total_eur = 10\x1b [ C\x1b [ 1P ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) `` port= '' + self.pg_port Opt , conn White , def main ( ) - > None : lambda syntax_error_analysis : `` '' , psql._intercept ( b'\r\x1b [ C ' ) with psycopg.connect ( results = [ stmt_res_list [ length - 3 ] , intercepted output . '' '' '' str ( self.supported_psql_versions ) sem_router = SemanticRouter ( * conn_info ) version_msg = self._check_psql_version ( ) def output_has_magical_return ( self , psql : str ) - > bool : identbodychars , nums psql._intercept ( b'\r\n\x1b [ ? 2004l\r ' ) # feed query to semantic analysis hook function # save a potential warning to be included in before next fresh prompt . # breaks , because both of these work right in straight psql . See : # ORDER BY in subquery ParseResults , ParserElement , StringEnd , White , Word , ZeroOrMore , \ # tok , or token , is parsing element with only single element output , psql._intercept ( b'\x08order_total_eur = 0 AND order_total_eur = 1\x1b [ 1P00 ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) self.match_rev_magical_returns.parse_string ( psql_rev ) new_output = self._replace_prompt ( latest_output ) lambda x , y : x + y , sys.argv [ 1 : ] , `` '' ... : returns : if output has a weird Return press . ) : print ( e.explain ( ) ) ZeroOrMore ( White ( ) ) + CaselessLiteral ( `` SELECT '' ) match_psql_conninfo : ParserElement = \ self.pg_user , CaselessLiteral ( `` SELECT '' ) PsqlParser ( ) self.semantic_analyze : Callable [ [ str ] , str ] = hook_semantic_f Literal ( `` \r\n\x1b [ ? 2004l\r '' [ : :-1 ] ) \ from shutil import get_terminal_size # Parsing functions common to more than 1 parsing functions are listed here # TODO ( ? ) : We may have to match for errors def get ( self ) - > ( str , str , str , str , str ) : results = [ ) unreversed_flattened_res : str = \ # If there is a fresh prompt : tok_rev_prompt_end : ParserElement = \ # for simplicity , just use pexpect here prompt_res : ParseResults = None psql._intercept ( b'\x08order_total_eur = 0 AND order_total_eur = 10\x1b [ C\x1b [ 1P ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) qep_analysis : QEPAnalysis = QEPParser ( conn=conn ) .parse ( sql_query ) # Wildcards without LIKE if self.pg4n_message ! = `` '' : # Implied expression Only one ( static ) class instance is intended for use in program . demultilined_res = demultilined_res.replace ( prompt , `` '' ) output to pyte screen for screenscraping . # keyboard input does not trigger parsing f = open ( `` psqlparser.log '' , `` a '' ) psql.ofilter ( b '' \x08\x08\x08= ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m=\x1b [ 27m 100 ; \x08\x08\x08\x08\x08\x08 '' ) self.analyze : Callable [ [ str ] , str ] = hook_f psql._intercept ( return_press_1 ) psql = PsqlWrapper ( assert p.parse_last_stmt ( case_multiple_queries_and_whitespaces ) == \ # command-line arguments prevent interactive sessions ( e.g pg4n -- help ) if prompt_res : # To save time , since linebreak prompts are only removed , match_rev_any_sql_stmt : ParserElement = ( psql._intercept ( b'SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; ' ) analysis_result = SubqueryOrderByChecker ( sys.argv [ 1 ] .encode ( `` utf-8 '' ) , `` password= '' + self.pg_pass psql.ofilter ( b '' \x1b [ A\rtest_db= # SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur = 100 ; \x1b [ K\x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\r\n\r '' ) ParserElement , tok_stmt_end : ParserElement = \ and then starting the session . '' '' '' psql.ofilter ( b'\x08order_total_eur = 0 AND order_total_eur = 1\x1b [ 1P00 ; \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C ' ) psql.ofilter ( b'FROM ' ) print ( e.explain ( ) ) from .semanticrouter import SemanticRouter psql.ofilter ( return_press_1 ) Combine , dimensions= ( self.rows , self.cols ) ( StringEnd ( ) | ( Literal ( `` ? [ \x1b '' ) self.pg_tuple : Optional [ Tuple [ str , str , str , str , str ] ] = None : returns : a prompt with injected message . ) as conn : self.syntax_analyze : Callable [ [ str ] , str ] = hook_syntax_f sanitized_sql : exp.Expression = sql_parser.parse_one ( sql_query ) ( Literal ( '= ' ) | Literal ( '^ ' ) ) has_new_prompt = True child process , initializing semantic analysis and wrapper modules , \ def run_analysis ( self , sql_query : str ) - > str : # Comparing different domains return `` '' # No semantic errors found def run_analysis ( psql.ofilter ( b'\x1b [ ? 2004l\r\x1b [ ? 2004htest_db- # ' ) analysis_result : Optional [ str ] = None List is empty if no fresh prompt was found . Combine ( res_list [ 1 ] [ : :-1 ] + res_list [ 0 ] [ : :-1 ] split_prompt : List [ str ] = \ potential_future_screen_output_sink = \ version_msg = self.check_psql_version ( ) return `` '' # ( Literal ( ' # ' ) | Literal ( ' > ' ) ) ) expected . # and save resulting message bytes.decode ( prompt , `` utf-8 '' ) ) - > Optional [ Tuple [ str , str , str , str , str ] ] : | Literal ( `` \r\n\r\r\n '' [ : :-1 ] ) self.pg_port , : returns : a two-part list with everything before the prompt \ f.close ( ) psql.ofilter ( b ' * ' ) sem_router.run_analysis , tok_rev_error self.pg4n_message = `` '' tok_marker_caret parser : PsqlParser # an insightful syntax error message from the syntax analysis . tok_rev_prompt_end if conn_info is not None : return unreversed_flattened_res against versions pg4n is tested with . prompt = db_name + multiline_prompt_end `` password= '' + self.pg_pass ) as conn : f.write ( '\n'.join ( ... + StringEnd ( ) ) ) ] reduce ( # Combine ( psql.start ( ) match_rev_magical_returns : ParserElement = ( ] pg_port : str , : param hook_syntax_f : is a callback to which scraped syntax error \ `` `` '' Start psql process and then start feeding hook function with \ # ^either stops after dbname or includes \x1b [ ? 2004l ... if self.parser.parse_magical_return ( identbodychars , has_magical_return : bool = False hook_syntax_f : Callable [ [ str ] , str ] , nums # for matching . # match_error : ParserElement = \ : param psql_args : are the command-line arguments pg4n has been called \ def get ( # TODO/BUG : removing \n 's is a tough problem , see : prompt_res = match_rev_prompt_and_then_rest.parse_string ( psql_rev ) # ParserElement for these would look this : dimensions= ( self.rows , self.cols ) ) # prompt2 per bin/psql/prompt.c : new_output : bytes = self.check_and_act_on_repl_output ( output ) ZeroOrMore ( Char ( `` \n '' ) | Char ( `` \r '' ) | White ( ) ) + \ # Reversing happens for performance reasons , self.tok_pre_port + self.tok_port assert p.parse_last_found_stmt ( case_empirical_1 ) == \ 5-tuple or None . psql_args : bytes , # feed query to hook function and save resulting message # Psql is not connecting to any database , psql._intercept ( b'\x08\x08\x08\x08 ' ) def _intercept ( # `` \r\n\x1b [ ? 2004l\r '' , `` \r\n\r\r\n '' and `` \x08\r\n '' . # If we have a semantic error message waiting def __init__ ( self , def parse_last_stmt ( self , psql : str ) - > str : # from functools import reduce assert p.parse_last_found_stmt ( case_select_then_select ) == \ # Replacing \n 's has some edge cases where wrapper transparency Word ( self.prompt_chars ) `` - * > '' , `` * * > '' , `` \ ' * > '' , `` \ '' * > '' , `` $ * > '' , `` ( * > '' , magical_return_res : ParseResults = None `` dbname= '' + self.pg_name '' , pg_host : str , assert p.parse_last_stmt ( case_multiline_query ) == \ PsqlParser ( ) ) psql.ofilter ( b'\x08\x08\x08\x08 ' ) columns : list [ Column ] = sql_parser.get_query_columns ( sanitized_sql ) return ( self.pg_host , magical_return_res = \ from .psqlparser import PsqlParser sql_query , ) line.rstrip ( ) for line in potential_future_screen.display pg_pass : str , magical_return_res : Optional [ ParseResults ] = None | Literal ( `` \r\n\r\r\n '' [ : :-1 ] ) \ analysis_result = InconsistentExpressionChecker ( # `` = > SELECT * FROM orders WHERE order_tot reduce ( lambda x , y : x + y [ : :-1 ] , results , `` '' ) ParserElement.setDefaultWhitespaceChars ( `` '' ) # % R = = , ^ assert psql.ofilter ( b'\x1b [ ? 2004htest_db= # ' ) == \ # Based on exploratory testing , screen : str = '\n'.join ( if split_prompt == [ ] : name . '' '' '' assert p.parse_last_found_stmt ( case_select_then_insert ) == \ pg_name : str if analysis_result is not None : ZeroOrMore ( White ( ) ) + tok_stmt_end + ... + \ no_newlines_res = reversed_flattened_res.replace ( '\n ' , ' ' ) columns : list [ Column ] = sql_parser.get_query_columns ( sanitized_sql ) from .psqlwrapper import PsqlWrapper import sys psql.ofilter ( b'\x08\x08\x08\x08\x08\x08 ' ) self.tok_rev_prompt_end + \ print ( bytes.decode ( psql_output.before ) ) new_output : bytes = `` '' results = prompt_res.as_list ( ) stmt_res_list = stmt_res.as_list ( ) # SUM/AVG ( DISTINCT ) import pexpect psql._intercept ( b '' \x08\x08\x08= ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m=\x1b [ 27m 100 ; \x08\x08\x08\x08\x08\x08 '' ) ... # has already been parsed as prompt_chars prompt_res = match_rev_prompt_and_then_rest.parse_string ( psql_rev ) import os Opt ( White ( ) ) ... control codes and newlines ( without carriage returns ) . from .semanticrouter import SemanticRouter def __init__ ( self , psql_args : bytes , screen : str = \ return new_output has_magical_return = True for multiline_prompt_end in self.multiline_prompt_ends : match_version_stmt : ParserElement = \ lambda x : `` '' , assert psql._intercept ( b'\x1b [ ? 2004htest_db= # ' ) == \ : returns : ( hostname , port , user , password , database name ) \ match_rev_prompt_and_then_rest : ParserElement = \ self.pg4n_message = self.analyze ( parsed_sql_query ) `` `` '' Parse for weird Return presses . res_list = prompt_res.as_list ( ) # optimization : do not spend time parsing if there is no message : # 'rev ' in variable names is shorthand for reversed . Otherwise has newline text . received in return . print ( `` Fatal error : psql connection info could not be parsed\n '' to 2 cells . psql_rev = psql [ : :-1 ] psql.ofilter ( b'\x1b [ ? 2004l\r\x1b [ ? 1049h\x1b=\r order_id | order_total_eur | customer_id \x1b [ m\r\n -- -- -- -- -- + -- -- -- -- -- -- -- -- -+ -- -- -- -- -- -- -\x1b [ m\r\n 1 | 535.36 | 111\x1b [ m\r\n 2 | 409.80 | 217\x1b [ m\r\n 3 | 189.43 | 19\x1b [ m\r\n 4 | 144.14 | 157\x1b [ m\r\n 5 | 582.52 | 172\x1b [ m\r\n 6 | 132.85 | 206\x1b [ m\r\n 7 | 183.92 | 236\x1b [ m\r\n 8 | 424.80 | 244\x1b [ m\r\n 9 | 519.43 | 175\x1b [ m\r\n 10 | 414.55 | 234\x1b [ m\r\n 11 | 88.19 | 50\x1b [ m\r\n 12 | 591.72 | 143\x1b [ m\r\n 13 | 503.52 | 216\x1b [ m\r\n 14 | 586.06 | 181\x1b [ m\r\n 15 | 47.79 | 248\x1b [ m\r\n 16 | 330.92 | 130\x1b [ m\r\n 17 | 302.31 | 225\x1b [ m\r\n 18 | 438.38 | 26\x1b [ m\r\n 19 | 107.53 | 94\x1b [ m\r\n 20 | ' analysis_result = SumDistinctChecker ( match_error_statement : ParserElement = ( version_info = pexpect.spawn ( `` `` '' psql.ofilter ( b '' \x1b [ A\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C\x1b [ C0 ' : SELECT * FROM orders WHERE order_total_eur = 0 AND order_total_eur \x1b [ 7m= 10\x1b [ 27m0 ; \x08\x08\x08\x08\x08\x08 '' ) : param psql : screen-scraped psql output . # psqlwrapper.log ( capturing terminal stream ) in working directory return analysis_result self.pg_name ) self.tok_pre_user + self.tok_user + \ results : list [ str ] = [ ]","['src/pg4n/main.py', 'src/pg4n/psqlconninfo.py', 'src/pg4n/psqlparser.py', 'src/pg4n/psqlwrapper.py', 'src/pg4n/semanticrouter.py', 'src/pg4n/test/test_psqlparser.py', 'src/pg4n/test/test_psqlwrapper.py']",2022-11-21 09:53:55+00:00,2022-12-12 12:47:04+00:00,2022-12-12 14:47:03+02:00
91,6c5e663747462817aa670b59addb191b618c5eb9,0.0029461332596838,0,QEPParser executes sql queries prefixed with ` EXPLAIN ANALYZE ` using the psycopg library . The program crashes when psycopg detects sql error and throws an exception that is not caught in QEPParser . Exploration / partial fix in branch tmp/qepparser-crash,Fix QEPParser crashes on sql syntax errors,Merge pull request # 29 from Project-C-SQL/feat/qep-parser,"return QEPNode ( self._qep [ `` Plan '' ] ) assert qep.root [ 0 ] .plan [ `` Node Type '' ] == `` Index Scan '' assert qep.plan [ `` Alias '' ] == `` stories '' load= [ load_database ] , class QEPAnalysis : def __call__ ( self , stmt : str , * args , * * kwargs ) - > QEPAnalysis : if ( n : = len ( res [ 0 ] [ 0 ] ) ) ! = 1 : drop table if exists users ; with conn.cursor ( ) as cur : `` `` '' The root node of the query execution plan . '' '' '' if ( n : = len ( res ) ) ! = 1 : # TODO : break into variants discriminated by Node Type def qep ( self ) - > qep : def find ( self , pred : Callable [ [ node ] , bool ] ) - > list [ node ] : `` `` '' A node in a query execution plan . '' '' '' qep = parser ( `` select * from stories '' ) `` Actual Startup Time '' : float , import qepparser self._ref = not not conn qep = parser ( `` select * from users where id = 1 '' ) story_id integer references stories ( id ) on delete cascade , return self._node.__repr__ ( ) password=getenv ( `` POSTGRES_PASSWORD '' , `` postgres '' ) ) `` Actual Total Time '' : float , self._conn : connection = conn or psycopg2.connect ( * args , * * kwargs ) qep = parser ( `` select * from users '' ) stmt : The query to execute . `` `` '' Performs analyses on given queries , returning resultant QEPAnalysis . '' '' '' qep = parser ( `` select * from stories where id = 1 '' ) return map ( QEPNode , self._node [ `` Plans '' ] ) } ) self._conn.rollback ( ) `` Index Cond '' : str , qep = parser ( `` select * from comments '' ) def __iter__ ( self ) - > Iterable [ `` QEPNode '' ] : return self._qep.__repr__ ( ) import psycopg2 `` `` '' A dict of the node 's properties . '' '' '' insert into users ( name ) values ( 'user1 ' ) ; def __len__ ( self ) - > int : return list ( filter ( pred , self._node [ `` Plans '' ] ) ) insert into stories ( name ) values ( 'story2 ' ) ; postgresql_in_docker = factories.postgresql_noproc ( `` Plan Width '' : int , `` Actual Loops '' : int , insert into users ( name ) values ( 'user2 ' ) ; from typing import Callable , Iterable , List , TypedDict assert qep.plan [ `` Actual Rows '' ] == 1 def __init__ ( self , * args , conn=None , * * kwargs ) : return self._node create table stories ( id serial primary key , name varchar ) ; `` `` '' Get the child node at the given index . '' '' '' return self._qep [ `` Plan '' ] `` `` '' Represents the result of EXPLAIN ANALYZE . '' '' '' return QEPNode ( self._node [ `` Plans '' ] [ key ] ) comment varchar ) ; from pytest_postgresql import factories return self._qep `` Actual Rows '' : int , def __del__ ( self ) : from os import getenv `` Scan Direction '' : str , `` Total Runtime '' : float , `` `` '' Test that the QEP structure is as expected . '' '' '' return QEPAnalysis ( res [ 0 ] [ 0 ] [ 0 ] ) A dictionary representing the query execution plan . insert into comments ( story_id , user_id , comment ) values ( 1 , 1 , 'comment1 ' ) ; postgresql = factories.postgresql ( `` postgresql_in_docker '' ) drop table if exists comments ; `` Plan Rows '' : int , def plan ( self ) - > node : qep = parser ( `` select * from stories where id = 1 or id = 2 '' ) Parameters : assert qep.root [ 0 ] .plan [ `` Relation Name '' ] == `` users '' qep = parser ( `` select * from comments where id = 1 and id = 2 '' ) conn.commit ( ) assert qep.root [ 0 ] .plan [ `` Relation Name '' ] == `` stories '' raise ValueError ( f '' Expected dict in column , got { t } '' ) self._qep = qep_ qep = parser ( `` select * from comments where id = 1 '' ) demonstrates relational data assert qep.root [ 0 ] .plan [ `` Alias '' ] == `` users '' `` Plans '' : List [ `` node '' ] , insert into comments ( story_id , user_id , comment ) values ( 2 , 2 , 'comment4 ' ) ; def __getitem__ ( self , key : int ) - > `` QEPNode '' : `` `` '' A dict of the root node 's properties . '' '' '' `` `` '' Iterate over child nodes . '' '' '' assert qep.plan [ `` Node Type '' ] == `` Index Scan '' # are available for each node type `` Filter '' : str , assert qep.root [ 0 ] .plan [ `` Actual Rows '' ] == 0 assert qep.plan [ `` Alias '' ] == `` users '' def __init__ ( self , node_ : node ) : assert qep.plan [ `` Relation Name '' ] == `` users '' return self ( stmt , * args , * * kwargs ) def test_qep_structure ( parser : qepparser.QEPParser ) : return len ( self._node [ `` Plans '' ] ) * * kwargs : Keyword arguments to pass to cursor.execute ( ) . return self._node [ `` Plans '' ] class QEPNode : assert qep.plan [ `` Relation Name '' ] == `` comments '' import pytest `` Triggers '' : list [ str ] , `` Execution Time '' : float , node = TypedDict ( `` Plan '' , { assert qep.plan [ `` Node Type '' ] == `` Result '' insert into comments ( story_id , user_id , comment ) values ( 1 , 2 , 'comment2 ' ) ; user_id integer references users ( id ) on delete cascade , def parser ( postgresql : connection ) : assert qep.root [ 0 ] .plan [ `` Alias '' ] == `` stories '' create table comments ( assert qep.plan [ `` Node Type '' ] == `` Seq Scan '' qep = parser ( `` select * from users where id = 1 and id = 2 '' ) def __str__ ( self ) : assert qep.plan [ `` Relation Name '' ] == `` stories '' raise ValueError ( f '' Expected 1 column , got { n } '' ) self._node = node_ def plans ( self ) - > list [ node ] : populate with sample data Returns : stmt = f '' explain ( format json , analyze , verbose ) { stmt.strip ( ) .rstrip ( ' ; ' ) } ; '' `` Planning Time '' : float , user=getenv ( `` POSTGRES_USER '' , `` postgres '' ) , Executes a query and returns the query execution plan as a dictionary . `` `` '' A list of the node 's children . '' '' '' `` Node Type '' : str , # right now , the interface is n't safe to use because it 's not clear what fields drop table if exists stories ; `` `` '' ) self._conn.close ( ) raise ValueError ( f '' Expected 1 item in column , got { n } '' ) def root ( self ) - > QEPNode : for copy-and-pasting insert into stories ( name ) values ( 'story1 ' ) ; conn : connection = psycopg2.connect ( * * kwargs ) `` Relation Name '' : str , id serial primary key , `` `` '' Get the number of child nodes . '' '' '' assert qep.root [ 0 ] .plan [ `` Relation Name '' ] == `` comments '' `` Parent Relationship '' : str , return self._node.__str__ ( ) res = cur.fetchall ( ) qep = parser ( `` select * from users where id = 1 or id = 2 '' ) with self._conn.cursor ( ) as cur : from psycopg2.extensions import connection `` Index Name '' : str , `` `` '' A dict of the query execution plan 's properties . '' '' '' `` Plan '' : node , cur.execute ( stmt , * args , * * kwargs ) cur.execute ( `` '' '' `` Total Cost '' : float , if ( n : = len ( res [ 0 ] ) ) ! = 1 : `` `` '' Find nodes matching the predicate . '' '' '' raise ValueError ( f '' Expected 1 row , got { n } '' ) assert qep.plan [ `` Actual Rows '' ] == 2 if ( t : = type ( res [ 0 ] [ 0 ] [ 0 ] ) ) ! = dict : `` Alias '' : str , '' 'Alias for __call__ '' ' def __repr__ ( self ) : def __init__ ( self , qep_ : qep ) : if not self._ref : assert qep.plan [ `` Node Type '' ] == `` Bitmap Heap Scan '' qep = TypedDict ( `` QEP '' , { def load_database ( * * kwargs ) : assert qep.root [ 0 ] .plan [ `` Alias '' ] == `` comments '' assert qep.plan [ `` Actual Rows '' ] == 4 * text=auto qep = parser ( `` select * from stories where id = 1 and id = 2 '' ) * args : Positional arguments to pass to cursor.execute ( ) . return qepparser.QEPParser ( conn=postgresql ) create table users ( id serial primary key , name varchar ) ; assert qep.plan [ `` Alias '' ] == `` comments '' def parse ( self , stmt : str , * args , * * kwargs ) - > QEPAnalysis : return self._qep.__str__ ( ) `` Startup Cost '' : float , `` `` '' class QEPParser : insert into comments ( story_id , user_id , comment ) values ( 2 , 1 , 'comment3 ' ) ;","['.gitattributes', 'qepparser.py', 'test_qepparser.py']",2022-11-25 12:06:28+00:00,2022-12-16 11:05:51+00:00,2022-10-11 17:32:29+03:00
